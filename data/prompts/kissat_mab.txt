You are designing a restart trigger policy for the Kissat-MAB SAT solver to optimize performance on SAT Competition 2025 benchmarks (400 instances, PAR-2 scoring).

### Task
Design a restart trigger algorithm (conceptual, not code) that decides WHEN the solver should restart. Your policy will replace the `kissat_restarting()` function and must:
- Return a boolean decision (restart now: true/false)
- Run in O(1) amortized time per call
- Use only the signals listed below
- Improve PAR-2 score over baseline

### Search Mode Context

**Focused Mode** (solver->stable = false):
- Uses VSIDS or CHB heuristic (determined by MAB in stable mode)
- Baseline trigger: restart when fast_glue exceeds slow_glue by margin%
- Restart limit updated after each restart: conflicts + restartint + log(restarts)

**Stable Mode** (solver->stable = true):
- Uses reluctant doubling (Luby sequence) for restart intervals
- MAB selects between heuristics (VSIDS=0, CHB=1) after each restart
- Baseline trigger: reluctant.trigger flag via Luby sequence

**Key Insight**: MAB heuristic selection happens OUTSIDE this function (in restart_mab). Your trigger can observe MAB performance signals to make smarter restart timing decisions.

### Available Signals

**Required Guards** (must check these):
- `solver->unassigned` (unsigned) — unassigned variables remaining; must be > 0
- `solver->level` (unsigned) — current decision level; must be > 0
- `GET_OPTION(restart)` (int) — restarts enabled flag; must be true

**Core Statistics** (use macros):
- `CONFLICTS` — total conflicts (uint64_t) [macro for solver->statistics.conflicts]
- `DECISIONS` — total decisions (uint64_t) [macro for solver->statistics.decisions]
- `solver->statistics.restarts` (uint64_t) — total restart count

**Restart Limits**:
- `solver->limits.restart.conflicts` (uint64_t) — next scheduled restart threshold

**Quality Metrics** (use macros):
- `AVERAGE(fast_glue)` (double) — recent learned clause glue EMA [macro for solver->averages[solver->stable].fast_glue.value]
- `AVERAGE(slow_glue)` (double) — baseline learned clause glue EMA
- `AVERAGE(decision_rate)` (double) — decisions per conflict EMA

**Configuration Options**:
- `GET_OPTION(restartmargin)` (int) — glue margin percentage (default: 10, range: 0-25)
- `GET_OPTION(restartint)` (int) — base restart interval (default: varies by version)

**MAB Performance Signals** (stable mode only):
- `solver->mab` (bool) — MAB enabled flag
- `solver->heuristic` (unsigned) — active heuristic: 0=VSIDS, 1=CHB
- `solver->mab_reward[0]` (double) — cumulative reward for VSIDS
- `solver->mab_reward[1]` (double) — cumulative reward for CHB
  * Reward formula: log₂(decisions) / log₂(conflicts) since last restart
  * Higher reward = more solving progress per conflict
- `solver->mab_select[0]` (unsigned) — times VSIDS selected
- `solver->mab_select[1]` (unsigned) — times CHB selected
- `solver->mab_decisions` (double) — decisions made since last restart
- `solver->mab_conflicts` (unsigned) — conflicts since last restart
- `solver->mab_chosen_tot` (unsigned) — total variable selections since last restart
- `solver->mabc` (double) — UCB exploration constant C

**Helper Functions Available**:
- `kissat_reluctant_triggered(&solver->reluctant)` → bool (stable mode Luby trigger)

### Output Format (JSON only)
{
  "name": "Brief algorithm name (≤6 words)",
  "algorithm": "Detailed restart trigger logic. Specify conditions for returning true (restart) vs false (continue). Handle both stable and focused modes. Include quantitative thresholds and tie-breakers.",
  "reason": "Why this improves restart timing using MAB signals (2-3 sentences max). Focus on adaptive benefits for diverse SAT Competition instances."
}

### Constraints
- Do NOT modify MAB state (mab_reward, mab_select, heuristic) — only observe
- Do NOT call kissat_restart() or restart_mab() — this function only decides the trigger
- Must respect baseline behavior unless strong justification: stable mode reluctant doubling is well-tested
- Avoid magic numbers; use GET_OPTION() for configurable parameters

### Baseline Reference
**Current focused mode**: `return (CONFLICTS >= limits.restart.conflicts) && ((1.0 + margin/100.0) * slow_glue <= fast_glue)`
**Current stable mode**: `return (CONFLICTS >= limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant)`
