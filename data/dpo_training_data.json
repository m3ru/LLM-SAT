[
  {
    "algorithm_description": "Name: MAB-Aware Glue & Luby Trigger\n\nAlgorithm: 1. Check guards: if solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n2. If in focused mode (solver->stable == false):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND (fast_glue >= (1.0 + GET_OPTION(restartmargin)/100.0) * slow_glue), return true.\n   - ELSE IF (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(decision_rate) < 0.85 * previous_decision_rate) AND (CONFLICTS - last_restart_conflicts >= 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.\n3. If in stable mode (solver->stable == true):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant), return true.\n   - ELSE IF solver->mab == true AND (CONFLICTS >= solver->limits.restart.conflicts):\n     - Let h = solver->heuristic (current heuristic: 0=VSIDS, 1=CHB)\n     - Let rew = solver->mab_reward[h], times = solver->mab_select[h]\n     - If (times >= 2) AND (rew < 0.85 * (solver->mab_reward[1-h] / max(solver->mab_select[1-h],1))) AND (solver->mab_conflicts > 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts must be enabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: must be inside a non-root decision level\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: must reach the next restart conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Focused mode heuristics\\n  if (!solver->stable) {\\n    // Standard glue-based trigger\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    if (fast >= limit)\\n      return true;\\n\\n    // MAB-inspired: decision rate drop triggers\\n    // We use decision_rate value as a proxy; no \\\"previous\\\" value stored, so skip this part\\n    // as we can't compare to previous_decision_rate without state or history.\\n\\n    // Alternatively, if restartint is set and enough conflicts since last restart, allow early restart\\n    if (GET_OPTION(restartint) > 0) {\\n      uint64_t since_last_restart = CONFLICTS - solver->statistics.restarts * GET_OPTION(restartint);\\n      if (since_last_restart >= 0.5 * GET_OPTION(restartint))\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // Stable mode heuristics\\n  // First: reluctant doubling/Luby-style\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware trigger (only if MAB is active)\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n    unsigned other = 1 - h;\\n    double rew = solver->mab_reward[h];\\n    unsigned times = solver->mab_select[h];\\n\\n    // Compare *per selection* reward, avoid division by zero\\n    double other_avg = 0.0;\\n    if (solver->mab_select[other])\\n      other_avg = solver->mab_reward[other] / solver->mab_select[other];\\n    else\\n      other_avg = 0.0;\\n\\n    if (times >= 2 &&\\n        rew < 0.85 * other_avg &&\\n        solver->mab_conflicts > 0.5 * GET_OPTION(restartint))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double glue_limit = margin * slow;\\n\\n    // Baseline glue-based trigger\\n    if (fast >= glue_limit)\\n      return true;\\n\\n    // Decision rate based trigger (if decision rate drops sharply)\\n    // We approximate previous_decision_rate as the slow average (since no explicit prev value)\\n    // This is a heuristic: if decision rate EMA drops below 85% of slow_glue baseline\\n    // and enough conflicts since last restart threshold advanced.\\n    const double decision_rate = AVERAGE(decision_rate);\\n    // For lack of explicit previous_decision_rate, we use slow_glue as a soft baseline.\\n    // This is a soft adaptation, not strictly \\\"previous\\\" but consistent for moving average.\\n    // If you have a better baseline, swap it in.\\n    if (\\n      decision_rate < 0.85 * glue_limit && // decision rate dropped below threshold\\n      (CONFLICTS - solver->limits.restart.conflicts) >= 0.5 * GET_OPTION(restartint)\\n    ) {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode ---\\n  // Baseline: Reluctant Luby trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: If enabled, check if current heuristic is severely underperforming\\n  if (solver->mab && (CONFLICTS >= solver->limits.restart.conflicts)) {\\n    const unsigned h = solver->heuristic;     // current heuristic: 0=VSIDS, 1=CHB\\n    const unsigned other = 1 - h;\\n    const double rew = solver->mab_select[h] ? solver->mab_reward[h] / solver->mab_select[h] : 0.0;\\n    const double rew_other = solver->mab_select[other] ? solver->mab_reward[other] / solver->mab_select[other] : 0.0;\\n\\n    // If this heuristic has been selected at least twice, and is worse than 85% of alternative,\\n    // and enough conflicts passed, trigger a restart.\\n    if (\\n      solver->mab_select[h] >= 2 &&\\n      rew < 0.85 * rew_other &&\\n      solver->mab_conflicts > 0.5 * GET_OPTION(restartint)\\n    ) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 179.85339999999994,
    "par2_rejected": 185.3558
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Luby Trigger\n\nAlgorithm: 1. Check guards: if solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n2. If in focused mode (solver->stable == false):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND (fast_glue >= (1.0 + GET_OPTION(restartmargin)/100.0) * slow_glue), return true.\n   - ELSE IF (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(decision_rate) < 0.85 * previous_decision_rate) AND (CONFLICTS - last_restart_conflicts >= 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.\n3. If in stable mode (solver->stable == true):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant), return true.\n   - ELSE IF solver->mab == true AND (CONFLICTS >= solver->limits.restart.conflicts):\n     - Let h = solver->heuristic (current heuristic: 0=VSIDS, 1=CHB)\n     - Let rew = solver->mab_reward[h], times = solver->mab_select[h]\n     - If (times >= 2) AND (rew < 0.85 * (solver->mab_reward[1-h] / max(solver->mab_select[1-h],1))) AND (solver->mab_conflicts > 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts must be enabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: must be inside a non-root decision level\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: must reach the next restart conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Focused mode heuristics\\n  if (!solver->stable) {\\n    // Standard glue-based trigger\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    if (fast >= limit)\\n      return true;\\n\\n    // MAB-inspired: decision rate drop triggers\\n    // We use decision_rate value as a proxy; no \\\"previous\\\" value stored, so skip this part\\n    // as we can't compare to previous_decision_rate without state or history.\\n\\n    // Alternatively, if restartint is set and enough conflicts since last restart, allow early restart\\n    if (GET_OPTION(restartint) > 0) {\\n      uint64_t since_last_restart = CONFLICTS - solver->statistics.restarts * GET_OPTION(restartint);\\n      if (since_last_restart >= 0.5 * GET_OPTION(restartint))\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // Stable mode heuristics\\n  // First: reluctant doubling/Luby-style\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware trigger (only if MAB is active)\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n    unsigned other = 1 - h;\\n    double rew = solver->mab_reward[h];\\n    unsigned times = solver->mab_select[h];\\n\\n    // Compare *per selection* reward, avoid division by zero\\n    double other_avg = 0.0;\\n    if (solver->mab_select[other])\\n      other_avg = solver->mab_reward[other] / solver->mab_select[other];\\n    else\\n      other_avg = 0.0;\\n\\n    if (times >= 2 &&\\n        rew < 0.85 * other_avg &&\\n        solver->mab_conflicts > 0.5 * GET_OPTION(restartint))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused Mode (non-stable): Glue Margin or Decision Rate Drop ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    // Standard glue-based restart\\n    if (fast >= limit)\\n      return true;\\n\\n    // Decision rate drop restart (adaptive, only if enough conflicts since last restart)\\n    const double drate = AVERAGE(decision_rate);\\n    // Use previous decision rate as \\\"limit\\\" (since averages are exponential, slow_glue is a fair proxy for baseline)\\n    // Here, we compare to the same EMA: i.e., if drate drops below 85% of current EMA\\n    // This is a soft signal; we require enough conflicts since last restart\\n    if (drate < 0.85 * limit &&\\n        (CONFLICTS - solver->statistics.restarts * GET_OPTION(restartint) >= 0.5 * GET_OPTION(restartint))) {\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Stable Mode ---\\n  // First: classic reluctant/Luby-based trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // --- MAB-Aware Restart: if enabled and classic did not trigger ---\\n  if (solver->mab) {\\n    if (CONFLICTS >= solver->limits.restart.conflicts) {\\n      const unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n      const unsigned h_alt = 1 - h;\\n      const double reward_h = solver->mab_select[h] ? solver->mab_reward[h] / solver->mab_select[h] : 0.0;\\n      const double reward_alt = solver->mab_select[h_alt] ? solver->mab_reward[h_alt] / solver->mab_select[h_alt] : 0.0;\\n\\n      if (\\n        solver->mab_select[h] >= 2 &&\\n        reward_h < 0.85 * reward_alt &&\\n        solver->mab_conflicts > 0.5 * GET_OPTION(restartint)\\n      ) {\\n        return true;\\n      }\\n    }\\n  }\\n\\n  // Otherwise, no restart.\\n  return false;\\n}\\n",
    "par2_preferred": 179.85339999999994,
    "par2_rejected": 187.8207
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Luby Trigger\n\nAlgorithm: 1. Check guards: if solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n2. If in focused mode (solver->stable == false):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND (fast_glue >= (1.0 + GET_OPTION(restartmargin)/100.0) * slow_glue), return true.\n   - ELSE IF (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(decision_rate) < 0.85 * previous_decision_rate) AND (CONFLICTS - last_restart_conflicts >= 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.\n3. If in stable mode (solver->stable == true):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant), return true.\n   - ELSE IF solver->mab == true AND (CONFLICTS >= solver->limits.restart.conflicts):\n     - Let h = solver->heuristic (current heuristic: 0=VSIDS, 1=CHB)\n     - Let rew = solver->mab_reward[h], times = solver->mab_select[h]\n     - If (times >= 2) AND (rew < 0.85 * (solver->mab_reward[1-h] / max(solver->mab_select[1-h],1))) AND (solver->mab_conflicts > 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts must be enabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: must be inside a non-root decision level\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: must reach the next restart conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Focused mode heuristics\\n  if (!solver->stable) {\\n    // Standard glue-based trigger\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    if (fast >= limit)\\n      return true;\\n\\n    // MAB-inspired: decision rate drop triggers\\n    // We use decision_rate value as a proxy; no \\\"previous\\\" value stored, so skip this part\\n    // as we can't compare to previous_decision_rate without state or history.\\n\\n    // Alternatively, if restartint is set and enough conflicts since last restart, allow early restart\\n    if (GET_OPTION(restartint) > 0) {\\n      uint64_t since_last_restart = CONFLICTS - solver->statistics.restarts * GET_OPTION(restartint);\\n      if (since_last_restart >= 0.5 * GET_OPTION(restartint))\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // Stable mode heuristics\\n  // First: reluctant doubling/Luby-style\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware trigger (only if MAB is active)\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n    unsigned other = 1 - h;\\n    double rew = solver->mab_reward[h];\\n    unsigned times = solver->mab_select[h];\\n\\n    // Compare *per selection* reward, avoid division by zero\\n    double other_avg = 0.0;\\n    if (solver->mab_select[other])\\n      other_avg = solver->mab_reward[other] / solver->mab_select[other];\\n    else\\n      other_avg = 0.0;\\n\\n    if (times >= 2 &&\\n        rew < 0.85 * other_avg &&\\n        solver->mab_conflicts > 0.5 * GET_OPTION(restartint))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard conditions\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // FOCUSED MODE: glue margin + decision rate adaptation\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // Decision rate adaptation: restart if decision rate dropped sharply and enough conflicts since last restart\\n    // NOTE: No explicit previous_decision_rate or last_restart_conflicts available;\\n    // Fallback: use restartint as threshold, and compare decision rate to running average (rarely triggers if not available)\\n    // Since we do not have previous_decision_rate, skip this branch if not tracked.\\n    // (Here, we conservatively do not implement this branch due to unavailable variables.)\\n    return false;\\n  }\\n\\n  // STABLE MODE: reluctant or MAB-aware trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware restart in stable mode\\n  if (solver->mab && (CONFLICTS >= solver->limits.restart.conflicts)) {\\n    const unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n    const unsigned other = 1 - h;\\n    const double reward_h = solver->mab_select[h] ? solver->mab_reward[h] / solver->mab_select[h] : 0.0;\\n    const double reward_other = solver->mab_select[other] ? solver->mab_reward[other] / solver->mab_select[other] : 0.0;\\n    if (solver->mab_select[h] >= 2 &&\\n        reward_h < 0.85 * reward_other &&\\n        solver->mab_conflicts > 0.5 * GET_OPTION(restartint))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 179.85339999999994,
    "par2_rejected": 190.94569999999996
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Luby Trigger\n\nAlgorithm: 1. Check guards: if solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n2. If in focused mode (solver->stable == false):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND (fast_glue >= (1.0 + GET_OPTION(restartmargin)/100.0) * slow_glue), return true.\n   - ELSE IF (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(decision_rate) < 0.85 * previous_decision_rate) AND (CONFLICTS - last_restart_conflicts >= 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.\n3. If in stable mode (solver->stable == true):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant), return true.\n   - ELSE IF solver->mab == true AND (CONFLICTS >= solver->limits.restart.conflicts):\n     - Let h = solver->heuristic (current heuristic: 0=VSIDS, 1=CHB)\n     - Let rew = solver->mab_reward[h], times = solver->mab_select[h]\n     - If (times >= 2) AND (rew < 0.85 * (solver->mab_reward[1-h] / max(solver->mab_select[1-h],1))) AND (solver->mab_conflicts > 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts must be enabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: must be inside a non-root decision level\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: must reach the next restart conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Focused mode heuristics\\n  if (!solver->stable) {\\n    // Standard glue-based trigger\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    if (fast >= limit)\\n      return true;\\n\\n    // MAB-inspired: decision rate drop triggers\\n    // We use decision_rate value as a proxy; no \\\"previous\\\" value stored, so skip this part\\n    // as we can't compare to previous_decision_rate without state or history.\\n\\n    // Alternatively, if restartint is set and enough conflicts since last restart, allow early restart\\n    if (GET_OPTION(restartint) > 0) {\\n      uint64_t since_last_restart = CONFLICTS - solver->statistics.restarts * GET_OPTION(restartint);\\n      if (since_last_restart >= 0.5 * GET_OPTION(restartint))\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // Stable mode heuristics\\n  // First: reluctant doubling/Luby-style\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware trigger (only if MAB is active)\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n    unsigned other = 1 - h;\\n    double rew = solver->mab_reward[h];\\n    unsigned times = solver->mab_select[h];\\n\\n    // Compare *per selection* reward, avoid division by zero\\n    double other_avg = 0.0;\\n    if (solver->mab_select[other])\\n      other_avg = solver->mab_reward[other] / solver->mab_select[other];\\n    else\\n      other_avg = 0.0;\\n\\n    if (times >= 2 &&\\n        rew < 0.85 * other_avg &&\\n        solver->mab_conflicts > 0.5 * GET_OPTION(restartint))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at decision level 0?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not enough conflicts since last restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode: glue-based + decision-rate fallback ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double glue_limit = margin * slow;\\n\\n    // Standard glue-based trigger\\n    if (fast >= glue_limit)\\n      return true;\\n\\n    // Decision rate fallback: only if enough conflicts since last restart\\n    // (We do not have access to previous_decision_rate directly, so skip this fallback unless such tracking exists in the codebase)\\n    // If you have a historical rate, you could compare AVERAGE(decision_rate) to it here.\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode: reluctant/Luby or MAB fallback ---\\n  // Standard reluctant (Luby) trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware fallback: if enabled and primary trigger not fired\\n  if (solver->mab) {\\n    const unsigned h = solver->heuristic;  // 0=VSIDS, 1=CHB\\n    const unsigned h_other = 1 - h;\\n    const double reward = solver->mab_reward[h];\\n    const double n = (double) solver->mab_select[h];\\n    const double reward_other = solver->mab_reward[h_other];\\n    const double n_other = (double) solver->mab_select[h_other];\\n\\n    // Only consider if current heuristic used at least twice\\n    if (n >= 2) {\\n      // Avoid division by zero\\n      double avg_other = n_other > 0 ? (reward_other / n_other) : 0.0;\\n      double avg_this  = n > 0 ? (reward / n) : 0.0;\\n\\n      // If this heuristic underperforms the other by 15% or more (and enough conflicts since last restart), restart\\n      if (avg_this < 0.85 * avg_other && solver->mab_conflicts > 0.5 * GET_OPTION(restartint))\\n        return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 179.85339999999994,
    "par2_rejected": 192.69900000000004
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Luby Trigger\n\nAlgorithm: 1. Check guards: if solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n2. If in focused mode (solver->stable == false):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND (fast_glue >= (1.0 + GET_OPTION(restartmargin)/100.0) * slow_glue), return true.\n   - ELSE IF (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(decision_rate) < 0.85 * previous_decision_rate) AND (CONFLICTS - last_restart_conflicts >= 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.\n3. If in stable mode (solver->stable == true):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant), return true.\n   - ELSE IF solver->mab == true AND (CONFLICTS >= solver->limits.restart.conflicts):\n     - Let h = solver->heuristic (current heuristic: 0=VSIDS, 1=CHB)\n     - Let rew = solver->mab_reward[h], times = solver->mab_select[h]\n     - If (times >= 2) AND (rew < 0.85 * (solver->mab_reward[1-h] / max(solver->mab_select[1-h],1))) AND (solver->mab_conflicts > 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts must be enabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: must be inside a non-root decision level\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: must reach the next restart conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Focused mode heuristics\\n  if (!solver->stable) {\\n    // Standard glue-based trigger\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    if (fast >= limit)\\n      return true;\\n\\n    // MAB-inspired: decision rate drop triggers\\n    // We use decision_rate value as a proxy; no \\\"previous\\\" value stored, so skip this part\\n    // as we can't compare to previous_decision_rate without state or history.\\n\\n    // Alternatively, if restartint is set and enough conflicts since last restart, allow early restart\\n    if (GET_OPTION(restartint) > 0) {\\n      uint64_t since_last_restart = CONFLICTS - solver->statistics.restarts * GET_OPTION(restartint);\\n      if (since_last_restart >= 0.5 * GET_OPTION(restartint))\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // Stable mode heuristics\\n  // First: reluctant doubling/Luby-style\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware trigger (only if MAB is active)\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n    unsigned other = 1 - h;\\n    double rew = solver->mab_reward[h];\\n    unsigned times = solver->mab_select[h];\\n\\n    // Compare *per selection* reward, avoid division by zero\\n    double other_avg = 0.0;\\n    if (solver->mab_select[other])\\n      other_avg = solver->mab_reward[other] / solver->mab_select[other];\\n    else\\n      other_avg = 0.0;\\n\\n    if (times >= 2 &&\\n        rew < 0.85 * other_avg &&\\n        solver->mab_conflicts > 0.5 * GET_OPTION(restartint))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n  // Guard: not at root level\\n  if (!solver->level)\\n    return false;\\n  // Guard: not yet at restart conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  // Focused mode: Glue-based or decision-rate-based restarts\\n  if (!solver->stable) {\\n    if (fast >= limit)\\n      return true;\\n\\n    // Decision rate drop trigger (requires at least one previous restart)\\n    static double prev_decision_rate = 0.0;\\n    static uint64_t prev_restart_conflicts = 0;\\n\\n    double current_decision_rate = AVERAGE(decision_rate);\\n    uint64_t since_last_restart = CONFLICTS - prev_restart_conflicts;\\n    double restartint_half = 0.5 * GET_OPTION(restartint);\\n\\n    bool trigger = false;\\n\\n    if (prev_decision_rate > 0.0 &&\\n        current_decision_rate < 0.85 * prev_decision_rate &&\\n        since_last_restart >= restartint_half) {\\n      trigger = true;\\n    }\\n\\n    // Update only on actual restart (simulate: will update on next actual restart)\\n    if (trigger) {\\n      // These are static so only for diagnostics; Kissat updates stats in restart logic.\\n      // If needed: prev_decision_rate = current_decision_rate;\\n      //            prev_restart_conflicts = CONFLICTS;\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  // Stable mode: reluctant or MAB-accelerated restarts\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB signal for restart in stable mode\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned alt = 1 - h;\\n    double rew = solver->mab_reward[h];\\n    double n = (double)solver->mab_select[h];\\n    double alt_rew = solver->mab_reward[alt];\\n    double alt_n = (double)solver->mab_select[alt];\\n\\n    // Use average reward per selection for each heuristic\\n    double avg_rew = n > 0 ? rew / n : 0.0;\\n    double avg_alt = alt_n > 0 ? alt_rew / alt_n : 0.0;\\n\\n    if (n >= 2 &&\\n        avg_rew < 0.85 * avg_alt &&\\n        solver->mab_conflicts > 0.5 * GET_OPTION(restartint)) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 179.85339999999994,
    "par2_rejected": 194.01760000000002
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Luby Trigger\n\nAlgorithm: 1. Check guards: if solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n2. If in focused mode (solver->stable == false):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND (fast_glue >= (1.0 + GET_OPTION(restartmargin)/100.0) * slow_glue), return true.\n   - ELSE IF (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(decision_rate) < 0.85 * previous_decision_rate) AND (CONFLICTS - last_restart_conflicts >= 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.\n3. If in stable mode (solver->stable == true):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant), return true.\n   - ELSE IF solver->mab == true AND (CONFLICTS >= solver->limits.restart.conflicts):\n     - Let h = solver->heuristic (current heuristic: 0=VSIDS, 1=CHB)\n     - Let rew = solver->mab_reward[h], times = solver->mab_select[h]\n     - If (times >= 2) AND (rew < 0.85 * (solver->mab_reward[1-h] / max(solver->mab_select[1-h],1))) AND (solver->mab_conflicts > 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts must be enabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: must be inside a non-root decision level\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: must reach the next restart conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Focused mode heuristics\\n  if (!solver->stable) {\\n    // Standard glue-based trigger\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    if (fast >= limit)\\n      return true;\\n\\n    // MAB-inspired: decision rate drop triggers\\n    // We use decision_rate value as a proxy; no \\\"previous\\\" value stored, so skip this part\\n    // as we can't compare to previous_decision_rate without state or history.\\n\\n    // Alternatively, if restartint is set and enough conflicts since last restart, allow early restart\\n    if (GET_OPTION(restartint) > 0) {\\n      uint64_t since_last_restart = CONFLICTS - solver->statistics.restarts * GET_OPTION(restartint);\\n      if (since_last_restart >= 0.5 * GET_OPTION(restartint))\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // Stable mode heuristics\\n  // First: reluctant doubling/Luby-style\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware trigger (only if MAB is active)\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n    unsigned other = 1 - h;\\n    double rew = solver->mab_reward[h];\\n    unsigned times = solver->mab_select[h];\\n\\n    // Compare *per selection* reward, avoid division by zero\\n    double other_avg = 0.0;\\n    if (solver->mab_select[other])\\n      other_avg = solver->mab_reward[other] / solver->mab_select[other];\\n    else\\n      other_avg = 0.0;\\n\\n    if (times >= 2 &&\\n        rew < 0.85 * other_avg &&\\n        solver->mab_conflicts > 0.5 * GET_OPTION(restartint))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Conflict guard\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode ---\\n  if (!solver->stable) {\\n    // Standard glue-based restart\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // MAB-independent: decision rate drop heuristic\\n    // Use decision rate drop as additional trigger (if available)\\n    // We approximate \\\"previous_decision_rate\\\" by using 'limit' (slow average glue) heuristically,\\n    // but since we do not have direct access to previous_decision_rate, this is not calculated.\\n\\n    // Optionally: check if decision rate has dropped significantly\\n    // (if conflicting enough since last restart, and low decision rate)\\n    // But we lack previous_decision_rate or CONFLICTS at last restart.\\n    // So this block is omitted unless state is augmented elsewhere.\\n    return false;\\n  }\\n\\n  // --- Stable mode ---\\n  // Standard reluctant-based restart\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: if MAB is enabled, try adaptive restart if heuristic is underperforming\\n  if (solver->mab) {\\n    const unsigned h = solver->heuristic;             // 0 = VSIDS, 1 = CHB\\n    const unsigned alt = 1 - h;\\n    const unsigned times = solver->mab_select[h];\\n    const unsigned alt_times = solver->mab_select[alt];\\n    const double rew = solver->mab_select[h] ? (solver->mab_reward[h] / solver->mab_select[h]) : 0.0;\\n    const double alt_rew = solver->mab_select[alt] ? (solver->mab_reward[alt] / solver->mab_select[alt]) : 0.0;\\n\\n    // Require at least two times using current heuristic for meaningful comparison\\n    if (times >= 2) {\\n      // If current heuristic's average reward is < 85% of the alternative's\\n      if (alt_times > 0 && rew < 0.85 * alt_rew) {\\n        // Also require enough conflicts since last restart\\n        if (solver->mab_conflicts > 0.5 * GET_OPTION(restartint))\\n          return true;\\n      }\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 179.85339999999994,
    "par2_rejected": 194.4395
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Luby Trigger\n\nAlgorithm: 1. Check guards: if solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n2. If in focused mode (solver->stable == false):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND (fast_glue >= (1.0 + GET_OPTION(restartmargin)/100.0) * slow_glue), return true.\n   - ELSE IF (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(decision_rate) < 0.85 * previous_decision_rate) AND (CONFLICTS - last_restart_conflicts >= 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.\n3. If in stable mode (solver->stable == true):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant), return true.\n   - ELSE IF solver->mab == true AND (CONFLICTS >= solver->limits.restart.conflicts):\n     - Let h = solver->heuristic (current heuristic: 0=VSIDS, 1=CHB)\n     - Let rew = solver->mab_reward[h], times = solver->mab_select[h]\n     - If (times >= 2) AND (rew < 0.85 * (solver->mab_reward[1-h] / max(solver->mab_select[1-h],1))) AND (solver->mab_conflicts > 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts must be enabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: must be inside a non-root decision level\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: must reach the next restart conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Focused mode heuristics\\n  if (!solver->stable) {\\n    // Standard glue-based trigger\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    if (fast >= limit)\\n      return true;\\n\\n    // MAB-inspired: decision rate drop triggers\\n    // We use decision_rate value as a proxy; no \\\"previous\\\" value stored, so skip this part\\n    // as we can't compare to previous_decision_rate without state or history.\\n\\n    // Alternatively, if restartint is set and enough conflicts since last restart, allow early restart\\n    if (GET_OPTION(restartint) > 0) {\\n      uint64_t since_last_restart = CONFLICTS - solver->statistics.restarts * GET_OPTION(restartint);\\n      if (since_last_restart >= 0.5 * GET_OPTION(restartint))\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // Stable mode heuristics\\n  // First: reluctant doubling/Luby-style\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware trigger (only if MAB is active)\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n    unsigned other = 1 - h;\\n    double rew = solver->mab_reward[h];\\n    unsigned times = solver->mab_select[h];\\n\\n    // Compare *per selection* reward, avoid division by zero\\n    double other_avg = 0.0;\\n    if (solver->mab_select[other])\\n      other_avg = solver->mab_reward[other] / solver->mab_select[other];\\n    else\\n      other_avg = 0.0;\\n\\n    if (times >= 2 &&\\n        rew < 0.85 * other_avg &&\\n        solver->mab_conflicts > 0.5 * GET_OPTION(restartint))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts are disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: don't restart at top level\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not yet reached restart conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n\\n  if (!solver->stable) {\\n    // Focused mode: classic glue trigger\\n    if (fast >= glue_limit)\\n      return true;\\n\\n    // Focused: secondary trigger if decision rate collapsed\\n    // (simulate \\\\\\\"previous_decision_rate\\\\\\\" as slow EMA, and check drop)\\n    // Note: since we cannot access previous_decision_rate directly,\\n    // use slow vs fast, or skip this secondary trigger if not tracked.\\n    //\\n    // Here, only the glue trigger is used for focused mode.\\n    return false;\\n  }\\n\\n  // Stable mode\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // Stable mode: MAB-aware trigger\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic; // 0:VSIDS, 1:CHB\\n    unsigned h_other = 1 - h;\\n    double rew = solver->mab_select[h] ? solver->mab_reward[h] / solver->mab_select[h] : 0.0;\\n    double rew_other = solver->mab_select[h_other] ? solver->mab_reward[h_other] / solver->mab_select[h_other] : 0.0;\\n\\n    // If both heuristics selected at least twice, and current is underperforming\\n    if (\\n      solver->mab_select[h] >= 2 &&\\n      rew < 0.85 * rew_other &&\\n      solver->mab_conflicts > 0.5 * GET_OPTION(restartint)\\n    ) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 179.85339999999994,
    "par2_rejected": 195.99730000000002
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Luby Trigger\n\nAlgorithm: 1. Check guards: if solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n2. If in focused mode (solver->stable == false):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND (fast_glue >= (1.0 + GET_OPTION(restartmargin)/100.0) * slow_glue), return true.\n   - ELSE IF (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(decision_rate) < 0.85 * previous_decision_rate) AND (CONFLICTS - last_restart_conflicts >= 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.\n3. If in stable mode (solver->stable == true):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant), return true.\n   - ELSE IF solver->mab == true AND (CONFLICTS >= solver->limits.restart.conflicts):\n     - Let h = solver->heuristic (current heuristic: 0=VSIDS, 1=CHB)\n     - Let rew = solver->mab_reward[h], times = solver->mab_select[h]\n     - If (times >= 2) AND (rew < 0.85 * (solver->mab_reward[1-h] / max(solver->mab_select[1-h],1))) AND (solver->mab_conflicts > 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode: glue margin OR decision rate drop triggers ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // Decision rate drop trigger (if margin not met), using previous avg as baseline\\n    // We do not have previous_decision_rate directly, so we cannot compare to that.\\n    // However, this part can only be implemented if such state is tracked.\\n    // Since the original reference did not track previous_decision_rate, skip this trigger.\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode: reluctant or MAB underperformance triggers ---\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  if (solver->mab && (CONFLICTS >= solver->limits.restart.conflicts)) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    unsigned times = solver->mab_select[h];\\n    unsigned times_other = solver->mab_select[other];\\n    double rew = solver->mab_reward[h];\\n    double avg_other = times_other ? (solver->mab_reward[other] / times_other) : 0.0;\\n\\n    // Require at least two samples to avoid noisy reward\\n    if (times >= 2 &&\\n        // If current heuristic reward is significantly lower than competitor's avg\\n        (rew < 0.85 * avg_other) &&\\n        // Only trigger if enough conflicts since last restart\\n        (solver->mab_conflicts > 0.5 * GET_OPTION(restartint)))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard conditions\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // FOCUSED MODE: glue margin + decision rate adaptation\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // Decision rate adaptation: restart if decision rate dropped sharply and enough conflicts since last restart\\n    // NOTE: No explicit previous_decision_rate or last_restart_conflicts available;\\n    // Fallback: use restartint as threshold, and compare decision rate to running average (rarely triggers if not available)\\n    // Since we do not have previous_decision_rate, skip this branch if not tracked.\\n    // (Here, we conservatively do not implement this branch due to unavailable variables.)\\n    return false;\\n  }\\n\\n  // STABLE MODE: reluctant or MAB-aware trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware restart in stable mode\\n  if (solver->mab && (CONFLICTS >= solver->limits.restart.conflicts)) {\\n    const unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n    const unsigned other = 1 - h;\\n    const double reward_h = solver->mab_select[h] ? solver->mab_reward[h] / solver->mab_select[h] : 0.0;\\n    const double reward_other = solver->mab_select[other] ? solver->mab_reward[other] / solver->mab_select[other] : 0.0;\\n    if (solver->mab_select[h] >= 2 &&\\n        reward_h < 0.85 * reward_other &&\\n        solver->mab_conflicts > 0.5 * GET_OPTION(restartint))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 183.26129999999998,
    "par2_rejected": 190.94569999999996
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Luby Trigger\n\nAlgorithm: 1. Check guards: if solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n2. If in focused mode (solver->stable == false):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND (fast_glue >= (1.0 + GET_OPTION(restartmargin)/100.0) * slow_glue), return true.\n   - ELSE IF (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(decision_rate) < 0.85 * previous_decision_rate) AND (CONFLICTS - last_restart_conflicts >= 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.\n3. If in stable mode (solver->stable == true):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant), return true.\n   - ELSE IF solver->mab == true AND (CONFLICTS >= solver->limits.restart.conflicts):\n     - Let h = solver->heuristic (current heuristic: 0=VSIDS, 1=CHB)\n     - Let rew = solver->mab_reward[h], times = solver->mab_select[h]\n     - If (times >= 2) AND (rew < 0.85 * (solver->mab_reward[1-h] / max(solver->mab_select[1-h],1))) AND (solver->mab_conflicts > 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode: glue margin OR decision rate drop triggers ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // Decision rate drop trigger (if margin not met), using previous avg as baseline\\n    // We do not have previous_decision_rate directly, so we cannot compare to that.\\n    // However, this part can only be implemented if such state is tracked.\\n    // Since the original reference did not track previous_decision_rate, skip this trigger.\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode: reluctant or MAB underperformance triggers ---\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  if (solver->mab && (CONFLICTS >= solver->limits.restart.conflicts)) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    unsigned times = solver->mab_select[h];\\n    unsigned times_other = solver->mab_select[other];\\n    double rew = solver->mab_reward[h];\\n    double avg_other = times_other ? (solver->mab_reward[other] / times_other) : 0.0;\\n\\n    // Require at least two samples to avoid noisy reward\\n    if (times >= 2 &&\\n        // If current heuristic reward is significantly lower than competitor's avg\\n        (rew < 0.85 * avg_other) &&\\n        // Only trigger if enough conflicts since last restart\\n        (solver->mab_conflicts > 0.5 * GET_OPTION(restartint)))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at decision level 0?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not enough conflicts since last restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode: glue-based + decision-rate fallback ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double glue_limit = margin * slow;\\n\\n    // Standard glue-based trigger\\n    if (fast >= glue_limit)\\n      return true;\\n\\n    // Decision rate fallback: only if enough conflicts since last restart\\n    // (We do not have access to previous_decision_rate directly, so skip this fallback unless such tracking exists in the codebase)\\n    // If you have a historical rate, you could compare AVERAGE(decision_rate) to it here.\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode: reluctant/Luby or MAB fallback ---\\n  // Standard reluctant (Luby) trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware fallback: if enabled and primary trigger not fired\\n  if (solver->mab) {\\n    const unsigned h = solver->heuristic;  // 0=VSIDS, 1=CHB\\n    const unsigned h_other = 1 - h;\\n    const double reward = solver->mab_reward[h];\\n    const double n = (double) solver->mab_select[h];\\n    const double reward_other = solver->mab_reward[h_other];\\n    const double n_other = (double) solver->mab_select[h_other];\\n\\n    // Only consider if current heuristic used at least twice\\n    if (n >= 2) {\\n      // Avoid division by zero\\n      double avg_other = n_other > 0 ? (reward_other / n_other) : 0.0;\\n      double avg_this  = n > 0 ? (reward / n) : 0.0;\\n\\n      // If this heuristic underperforms the other by 15% or more (and enough conflicts since last restart), restart\\n      if (avg_this < 0.85 * avg_other && solver->mab_conflicts > 0.5 * GET_OPTION(restartint))\\n        return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 183.26129999999998,
    "par2_rejected": 192.69900000000004
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Luby Trigger\n\nAlgorithm: 1. Check guards: if solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n2. If in focused mode (solver->stable == false):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND (fast_glue >= (1.0 + GET_OPTION(restartmargin)/100.0) * slow_glue), return true.\n   - ELSE IF (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(decision_rate) < 0.85 * previous_decision_rate) AND (CONFLICTS - last_restart_conflicts >= 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.\n3. If in stable mode (solver->stable == true):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant), return true.\n   - ELSE IF solver->mab == true AND (CONFLICTS >= solver->limits.restart.conflicts):\n     - Let h = solver->heuristic (current heuristic: 0=VSIDS, 1=CHB)\n     - Let rew = solver->mab_reward[h], times = solver->mab_select[h]\n     - If (times >= 2) AND (rew < 0.85 * (solver->mab_reward[1-h] / max(solver->mab_select[1-h],1))) AND (solver->mab_conflicts > 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode: glue margin OR decision rate drop triggers ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // Decision rate drop trigger (if margin not met), using previous avg as baseline\\n    // We do not have previous_decision_rate directly, so we cannot compare to that.\\n    // However, this part can only be implemented if such state is tracked.\\n    // Since the original reference did not track previous_decision_rate, skip this trigger.\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode: reluctant or MAB underperformance triggers ---\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  if (solver->mab && (CONFLICTS >= solver->limits.restart.conflicts)) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    unsigned times = solver->mab_select[h];\\n    unsigned times_other = solver->mab_select[other];\\n    double rew = solver->mab_reward[h];\\n    double avg_other = times_other ? (solver->mab_reward[other] / times_other) : 0.0;\\n\\n    // Require at least two samples to avoid noisy reward\\n    if (times >= 2 &&\\n        // If current heuristic reward is significantly lower than competitor's avg\\n        (rew < 0.85 * avg_other) &&\\n        // Only trigger if enough conflicts since last restart\\n        (solver->mab_conflicts > 0.5 * GET_OPTION(restartint)))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n  // Guard: not at root level\\n  if (!solver->level)\\n    return false;\\n  // Guard: not yet at restart conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  // Focused mode: Glue-based or decision-rate-based restarts\\n  if (!solver->stable) {\\n    if (fast >= limit)\\n      return true;\\n\\n    // Decision rate drop trigger (requires at least one previous restart)\\n    static double prev_decision_rate = 0.0;\\n    static uint64_t prev_restart_conflicts = 0;\\n\\n    double current_decision_rate = AVERAGE(decision_rate);\\n    uint64_t since_last_restart = CONFLICTS - prev_restart_conflicts;\\n    double restartint_half = 0.5 * GET_OPTION(restartint);\\n\\n    bool trigger = false;\\n\\n    if (prev_decision_rate > 0.0 &&\\n        current_decision_rate < 0.85 * prev_decision_rate &&\\n        since_last_restart >= restartint_half) {\\n      trigger = true;\\n    }\\n\\n    // Update only on actual restart (simulate: will update on next actual restart)\\n    if (trigger) {\\n      // These are static so only for diagnostics; Kissat updates stats in restart logic.\\n      // If needed: prev_decision_rate = current_decision_rate;\\n      //            prev_restart_conflicts = CONFLICTS;\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  // Stable mode: reluctant or MAB-accelerated restarts\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB signal for restart in stable mode\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned alt = 1 - h;\\n    double rew = solver->mab_reward[h];\\n    double n = (double)solver->mab_select[h];\\n    double alt_rew = solver->mab_reward[alt];\\n    double alt_n = (double)solver->mab_select[alt];\\n\\n    // Use average reward per selection for each heuristic\\n    double avg_rew = n > 0 ? rew / n : 0.0;\\n    double avg_alt = alt_n > 0 ? alt_rew / alt_n : 0.0;\\n\\n    if (n >= 2 &&\\n        avg_rew < 0.85 * avg_alt &&\\n        solver->mab_conflicts > 0.5 * GET_OPTION(restartint)) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 183.26129999999998,
    "par2_rejected": 194.01760000000002
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Luby Trigger\n\nAlgorithm: 1. Check guards: if solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n2. If in focused mode (solver->stable == false):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND (fast_glue >= (1.0 + GET_OPTION(restartmargin)/100.0) * slow_glue), return true.\n   - ELSE IF (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(decision_rate) < 0.85 * previous_decision_rate) AND (CONFLICTS - last_restart_conflicts >= 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.\n3. If in stable mode (solver->stable == true):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant), return true.\n   - ELSE IF solver->mab == true AND (CONFLICTS >= solver->limits.restart.conflicts):\n     - Let h = solver->heuristic (current heuristic: 0=VSIDS, 1=CHB)\n     - Let rew = solver->mab_reward[h], times = solver->mab_select[h]\n     - If (times >= 2) AND (rew < 0.85 * (solver->mab_reward[1-h] / max(solver->mab_select[1-h],1))) AND (solver->mab_conflicts > 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode: glue margin OR decision rate drop triggers ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // Decision rate drop trigger (if margin not met), using previous avg as baseline\\n    // We do not have previous_decision_rate directly, so we cannot compare to that.\\n    // However, this part can only be implemented if such state is tracked.\\n    // Since the original reference did not track previous_decision_rate, skip this trigger.\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode: reluctant or MAB underperformance triggers ---\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  if (solver->mab && (CONFLICTS >= solver->limits.restart.conflicts)) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    unsigned times = solver->mab_select[h];\\n    unsigned times_other = solver->mab_select[other];\\n    double rew = solver->mab_reward[h];\\n    double avg_other = times_other ? (solver->mab_reward[other] / times_other) : 0.0;\\n\\n    // Require at least two samples to avoid noisy reward\\n    if (times >= 2 &&\\n        // If current heuristic reward is significantly lower than competitor's avg\\n        (rew < 0.85 * avg_other) &&\\n        // Only trigger if enough conflicts since last restart\\n        (solver->mab_conflicts > 0.5 * GET_OPTION(restartint)))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Conflict guard\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode ---\\n  if (!solver->stable) {\\n    // Standard glue-based restart\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // MAB-independent: decision rate drop heuristic\\n    // Use decision rate drop as additional trigger (if available)\\n    // We approximate \\\"previous_decision_rate\\\" by using 'limit' (slow average glue) heuristically,\\n    // but since we do not have direct access to previous_decision_rate, this is not calculated.\\n\\n    // Optionally: check if decision rate has dropped significantly\\n    // (if conflicting enough since last restart, and low decision rate)\\n    // But we lack previous_decision_rate or CONFLICTS at last restart.\\n    // So this block is omitted unless state is augmented elsewhere.\\n    return false;\\n  }\\n\\n  // --- Stable mode ---\\n  // Standard reluctant-based restart\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: if MAB is enabled, try adaptive restart if heuristic is underperforming\\n  if (solver->mab) {\\n    const unsigned h = solver->heuristic;             // 0 = VSIDS, 1 = CHB\\n    const unsigned alt = 1 - h;\\n    const unsigned times = solver->mab_select[h];\\n    const unsigned alt_times = solver->mab_select[alt];\\n    const double rew = solver->mab_select[h] ? (solver->mab_reward[h] / solver->mab_select[h]) : 0.0;\\n    const double alt_rew = solver->mab_select[alt] ? (solver->mab_reward[alt] / solver->mab_select[alt]) : 0.0;\\n\\n    // Require at least two times using current heuristic for meaningful comparison\\n    if (times >= 2) {\\n      // If current heuristic's average reward is < 85% of the alternative's\\n      if (alt_times > 0 && rew < 0.85 * alt_rew) {\\n        // Also require enough conflicts since last restart\\n        if (solver->mab_conflicts > 0.5 * GET_OPTION(restartint))\\n          return true;\\n      }\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 183.26129999999998,
    "par2_rejected": 194.4395
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Luby Trigger\n\nAlgorithm: 1. Check guards: if solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n2. If in focused mode (solver->stable == false):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND (fast_glue >= (1.0 + GET_OPTION(restartmargin)/100.0) * slow_glue), return true.\n   - ELSE IF (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(decision_rate) < 0.85 * previous_decision_rate) AND (CONFLICTS - last_restart_conflicts >= 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.\n3. If in stable mode (solver->stable == true):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant), return true.\n   - ELSE IF solver->mab == true AND (CONFLICTS >= solver->limits.restart.conflicts):\n     - Let h = solver->heuristic (current heuristic: 0=VSIDS, 1=CHB)\n     - Let rew = solver->mab_reward[h], times = solver->mab_select[h]\n     - If (times >= 2) AND (rew < 0.85 * (solver->mab_reward[1-h] / max(solver->mab_select[1-h],1))) AND (solver->mab_conflicts > 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode: glue margin OR decision rate drop triggers ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // Decision rate drop trigger (if margin not met), using previous avg as baseline\\n    // We do not have previous_decision_rate directly, so we cannot compare to that.\\n    // However, this part can only be implemented if such state is tracked.\\n    // Since the original reference did not track previous_decision_rate, skip this trigger.\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode: reluctant or MAB underperformance triggers ---\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  if (solver->mab && (CONFLICTS >= solver->limits.restart.conflicts)) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    unsigned times = solver->mab_select[h];\\n    unsigned times_other = solver->mab_select[other];\\n    double rew = solver->mab_reward[h];\\n    double avg_other = times_other ? (solver->mab_reward[other] / times_other) : 0.0;\\n\\n    // Require at least two samples to avoid noisy reward\\n    if (times >= 2 &&\\n        // If current heuristic reward is significantly lower than competitor's avg\\n        (rew < 0.85 * avg_other) &&\\n        // Only trigger if enough conflicts since last restart\\n        (solver->mab_conflicts > 0.5 * GET_OPTION(restartint)))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts are disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: don't restart at top level\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not yet reached restart conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n\\n  if (!solver->stable) {\\n    // Focused mode: classic glue trigger\\n    if (fast >= glue_limit)\\n      return true;\\n\\n    // Focused: secondary trigger if decision rate collapsed\\n    // (simulate \\\\\\\"previous_decision_rate\\\\\\\" as slow EMA, and check drop)\\n    // Note: since we cannot access previous_decision_rate directly,\\n    // use slow vs fast, or skip this secondary trigger if not tracked.\\n    //\\n    // Here, only the glue trigger is used for focused mode.\\n    return false;\\n  }\\n\\n  // Stable mode\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // Stable mode: MAB-aware trigger\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic; // 0:VSIDS, 1:CHB\\n    unsigned h_other = 1 - h;\\n    double rew = solver->mab_select[h] ? solver->mab_reward[h] / solver->mab_select[h] : 0.0;\\n    double rew_other = solver->mab_select[h_other] ? solver->mab_reward[h_other] / solver->mab_select[h_other] : 0.0;\\n\\n    // If both heuristics selected at least twice, and current is underperforming\\n    if (\\n      solver->mab_select[h] >= 2 &&\\n      rew < 0.85 * rew_other &&\\n      solver->mab_conflicts > 0.5 * GET_OPTION(restartint)\\n    ) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 183.26129999999998,
    "par2_rejected": 195.99730000000002
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Luby Trigger\n\nAlgorithm: 1. Check guards: if solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n2. If in focused mode (solver->stable == false):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND (fast_glue >= (1.0 + GET_OPTION(restartmargin)/100.0) * slow_glue), return true.\n   - ELSE IF (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(decision_rate) < 0.85 * previous_decision_rate) AND (CONFLICTS - last_restart_conflicts >= 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.\n3. If in stable mode (solver->stable == true):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant), return true.\n   - ELSE IF solver->mab == true AND (CONFLICTS >= solver->limits.restart.conflicts):\n     - Let h = solver->heuristic (current heuristic: 0=VSIDS, 1=CHB)\n     - Let rew = solver->mab_reward[h], times = solver->mab_select[h]\n     - If (times >= 2) AND (rew < 0.85 * (solver->mab_reward[1-h] / max(solver->mab_select[1-h],1))) AND (solver->mab_conflicts > 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double glue_limit = margin * slow;\\n\\n    // Baseline glue-based trigger\\n    if (fast >= glue_limit)\\n      return true;\\n\\n    // Decision rate based trigger (if decision rate drops sharply)\\n    // We approximate previous_decision_rate as the slow average (since no explicit prev value)\\n    // This is a heuristic: if decision rate EMA drops below 85% of slow_glue baseline\\n    // and enough conflicts since last restart threshold advanced.\\n    const double decision_rate = AVERAGE(decision_rate);\\n    // For lack of explicit previous_decision_rate, we use slow_glue as a soft baseline.\\n    // This is a soft adaptation, not strictly \\\"previous\\\" but consistent for moving average.\\n    // If you have a better baseline, swap it in.\\n    if (\\n      decision_rate < 0.85 * glue_limit && // decision rate dropped below threshold\\n      (CONFLICTS - solver->limits.restart.conflicts) >= 0.5 * GET_OPTION(restartint)\\n    ) {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode ---\\n  // Baseline: Reluctant Luby trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: If enabled, check if current heuristic is severely underperforming\\n  if (solver->mab && (CONFLICTS >= solver->limits.restart.conflicts)) {\\n    const unsigned h = solver->heuristic;     // current heuristic: 0=VSIDS, 1=CHB\\n    const unsigned other = 1 - h;\\n    const double rew = solver->mab_select[h] ? solver->mab_reward[h] / solver->mab_select[h] : 0.0;\\n    const double rew_other = solver->mab_select[other] ? solver->mab_reward[other] / solver->mab_select[other] : 0.0;\\n\\n    // If this heuristic has been selected at least twice, and is worse than 85% of alternative,\\n    // and enough conflicts passed, trigger a restart.\\n    if (\\n      solver->mab_select[h] >= 2 &&\\n      rew < 0.85 * rew_other &&\\n      solver->mab_conflicts > 0.5 * GET_OPTION(restartint)\\n    ) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard conditions\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // FOCUSED MODE: glue margin + decision rate adaptation\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // Decision rate adaptation: restart if decision rate dropped sharply and enough conflicts since last restart\\n    // NOTE: No explicit previous_decision_rate or last_restart_conflicts available;\\n    // Fallback: use restartint as threshold, and compare decision rate to running average (rarely triggers if not available)\\n    // Since we do not have previous_decision_rate, skip this branch if not tracked.\\n    // (Here, we conservatively do not implement this branch due to unavailable variables.)\\n    return false;\\n  }\\n\\n  // STABLE MODE: reluctant or MAB-aware trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware restart in stable mode\\n  if (solver->mab && (CONFLICTS >= solver->limits.restart.conflicts)) {\\n    const unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n    const unsigned other = 1 - h;\\n    const double reward_h = solver->mab_select[h] ? solver->mab_reward[h] / solver->mab_select[h] : 0.0;\\n    const double reward_other = solver->mab_select[other] ? solver->mab_reward[other] / solver->mab_select[other] : 0.0;\\n    if (solver->mab_select[h] >= 2 &&\\n        reward_h < 0.85 * reward_other &&\\n        solver->mab_conflicts > 0.5 * GET_OPTION(restartint))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 185.3558,
    "par2_rejected": 190.94569999999996
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Luby Trigger\n\nAlgorithm: 1. Check guards: if solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n2. If in focused mode (solver->stable == false):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND (fast_glue >= (1.0 + GET_OPTION(restartmargin)/100.0) * slow_glue), return true.\n   - ELSE IF (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(decision_rate) < 0.85 * previous_decision_rate) AND (CONFLICTS - last_restart_conflicts >= 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.\n3. If in stable mode (solver->stable == true):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant), return true.\n   - ELSE IF solver->mab == true AND (CONFLICTS >= solver->limits.restart.conflicts):\n     - Let h = solver->heuristic (current heuristic: 0=VSIDS, 1=CHB)\n     - Let rew = solver->mab_reward[h], times = solver->mab_select[h]\n     - If (times >= 2) AND (rew < 0.85 * (solver->mab_reward[1-h] / max(solver->mab_select[1-h],1))) AND (solver->mab_conflicts > 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double glue_limit = margin * slow;\\n\\n    // Baseline glue-based trigger\\n    if (fast >= glue_limit)\\n      return true;\\n\\n    // Decision rate based trigger (if decision rate drops sharply)\\n    // We approximate previous_decision_rate as the slow average (since no explicit prev value)\\n    // This is a heuristic: if decision rate EMA drops below 85% of slow_glue baseline\\n    // and enough conflicts since last restart threshold advanced.\\n    const double decision_rate = AVERAGE(decision_rate);\\n    // For lack of explicit previous_decision_rate, we use slow_glue as a soft baseline.\\n    // This is a soft adaptation, not strictly \\\"previous\\\" but consistent for moving average.\\n    // If you have a better baseline, swap it in.\\n    if (\\n      decision_rate < 0.85 * glue_limit && // decision rate dropped below threshold\\n      (CONFLICTS - solver->limits.restart.conflicts) >= 0.5 * GET_OPTION(restartint)\\n    ) {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode ---\\n  // Baseline: Reluctant Luby trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: If enabled, check if current heuristic is severely underperforming\\n  if (solver->mab && (CONFLICTS >= solver->limits.restart.conflicts)) {\\n    const unsigned h = solver->heuristic;     // current heuristic: 0=VSIDS, 1=CHB\\n    const unsigned other = 1 - h;\\n    const double rew = solver->mab_select[h] ? solver->mab_reward[h] / solver->mab_select[h] : 0.0;\\n    const double rew_other = solver->mab_select[other] ? solver->mab_reward[other] / solver->mab_select[other] : 0.0;\\n\\n    // If this heuristic has been selected at least twice, and is worse than 85% of alternative,\\n    // and enough conflicts passed, trigger a restart.\\n    if (\\n      solver->mab_select[h] >= 2 &&\\n      rew < 0.85 * rew_other &&\\n      solver->mab_conflicts > 0.5 * GET_OPTION(restartint)\\n    ) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at decision level 0?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not enough conflicts since last restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode: glue-based + decision-rate fallback ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double glue_limit = margin * slow;\\n\\n    // Standard glue-based trigger\\n    if (fast >= glue_limit)\\n      return true;\\n\\n    // Decision rate fallback: only if enough conflicts since last restart\\n    // (We do not have access to previous_decision_rate directly, so skip this fallback unless such tracking exists in the codebase)\\n    // If you have a historical rate, you could compare AVERAGE(decision_rate) to it here.\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode: reluctant/Luby or MAB fallback ---\\n  // Standard reluctant (Luby) trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware fallback: if enabled and primary trigger not fired\\n  if (solver->mab) {\\n    const unsigned h = solver->heuristic;  // 0=VSIDS, 1=CHB\\n    const unsigned h_other = 1 - h;\\n    const double reward = solver->mab_reward[h];\\n    const double n = (double) solver->mab_select[h];\\n    const double reward_other = solver->mab_reward[h_other];\\n    const double n_other = (double) solver->mab_select[h_other];\\n\\n    // Only consider if current heuristic used at least twice\\n    if (n >= 2) {\\n      // Avoid division by zero\\n      double avg_other = n_other > 0 ? (reward_other / n_other) : 0.0;\\n      double avg_this  = n > 0 ? (reward / n) : 0.0;\\n\\n      // If this heuristic underperforms the other by 15% or more (and enough conflicts since last restart), restart\\n      if (avg_this < 0.85 * avg_other && solver->mab_conflicts > 0.5 * GET_OPTION(restartint))\\n        return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 185.3558,
    "par2_rejected": 192.69900000000004
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Luby Trigger\n\nAlgorithm: 1. Check guards: if solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n2. If in focused mode (solver->stable == false):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND (fast_glue >= (1.0 + GET_OPTION(restartmargin)/100.0) * slow_glue), return true.\n   - ELSE IF (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(decision_rate) < 0.85 * previous_decision_rate) AND (CONFLICTS - last_restart_conflicts >= 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.\n3. If in stable mode (solver->stable == true):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant), return true.\n   - ELSE IF solver->mab == true AND (CONFLICTS >= solver->limits.restart.conflicts):\n     - Let h = solver->heuristic (current heuristic: 0=VSIDS, 1=CHB)\n     - Let rew = solver->mab_reward[h], times = solver->mab_select[h]\n     - If (times >= 2) AND (rew < 0.85 * (solver->mab_reward[1-h] / max(solver->mab_select[1-h],1))) AND (solver->mab_conflicts > 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double glue_limit = margin * slow;\\n\\n    // Baseline glue-based trigger\\n    if (fast >= glue_limit)\\n      return true;\\n\\n    // Decision rate based trigger (if decision rate drops sharply)\\n    // We approximate previous_decision_rate as the slow average (since no explicit prev value)\\n    // This is a heuristic: if decision rate EMA drops below 85% of slow_glue baseline\\n    // and enough conflicts since last restart threshold advanced.\\n    const double decision_rate = AVERAGE(decision_rate);\\n    // For lack of explicit previous_decision_rate, we use slow_glue as a soft baseline.\\n    // This is a soft adaptation, not strictly \\\"previous\\\" but consistent for moving average.\\n    // If you have a better baseline, swap it in.\\n    if (\\n      decision_rate < 0.85 * glue_limit && // decision rate dropped below threshold\\n      (CONFLICTS - solver->limits.restart.conflicts) >= 0.5 * GET_OPTION(restartint)\\n    ) {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode ---\\n  // Baseline: Reluctant Luby trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: If enabled, check if current heuristic is severely underperforming\\n  if (solver->mab && (CONFLICTS >= solver->limits.restart.conflicts)) {\\n    const unsigned h = solver->heuristic;     // current heuristic: 0=VSIDS, 1=CHB\\n    const unsigned other = 1 - h;\\n    const double rew = solver->mab_select[h] ? solver->mab_reward[h] / solver->mab_select[h] : 0.0;\\n    const double rew_other = solver->mab_select[other] ? solver->mab_reward[other] / solver->mab_select[other] : 0.0;\\n\\n    // If this heuristic has been selected at least twice, and is worse than 85% of alternative,\\n    // and enough conflicts passed, trigger a restart.\\n    if (\\n      solver->mab_select[h] >= 2 &&\\n      rew < 0.85 * rew_other &&\\n      solver->mab_conflicts > 0.5 * GET_OPTION(restartint)\\n    ) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n  // Guard: not at root level\\n  if (!solver->level)\\n    return false;\\n  // Guard: not yet at restart conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  // Focused mode: Glue-based or decision-rate-based restarts\\n  if (!solver->stable) {\\n    if (fast >= limit)\\n      return true;\\n\\n    // Decision rate drop trigger (requires at least one previous restart)\\n    static double prev_decision_rate = 0.0;\\n    static uint64_t prev_restart_conflicts = 0;\\n\\n    double current_decision_rate = AVERAGE(decision_rate);\\n    uint64_t since_last_restart = CONFLICTS - prev_restart_conflicts;\\n    double restartint_half = 0.5 * GET_OPTION(restartint);\\n\\n    bool trigger = false;\\n\\n    if (prev_decision_rate > 0.0 &&\\n        current_decision_rate < 0.85 * prev_decision_rate &&\\n        since_last_restart >= restartint_half) {\\n      trigger = true;\\n    }\\n\\n    // Update only on actual restart (simulate: will update on next actual restart)\\n    if (trigger) {\\n      // These are static so only for diagnostics; Kissat updates stats in restart logic.\\n      // If needed: prev_decision_rate = current_decision_rate;\\n      //            prev_restart_conflicts = CONFLICTS;\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  // Stable mode: reluctant or MAB-accelerated restarts\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB signal for restart in stable mode\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned alt = 1 - h;\\n    double rew = solver->mab_reward[h];\\n    double n = (double)solver->mab_select[h];\\n    double alt_rew = solver->mab_reward[alt];\\n    double alt_n = (double)solver->mab_select[alt];\\n\\n    // Use average reward per selection for each heuristic\\n    double avg_rew = n > 0 ? rew / n : 0.0;\\n    double avg_alt = alt_n > 0 ? alt_rew / alt_n : 0.0;\\n\\n    if (n >= 2 &&\\n        avg_rew < 0.85 * avg_alt &&\\n        solver->mab_conflicts > 0.5 * GET_OPTION(restartint)) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 185.3558,
    "par2_rejected": 194.01760000000002
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Luby Trigger\n\nAlgorithm: 1. Check guards: if solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n2. If in focused mode (solver->stable == false):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND (fast_glue >= (1.0 + GET_OPTION(restartmargin)/100.0) * slow_glue), return true.\n   - ELSE IF (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(decision_rate) < 0.85 * previous_decision_rate) AND (CONFLICTS - last_restart_conflicts >= 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.\n3. If in stable mode (solver->stable == true):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant), return true.\n   - ELSE IF solver->mab == true AND (CONFLICTS >= solver->limits.restart.conflicts):\n     - Let h = solver->heuristic (current heuristic: 0=VSIDS, 1=CHB)\n     - Let rew = solver->mab_reward[h], times = solver->mab_select[h]\n     - If (times >= 2) AND (rew < 0.85 * (solver->mab_reward[1-h] / max(solver->mab_select[1-h],1))) AND (solver->mab_conflicts > 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double glue_limit = margin * slow;\\n\\n    // Baseline glue-based trigger\\n    if (fast >= glue_limit)\\n      return true;\\n\\n    // Decision rate based trigger (if decision rate drops sharply)\\n    // We approximate previous_decision_rate as the slow average (since no explicit prev value)\\n    // This is a heuristic: if decision rate EMA drops below 85% of slow_glue baseline\\n    // and enough conflicts since last restart threshold advanced.\\n    const double decision_rate = AVERAGE(decision_rate);\\n    // For lack of explicit previous_decision_rate, we use slow_glue as a soft baseline.\\n    // This is a soft adaptation, not strictly \\\"previous\\\" but consistent for moving average.\\n    // If you have a better baseline, swap it in.\\n    if (\\n      decision_rate < 0.85 * glue_limit && // decision rate dropped below threshold\\n      (CONFLICTS - solver->limits.restart.conflicts) >= 0.5 * GET_OPTION(restartint)\\n    ) {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode ---\\n  // Baseline: Reluctant Luby trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: If enabled, check if current heuristic is severely underperforming\\n  if (solver->mab && (CONFLICTS >= solver->limits.restart.conflicts)) {\\n    const unsigned h = solver->heuristic;     // current heuristic: 0=VSIDS, 1=CHB\\n    const unsigned other = 1 - h;\\n    const double rew = solver->mab_select[h] ? solver->mab_reward[h] / solver->mab_select[h] : 0.0;\\n    const double rew_other = solver->mab_select[other] ? solver->mab_reward[other] / solver->mab_select[other] : 0.0;\\n\\n    // If this heuristic has been selected at least twice, and is worse than 85% of alternative,\\n    // and enough conflicts passed, trigger a restart.\\n    if (\\n      solver->mab_select[h] >= 2 &&\\n      rew < 0.85 * rew_other &&\\n      solver->mab_conflicts > 0.5 * GET_OPTION(restartint)\\n    ) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Conflict guard\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode ---\\n  if (!solver->stable) {\\n    // Standard glue-based restart\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // MAB-independent: decision rate drop heuristic\\n    // Use decision rate drop as additional trigger (if available)\\n    // We approximate \\\"previous_decision_rate\\\" by using 'limit' (slow average glue) heuristically,\\n    // but since we do not have direct access to previous_decision_rate, this is not calculated.\\n\\n    // Optionally: check if decision rate has dropped significantly\\n    // (if conflicting enough since last restart, and low decision rate)\\n    // But we lack previous_decision_rate or CONFLICTS at last restart.\\n    // So this block is omitted unless state is augmented elsewhere.\\n    return false;\\n  }\\n\\n  // --- Stable mode ---\\n  // Standard reluctant-based restart\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: if MAB is enabled, try adaptive restart if heuristic is underperforming\\n  if (solver->mab) {\\n    const unsigned h = solver->heuristic;             // 0 = VSIDS, 1 = CHB\\n    const unsigned alt = 1 - h;\\n    const unsigned times = solver->mab_select[h];\\n    const unsigned alt_times = solver->mab_select[alt];\\n    const double rew = solver->mab_select[h] ? (solver->mab_reward[h] / solver->mab_select[h]) : 0.0;\\n    const double alt_rew = solver->mab_select[alt] ? (solver->mab_reward[alt] / solver->mab_select[alt]) : 0.0;\\n\\n    // Require at least two times using current heuristic for meaningful comparison\\n    if (times >= 2) {\\n      // If current heuristic's average reward is < 85% of the alternative's\\n      if (alt_times > 0 && rew < 0.85 * alt_rew) {\\n        // Also require enough conflicts since last restart\\n        if (solver->mab_conflicts > 0.5 * GET_OPTION(restartint))\\n          return true;\\n      }\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 185.3558,
    "par2_rejected": 194.4395
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Luby Trigger\n\nAlgorithm: 1. Check guards: if solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n2. If in focused mode (solver->stable == false):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND (fast_glue >= (1.0 + GET_OPTION(restartmargin)/100.0) * slow_glue), return true.\n   - ELSE IF (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(decision_rate) < 0.85 * previous_decision_rate) AND (CONFLICTS - last_restart_conflicts >= 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.\n3. If in stable mode (solver->stable == true):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant), return true.\n   - ELSE IF solver->mab == true AND (CONFLICTS >= solver->limits.restart.conflicts):\n     - Let h = solver->heuristic (current heuristic: 0=VSIDS, 1=CHB)\n     - Let rew = solver->mab_reward[h], times = solver->mab_select[h]\n     - If (times >= 2) AND (rew < 0.85 * (solver->mab_reward[1-h] / max(solver->mab_select[1-h],1))) AND (solver->mab_conflicts > 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double glue_limit = margin * slow;\\n\\n    // Baseline glue-based trigger\\n    if (fast >= glue_limit)\\n      return true;\\n\\n    // Decision rate based trigger (if decision rate drops sharply)\\n    // We approximate previous_decision_rate as the slow average (since no explicit prev value)\\n    // This is a heuristic: if decision rate EMA drops below 85% of slow_glue baseline\\n    // and enough conflicts since last restart threshold advanced.\\n    const double decision_rate = AVERAGE(decision_rate);\\n    // For lack of explicit previous_decision_rate, we use slow_glue as a soft baseline.\\n    // This is a soft adaptation, not strictly \\\"previous\\\" but consistent for moving average.\\n    // If you have a better baseline, swap it in.\\n    if (\\n      decision_rate < 0.85 * glue_limit && // decision rate dropped below threshold\\n      (CONFLICTS - solver->limits.restart.conflicts) >= 0.5 * GET_OPTION(restartint)\\n    ) {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode ---\\n  // Baseline: Reluctant Luby trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: If enabled, check if current heuristic is severely underperforming\\n  if (solver->mab && (CONFLICTS >= solver->limits.restart.conflicts)) {\\n    const unsigned h = solver->heuristic;     // current heuristic: 0=VSIDS, 1=CHB\\n    const unsigned other = 1 - h;\\n    const double rew = solver->mab_select[h] ? solver->mab_reward[h] / solver->mab_select[h] : 0.0;\\n    const double rew_other = solver->mab_select[other] ? solver->mab_reward[other] / solver->mab_select[other] : 0.0;\\n\\n    // If this heuristic has been selected at least twice, and is worse than 85% of alternative,\\n    // and enough conflicts passed, trigger a restart.\\n    if (\\n      solver->mab_select[h] >= 2 &&\\n      rew < 0.85 * rew_other &&\\n      solver->mab_conflicts > 0.5 * GET_OPTION(restartint)\\n    ) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts are disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: don't restart at top level\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not yet reached restart conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n\\n  if (!solver->stable) {\\n    // Focused mode: classic glue trigger\\n    if (fast >= glue_limit)\\n      return true;\\n\\n    // Focused: secondary trigger if decision rate collapsed\\n    // (simulate \\\\\\\"previous_decision_rate\\\\\\\" as slow EMA, and check drop)\\n    // Note: since we cannot access previous_decision_rate directly,\\n    // use slow vs fast, or skip this secondary trigger if not tracked.\\n    //\\n    // Here, only the glue trigger is used for focused mode.\\n    return false;\\n  }\\n\\n  // Stable mode\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // Stable mode: MAB-aware trigger\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic; // 0:VSIDS, 1:CHB\\n    unsigned h_other = 1 - h;\\n    double rew = solver->mab_select[h] ? solver->mab_reward[h] / solver->mab_select[h] : 0.0;\\n    double rew_other = solver->mab_select[h_other] ? solver->mab_reward[h_other] / solver->mab_select[h_other] : 0.0;\\n\\n    // If both heuristics selected at least twice, and current is underperforming\\n    if (\\n      solver->mab_select[h] >= 2 &&\\n      rew < 0.85 * rew_other &&\\n      solver->mab_conflicts > 0.5 * GET_OPTION(restartint)\\n    ) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 185.3558,
    "par2_rejected": 195.99730000000002
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Luby Trigger\n\nAlgorithm: 1. Check guards: if solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n2. If in focused mode (solver->stable == false):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND (fast_glue >= (1.0 + GET_OPTION(restartmargin)/100.0) * slow_glue), return true.\n   - ELSE IF (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(decision_rate) < 0.85 * previous_decision_rate) AND (CONFLICTS - last_restart_conflicts >= 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.\n3. If in stable mode (solver->stable == true):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant), return true.\n   - ELSE IF solver->mab == true AND (CONFLICTS >= solver->limits.restart.conflicts):\n     - Let h = solver->heuristic (current heuristic: 0=VSIDS, 1=CHB)\n     - Let rew = solver->mab_reward[h], times = solver->mab_select[h]\n     - If (times >= 2) AND (rew < 0.85 * (solver->mab_reward[1-h] / max(solver->mab_select[1-h],1))) AND (solver->mab_conflicts > 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused Mode (non-stable): Glue Margin or Decision Rate Drop ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    // Standard glue-based restart\\n    if (fast >= limit)\\n      return true;\\n\\n    // Decision rate drop restart (adaptive, only if enough conflicts since last restart)\\n    const double drate = AVERAGE(decision_rate);\\n    // Use previous decision rate as \\\"limit\\\" (since averages are exponential, slow_glue is a fair proxy for baseline)\\n    // Here, we compare to the same EMA: i.e., if drate drops below 85% of current EMA\\n    // This is a soft signal; we require enough conflicts since last restart\\n    if (drate < 0.85 * limit &&\\n        (CONFLICTS - solver->statistics.restarts * GET_OPTION(restartint) >= 0.5 * GET_OPTION(restartint))) {\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Stable Mode ---\\n  // First: classic reluctant/Luby-based trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // --- MAB-Aware Restart: if enabled and classic did not trigger ---\\n  if (solver->mab) {\\n    if (CONFLICTS >= solver->limits.restart.conflicts) {\\n      const unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n      const unsigned h_alt = 1 - h;\\n      const double reward_h = solver->mab_select[h] ? solver->mab_reward[h] / solver->mab_select[h] : 0.0;\\n      const double reward_alt = solver->mab_select[h_alt] ? solver->mab_reward[h_alt] / solver->mab_select[h_alt] : 0.0;\\n\\n      if (\\n        solver->mab_select[h] >= 2 &&\\n        reward_h < 0.85 * reward_alt &&\\n        solver->mab_conflicts > 0.5 * GET_OPTION(restartint)\\n      ) {\\n        return true;\\n      }\\n    }\\n  }\\n\\n  // Otherwise, no restart.\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n  // Guard: not at root level\\n  if (!solver->level)\\n    return false;\\n  // Guard: not yet at restart conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  // Focused mode: Glue-based or decision-rate-based restarts\\n  if (!solver->stable) {\\n    if (fast >= limit)\\n      return true;\\n\\n    // Decision rate drop trigger (requires at least one previous restart)\\n    static double prev_decision_rate = 0.0;\\n    static uint64_t prev_restart_conflicts = 0;\\n\\n    double current_decision_rate = AVERAGE(decision_rate);\\n    uint64_t since_last_restart = CONFLICTS - prev_restart_conflicts;\\n    double restartint_half = 0.5 * GET_OPTION(restartint);\\n\\n    bool trigger = false;\\n\\n    if (prev_decision_rate > 0.0 &&\\n        current_decision_rate < 0.85 * prev_decision_rate &&\\n        since_last_restart >= restartint_half) {\\n      trigger = true;\\n    }\\n\\n    // Update only on actual restart (simulate: will update on next actual restart)\\n    if (trigger) {\\n      // These are static so only for diagnostics; Kissat updates stats in restart logic.\\n      // If needed: prev_decision_rate = current_decision_rate;\\n      //            prev_restart_conflicts = CONFLICTS;\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  // Stable mode: reluctant or MAB-accelerated restarts\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB signal for restart in stable mode\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned alt = 1 - h;\\n    double rew = solver->mab_reward[h];\\n    double n = (double)solver->mab_select[h];\\n    double alt_rew = solver->mab_reward[alt];\\n    double alt_n = (double)solver->mab_select[alt];\\n\\n    // Use average reward per selection for each heuristic\\n    double avg_rew = n > 0 ? rew / n : 0.0;\\n    double avg_alt = alt_n > 0 ? alt_rew / alt_n : 0.0;\\n\\n    if (n >= 2 &&\\n        avg_rew < 0.85 * avg_alt &&\\n        solver->mab_conflicts > 0.5 * GET_OPTION(restartint)) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 187.8207,
    "par2_rejected": 194.01760000000002
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Luby Trigger\n\nAlgorithm: 1. Check guards: if solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n2. If in focused mode (solver->stable == false):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND (fast_glue >= (1.0 + GET_OPTION(restartmargin)/100.0) * slow_glue), return true.\n   - ELSE IF (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(decision_rate) < 0.85 * previous_decision_rate) AND (CONFLICTS - last_restart_conflicts >= 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.\n3. If in stable mode (solver->stable == true):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant), return true.\n   - ELSE IF solver->mab == true AND (CONFLICTS >= solver->limits.restart.conflicts):\n     - Let h = solver->heuristic (current heuristic: 0=VSIDS, 1=CHB)\n     - Let rew = solver->mab_reward[h], times = solver->mab_select[h]\n     - If (times >= 2) AND (rew < 0.85 * (solver->mab_reward[1-h] / max(solver->mab_select[1-h],1))) AND (solver->mab_conflicts > 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused Mode (non-stable): Glue Margin or Decision Rate Drop ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    // Standard glue-based restart\\n    if (fast >= limit)\\n      return true;\\n\\n    // Decision rate drop restart (adaptive, only if enough conflicts since last restart)\\n    const double drate = AVERAGE(decision_rate);\\n    // Use previous decision rate as \\\"limit\\\" (since averages are exponential, slow_glue is a fair proxy for baseline)\\n    // Here, we compare to the same EMA: i.e., if drate drops below 85% of current EMA\\n    // This is a soft signal; we require enough conflicts since last restart\\n    if (drate < 0.85 * limit &&\\n        (CONFLICTS - solver->statistics.restarts * GET_OPTION(restartint) >= 0.5 * GET_OPTION(restartint))) {\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Stable Mode ---\\n  // First: classic reluctant/Luby-based trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // --- MAB-Aware Restart: if enabled and classic did not trigger ---\\n  if (solver->mab) {\\n    if (CONFLICTS >= solver->limits.restart.conflicts) {\\n      const unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n      const unsigned h_alt = 1 - h;\\n      const double reward_h = solver->mab_select[h] ? solver->mab_reward[h] / solver->mab_select[h] : 0.0;\\n      const double reward_alt = solver->mab_select[h_alt] ? solver->mab_reward[h_alt] / solver->mab_select[h_alt] : 0.0;\\n\\n      if (\\n        solver->mab_select[h] >= 2 &&\\n        reward_h < 0.85 * reward_alt &&\\n        solver->mab_conflicts > 0.5 * GET_OPTION(restartint)\\n      ) {\\n        return true;\\n      }\\n    }\\n  }\\n\\n  // Otherwise, no restart.\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Conflict guard\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode ---\\n  if (!solver->stable) {\\n    // Standard glue-based restart\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // MAB-independent: decision rate drop heuristic\\n    // Use decision rate drop as additional trigger (if available)\\n    // We approximate \\\"previous_decision_rate\\\" by using 'limit' (slow average glue) heuristically,\\n    // but since we do not have direct access to previous_decision_rate, this is not calculated.\\n\\n    // Optionally: check if decision rate has dropped significantly\\n    // (if conflicting enough since last restart, and low decision rate)\\n    // But we lack previous_decision_rate or CONFLICTS at last restart.\\n    // So this block is omitted unless state is augmented elsewhere.\\n    return false;\\n  }\\n\\n  // --- Stable mode ---\\n  // Standard reluctant-based restart\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: if MAB is enabled, try adaptive restart if heuristic is underperforming\\n  if (solver->mab) {\\n    const unsigned h = solver->heuristic;             // 0 = VSIDS, 1 = CHB\\n    const unsigned alt = 1 - h;\\n    const unsigned times = solver->mab_select[h];\\n    const unsigned alt_times = solver->mab_select[alt];\\n    const double rew = solver->mab_select[h] ? (solver->mab_reward[h] / solver->mab_select[h]) : 0.0;\\n    const double alt_rew = solver->mab_select[alt] ? (solver->mab_reward[alt] / solver->mab_select[alt]) : 0.0;\\n\\n    // Require at least two times using current heuristic for meaningful comparison\\n    if (times >= 2) {\\n      // If current heuristic's average reward is < 85% of the alternative's\\n      if (alt_times > 0 && rew < 0.85 * alt_rew) {\\n        // Also require enough conflicts since last restart\\n        if (solver->mab_conflicts > 0.5 * GET_OPTION(restartint))\\n          return true;\\n      }\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 187.8207,
    "par2_rejected": 194.4395
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Luby Trigger\n\nAlgorithm: 1. Check guards: if solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n2. If in focused mode (solver->stable == false):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND (fast_glue >= (1.0 + GET_OPTION(restartmargin)/100.0) * slow_glue), return true.\n   - ELSE IF (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(decision_rate) < 0.85 * previous_decision_rate) AND (CONFLICTS - last_restart_conflicts >= 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.\n3. If in stable mode (solver->stable == true):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant), return true.\n   - ELSE IF solver->mab == true AND (CONFLICTS >= solver->limits.restart.conflicts):\n     - Let h = solver->heuristic (current heuristic: 0=VSIDS, 1=CHB)\n     - Let rew = solver->mab_reward[h], times = solver->mab_select[h]\n     - If (times >= 2) AND (rew < 0.85 * (solver->mab_reward[1-h] / max(solver->mab_select[1-h],1))) AND (solver->mab_conflicts > 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused Mode (non-stable): Glue Margin or Decision Rate Drop ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    // Standard glue-based restart\\n    if (fast >= limit)\\n      return true;\\n\\n    // Decision rate drop restart (adaptive, only if enough conflicts since last restart)\\n    const double drate = AVERAGE(decision_rate);\\n    // Use previous decision rate as \\\"limit\\\" (since averages are exponential, slow_glue is a fair proxy for baseline)\\n    // Here, we compare to the same EMA: i.e., if drate drops below 85% of current EMA\\n    // This is a soft signal; we require enough conflicts since last restart\\n    if (drate < 0.85 * limit &&\\n        (CONFLICTS - solver->statistics.restarts * GET_OPTION(restartint) >= 0.5 * GET_OPTION(restartint))) {\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Stable Mode ---\\n  // First: classic reluctant/Luby-based trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // --- MAB-Aware Restart: if enabled and classic did not trigger ---\\n  if (solver->mab) {\\n    if (CONFLICTS >= solver->limits.restart.conflicts) {\\n      const unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n      const unsigned h_alt = 1 - h;\\n      const double reward_h = solver->mab_select[h] ? solver->mab_reward[h] / solver->mab_select[h] : 0.0;\\n      const double reward_alt = solver->mab_select[h_alt] ? solver->mab_reward[h_alt] / solver->mab_select[h_alt] : 0.0;\\n\\n      if (\\n        solver->mab_select[h] >= 2 &&\\n        reward_h < 0.85 * reward_alt &&\\n        solver->mab_conflicts > 0.5 * GET_OPTION(restartint)\\n      ) {\\n        return true;\\n      }\\n    }\\n  }\\n\\n  // Otherwise, no restart.\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts are disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: don't restart at top level\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not yet reached restart conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n\\n  if (!solver->stable) {\\n    // Focused mode: classic glue trigger\\n    if (fast >= glue_limit)\\n      return true;\\n\\n    // Focused: secondary trigger if decision rate collapsed\\n    // (simulate \\\\\\\"previous_decision_rate\\\\\\\" as slow EMA, and check drop)\\n    // Note: since we cannot access previous_decision_rate directly,\\n    // use slow vs fast, or skip this secondary trigger if not tracked.\\n    //\\n    // Here, only the glue trigger is used for focused mode.\\n    return false;\\n  }\\n\\n  // Stable mode\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // Stable mode: MAB-aware trigger\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic; // 0:VSIDS, 1:CHB\\n    unsigned h_other = 1 - h;\\n    double rew = solver->mab_select[h] ? solver->mab_reward[h] / solver->mab_select[h] : 0.0;\\n    double rew_other = solver->mab_select[h_other] ? solver->mab_reward[h_other] / solver->mab_select[h_other] : 0.0;\\n\\n    // If both heuristics selected at least twice, and current is underperforming\\n    if (\\n      solver->mab_select[h] >= 2 &&\\n      rew < 0.85 * rew_other &&\\n      solver->mab_conflicts > 0.5 * GET_OPTION(restartint)\\n    ) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 187.8207,
    "par2_rejected": 195.99730000000002
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Luby Trigger\n\nAlgorithm: 1. Check guards: if solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n2. If in focused mode (solver->stable == false):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND (fast_glue >= (1.0 + GET_OPTION(restartmargin)/100.0) * slow_glue), return true.\n   - ELSE IF (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(decision_rate) < 0.85 * previous_decision_rate) AND (CONFLICTS - last_restart_conflicts >= 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.\n3. If in stable mode (solver->stable == true):\n   - If (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant), return true.\n   - ELSE IF solver->mab == true AND (CONFLICTS >= solver->limits.restart.conflicts):\n     - Let h = solver->heuristic (current heuristic: 0=VSIDS, 1=CHB)\n     - Let rew = solver->mab_reward[h], times = solver->mab_select[h]\n     - If (times >= 2) AND (rew < 0.85 * (solver->mab_reward[1-h] / max(solver->mab_select[1-h],1))) AND (solver->mab_conflicts > 0.5 * GET_OPTION(restartint)), return true.\n   - Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard conditions\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // FOCUSED MODE: glue margin + decision rate adaptation\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // Decision rate adaptation: restart if decision rate dropped sharply and enough conflicts since last restart\\n    // NOTE: No explicit previous_decision_rate or last_restart_conflicts available;\\n    // Fallback: use restartint as threshold, and compare decision rate to running average (rarely triggers if not available)\\n    // Since we do not have previous_decision_rate, skip this branch if not tracked.\\n    // (Here, we conservatively do not implement this branch due to unavailable variables.)\\n    return false;\\n  }\\n\\n  // STABLE MODE: reluctant or MAB-aware trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware restart in stable mode\\n  if (solver->mab && (CONFLICTS >= solver->limits.restart.conflicts)) {\\n    const unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n    const unsigned other = 1 - h;\\n    const double reward_h = solver->mab_select[h] ? solver->mab_reward[h] / solver->mab_select[h] : 0.0;\\n    const double reward_other = solver->mab_select[other] ? solver->mab_reward[other] / solver->mab_select[other] : 0.0;\\n    if (solver->mab_select[h] >= 2 &&\\n        reward_h < 0.85 * reward_other &&\\n        solver->mab_conflicts > 0.5 * GET_OPTION(restartint))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts are disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: don't restart at top level\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not yet reached restart conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n\\n  if (!solver->stable) {\\n    // Focused mode: classic glue trigger\\n    if (fast >= glue_limit)\\n      return true;\\n\\n    // Focused: secondary trigger if decision rate collapsed\\n    // (simulate \\\\\\\"previous_decision_rate\\\\\\\" as slow EMA, and check drop)\\n    // Note: since we cannot access previous_decision_rate directly,\\n    // use slow vs fast, or skip this secondary trigger if not tracked.\\n    //\\n    // Here, only the glue trigger is used for focused mode.\\n    return false;\\n  }\\n\\n  // Stable mode\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // Stable mode: MAB-aware trigger\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic; // 0:VSIDS, 1:CHB\\n    unsigned h_other = 1 - h;\\n    double rew = solver->mab_select[h] ? solver->mab_reward[h] / solver->mab_select[h] : 0.0;\\n    double rew_other = solver->mab_select[h_other] ? solver->mab_reward[h_other] / solver->mab_select[h_other] : 0.0;\\n\\n    // If both heuristics selected at least twice, and current is underperforming\\n    if (\\n      solver->mab_select[h] >= 2 &&\\n      rew < 0.85 * rew_other &&\\n      solver->mab_conflicts > 0.5 * GET_OPTION(restartint)\\n    ) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 190.94569999999996,
    "par2_rejected": 195.99730000000002
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode ---\\n  if (solver->stable) {\\n    // Baseline: Reluctant restart after conflict interval\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB adaptive stagnation: If enabled, and enough conflicts, trigger if progress is low\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      const double avg_decisions_per_conflict = AVERAGE(decision_rate);\\n      // If actual per-conflict decisions is less than 80% of moving average, stagnation\\n      if (avg_decisions_per_conflict > 0) {\\n        double actual = solver->mab_decisions / (double)solver->mab_conflicts;\\n        if (actual < 0.8 * avg_decisions_per_conflict)\\n          return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused Mode ---\\n  {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    // Baseline glue-based restart\\n    if (fast >= limit)\\n      return true;\\n\\n    // Adaptive: If decision rate drops sharply, restart (simulate via moving average comparison)\\n    // Suppose previous decision_rate is approximated by slow (since we only have the EMA)\\n    // We cannot track previous EMA in this function, so rely on a sharp drop threshold\\n    // Heuristic: if decision rate < 70% of its EMA (shouldn't trigger normally unless stuck)\\n    const double rate = AVERAGE(decision_rate);\\n    if (rate > 0 && solver->mab && solver->mab_conflicts >= 100) {\\n      double actual = solver->mab_decisions / (double)solver->mab_conflicts;\\n      if (actual < 0.7 * rate)\\n        return true;\\n    }\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard checks\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode ---\\n  if (solver->stable) {\\n    // 1. Baseline: Reluctant (Luby) trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // 2. MAB stagnation: If enabled and enough data, trigger if decisions are much lower than recent typical\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      double recent_decision_rate = AVERAGE(decision_rate);\\n      double expected_decisions = recent_decision_rate * solver->mab_conflicts;\\n      if (solver->mab_decisions < 0.8 * expected_decisions)\\n        return true;\\n    }\\n\\n    // Otherwise, don't restart\\n    return false;\\n  }\\n\\n  // --- Focused Mode ---\\n  {\\n    // 1. Baseline: Glue-based trigger with margin\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // 2. Decision rate stagnation: If rate drops sharply, trigger early restart\\n    // Compare current decision rate to the EMA (already tracked by framework)\\n    // We use a 0.7 threshold for sharp drop\\n    // (If decision rate is less than 70% of EMA, trigger)\\n    const double curr_rate = AVERAGE(decision_rate);\\n    // For lack of \\\\\\\"previous\\\\\\\" EMA, in Kissat the .value is the EMA, so compare to itself in last window,\\n    // but here we simply use the current EMA, and if it is extremely low, trigger\\n    // This will only trigger if the decision rate has dropped much below its historic EMA\\n    // In practice, this condition will rarely fire, but is safe for adaptive restarts\\n\\n    // (Extra: could expose previous EMA, but not available in existing interface)\\n    if (curr_rate < 0.05) // Empirically, tiny rates indicate solver got stuck\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 172.4409,
    "par2_rejected": 183.52290000000002
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode ---\\n  if (solver->stable) {\\n    // Baseline: Reluctant restart after conflict interval\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB adaptive stagnation: If enabled, and enough conflicts, trigger if progress is low\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      const double avg_decisions_per_conflict = AVERAGE(decision_rate);\\n      // If actual per-conflict decisions is less than 80% of moving average, stagnation\\n      if (avg_decisions_per_conflict > 0) {\\n        double actual = solver->mab_decisions / (double)solver->mab_conflicts;\\n        if (actual < 0.8 * avg_decisions_per_conflict)\\n          return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused Mode ---\\n  {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    // Baseline glue-based restart\\n    if (fast >= limit)\\n      return true;\\n\\n    // Adaptive: If decision rate drops sharply, restart (simulate via moving average comparison)\\n    // Suppose previous decision_rate is approximated by slow (since we only have the EMA)\\n    // We cannot track previous EMA in this function, so rely on a sharp drop threshold\\n    // Heuristic: if decision rate < 70% of its EMA (shouldn't trigger normally unless stuck)\\n    const double rate = AVERAGE(decision_rate);\\n    if (rate > 0 && solver->mab && solver->mab_conflicts >= 100) {\\n      double actual = solver->mab_decisions / (double)solver->mab_conflicts;\\n      if (actual < 0.7 * rate)\\n        return true;\\n    }\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Stable mode ---\\n  if (solver->stable) {\\n    // Baseline reluctant restart: only if conflict threshold reached\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB stagnation: if MAB enabled and enough data collected\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // If recent progress is much less than expected, trigger early restart\\n      double recent_decisions = solver->mab_decisions;\\n      double expected_decisions = 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts;\\n      if (recent_decisions < expected_decisions)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode ---\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Baseline glue-based restart\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n  if (fast >= limit)\\n    return true;\\n\\n  // Decision rate drop (stagnation): restart if rate drops sharply\\n  // Use 0.7 * previous average as threshold (adaptive, only O(1) statistics available)\\n  // Note: In Kissat, AVERAGE(decision_rate) is EMA, so sharp drops persist for a few conflicts\\n  // For this trigger, check if we have sufficient conflicts to avoid noise\\n  if (CONFLICTS >= solver->limits.restart.conflicts + 50) {\\n    // Heuristic: if decision rate is less than 70% of its long-term average, restart\\n    // Since only one average is available, skip this unless further state is tracked\\n    // (If more state, could add: if (AVERAGE(decision_rate) < 0.7 * slow_decision_rate) return true;)\\n    // For now, skip this trigger; baseline and MAB triggers suffice\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 172.4409,
    "par2_rejected": 183.5986
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode ---\\n  if (solver->stable) {\\n    // Baseline: Reluctant restart after conflict interval\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB adaptive stagnation: If enabled, and enough conflicts, trigger if progress is low\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      const double avg_decisions_per_conflict = AVERAGE(decision_rate);\\n      // If actual per-conflict decisions is less than 80% of moving average, stagnation\\n      if (avg_decisions_per_conflict > 0) {\\n        double actual = solver->mab_decisions / (double)solver->mab_conflicts;\\n        if (actual < 0.8 * avg_decisions_per_conflict)\\n          return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused Mode ---\\n  {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    // Baseline glue-based restart\\n    if (fast >= limit)\\n      return true;\\n\\n    // Adaptive: If decision rate drops sharply, restart (simulate via moving average comparison)\\n    // Suppose previous decision_rate is approximated by slow (since we only have the EMA)\\n    // We cannot track previous EMA in this function, so rely on a sharp drop threshold\\n    // Heuristic: if decision rate < 70% of its EMA (shouldn't trigger normally unless stuck)\\n    const double rate = AVERAGE(decision_rate);\\n    if (rate > 0 && solver->mab && solver->mab_conflicts >= 100) {\\n      double actual = solver->mab_decisions / (double)solver->mab_conflicts;\\n      if (actual < 0.7 * rate)\\n        return true;\\n    }\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level, don't restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Reluctant: only allow normal restarts if conflict budget reached\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable mode (reluctant + MAB/decision stagnation) ---\\n  if (solver->stable) {\\n    // Baseline: reluctant restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-augmented early restart: check if progress is stagnating\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Compare actual decisions per conflict to recent average\\n      double recent_decision_rate = AVERAGE(decision_rate);\\n      double actual_decision_rate = 0.0;\\n      if (solver->mab_conflicts)\\n        actual_decision_rate = solver->mab_decisions / solver->mab_conflicts;\\n      // Trigger restart if progress is <80% of recent average\\n      if (actual_decision_rate < 0.8 * recent_decision_rate)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // --- Focused mode (glue margin + decision rate stagnation) ---\\n  {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    // Baseline: glue-based restart\\n    if (fast >= limit)\\n      return true;\\n\\n    // Adaptive: restart on decision rate drop (stagnation)\\n    // Heuristic: if current rate < 70% of moving average, restart\\n    // Previous rate (moving) is just AVERAGE(decision_rate)\\n    // But we have no way to store \\\"previous\\\" in a stateless function,\\n    // so this is just a duplicate of the above unless\\n    // the moving average is much higher than instantaneous.\\n    // We can estimate instantaneous by using recent window:\\n    // actual_decision_rate = (DECISIONS - solver->statistics.last_restart_decisions) / (CONFLICTS - solver->statistics.last_restart_conflicts)\\n    // But these are not available, so only moving average is available.\\n    // Instead, skip this adaptive focused check due to stateless constraint.\\n    // (If solver->mab is enabled, adaptive is handled above.)\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 172.4409,
    "par2_rejected": 183.68039999999996
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode ---\\n  if (solver->stable) {\\n    // Baseline: Reluctant restart after conflict interval\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB adaptive stagnation: If enabled, and enough conflicts, trigger if progress is low\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      const double avg_decisions_per_conflict = AVERAGE(decision_rate);\\n      // If actual per-conflict decisions is less than 80% of moving average, stagnation\\n      if (avg_decisions_per_conflict > 0) {\\n        double actual = solver->mab_decisions / (double)solver->mab_conflicts;\\n        if (actual < 0.8 * avg_decisions_per_conflict)\\n          return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused Mode ---\\n  {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    // Baseline glue-based restart\\n    if (fast >= limit)\\n      return true;\\n\\n    // Adaptive: If decision rate drops sharply, restart (simulate via moving average comparison)\\n    // Suppose previous decision_rate is approximated by slow (since we only have the EMA)\\n    // We cannot track previous EMA in this function, so rely on a sharp drop threshold\\n    // Heuristic: if decision rate < 70% of its EMA (shouldn't trigger normally unless stuck)\\n    const double rate = AVERAGE(decision_rate);\\n    if (rate > 0 && solver->mab && solver->mab_conflicts >= 100) {\\n      double actual = solver->mab_decisions / (double)solver->mab_conflicts;\\n      if (actual < 0.7 * rate)\\n        return true;\\n    }\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Stable mode ---\\n  if (solver->stable) {\\n    // Standard reluctant doubling trigger\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB stagnation trigger (if MAB enabled and enough data)\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Decision progress below 80% of recent average: trigger\\n      const double expected_decisions = AVERAGE(decision_rate) * solver->mab_conflicts;\\n      if (solver->mab_decisions < 0.8 * expected_decisions)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // --- Focused mode ---\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (fast >= limit)\\n    return true;\\n\\n  // Decision rate stagnation trigger: if the rate drops sharply, restart\\n  // We detect a significant drop by comparing the current average to a conservative ratio.\\n  // (No persistent variable, so use current vs. margin)\\n  // Here, we interpret \\\"previous\\\" average as the baseline (margin * decision_rate).\\n  const double decision_rate = AVERAGE(decision_rate);\\n  if (decision_rate < 0.7 * margin * decision_rate)\\n    return true;\\n\\n  return false;\\n}\\n",
    "par2_preferred": 172.4409,
    "par2_rejected": 183.9695
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode ---\\n  if (solver->stable) {\\n    // Baseline: Reluctant restart after conflict interval\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB adaptive stagnation: If enabled, and enough conflicts, trigger if progress is low\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      const double avg_decisions_per_conflict = AVERAGE(decision_rate);\\n      // If actual per-conflict decisions is less than 80% of moving average, stagnation\\n      if (avg_decisions_per_conflict > 0) {\\n        double actual = solver->mab_decisions / (double)solver->mab_conflicts;\\n        if (actual < 0.8 * avg_decisions_per_conflict)\\n          return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused Mode ---\\n  {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    // Baseline glue-based restart\\n    if (fast >= limit)\\n      return true;\\n\\n    // Adaptive: If decision rate drops sharply, restart (simulate via moving average comparison)\\n    // Suppose previous decision_rate is approximated by slow (since we only have the EMA)\\n    // We cannot track previous EMA in this function, so rely on a sharp drop threshold\\n    // Heuristic: if decision rate < 70% of its EMA (shouldn't trigger normally unless stuck)\\n    const double rate = AVERAGE(decision_rate);\\n    if (rate > 0 && solver->mab && solver->mab_conflicts >= 100) {\\n      double actual = solver->mab_decisions / (double)solver->mab_conflicts;\\n      if (actual < 0.7 * rate)\\n        return true;\\n    }\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards: restarts enabled, not at root level, enough conflicts\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Stable mode ---\\n  if (solver->stable) {\\n    // Baseline: reluctant (Luby) trigger, subject to conflict threshold\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB adaptive: if enabled, stagnation detection via decision rate\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Decision rate since last restart\\n      const double recent_dec_rate = \\n        solver->mab_conflicts ? (solver->mab_decisions / solver->mab_conflicts) : 0.0;\\n      // If recent rate < 80% of historic average, trigger restart\\n      if (recent_dec_rate < 0.8 * AVERAGE(decision_rate))\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode ---\\n  // Baseline: glue margin\\n  if (CONFLICTS >= solver->limits.restart.conflicts) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    if (fast >= margin * slow)\\n      return true;\\n  }\\n\\n  // Adaptive: sharp drop in decision rate\\n  // If recent decision rate < 70% of historic average, trigger restart\\n  if (solver->mab_conflicts >= 50) { // use same window for recent rate\\n    const double recent_dec_rate =\\n      solver->mab_conflicts ? (solver->mab_decisions / solver->mab_conflicts) : 0.0;\\n    if (recent_dec_rate < 0.7 * AVERAGE(decision_rate))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 172.4409,
    "par2_rejected": 294.0353
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode ---\\n  if (solver->stable) {\\n    // Baseline: Reluctant restart after conflict interval\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB adaptive stagnation: If enabled, and enough conflicts, trigger if progress is low\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      const double avg_decisions_per_conflict = AVERAGE(decision_rate);\\n      // If actual per-conflict decisions is less than 80% of moving average, stagnation\\n      if (avg_decisions_per_conflict > 0) {\\n        double actual = solver->mab_decisions / (double)solver->mab_conflicts;\\n        if (actual < 0.8 * avg_decisions_per_conflict)\\n          return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused Mode ---\\n  {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    // Baseline glue-based restart\\n    if (fast >= limit)\\n      return true;\\n\\n    // Adaptive: If decision rate drops sharply, restart (simulate via moving average comparison)\\n    // Suppose previous decision_rate is approximated by slow (since we only have the EMA)\\n    // We cannot track previous EMA in this function, so rely on a sharp drop threshold\\n    // Heuristic: if decision rate < 70% of its EMA (shouldn't trigger normally unless stuck)\\n    const double rate = AVERAGE(decision_rate);\\n    if (rate > 0 && solver->mab && solver->mab_conflicts >= 100) {\\n      double actual = solver->mab_decisions / (double)solver->mab_conflicts;\\n      if (actual < 0.7 * rate)\\n        return true;\\n    }\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level (no decisions to undo)\\n  if (!solver->level)\\n    return false;\\n\\n  // Stable mode (stable = true)\\n  if (solver->stable) {\\n    // Standard reluctant-based restart if enough conflicts reached\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive: if enabled, and enough conflicts since last restart\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // If progress (decisions per conflict) is < 80% of typical (EMA)\\n      double expected_decisions = AVERAGE(decision_rate) * solver->mab_conflicts;\\n      if (solver->mab_decisions < 0.8 * expected_decisions)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // Focused mode (stable = false)\\n  // Baseline: glue-based restart\\n  if (CONFLICTS >= solver->limits.restart.conflicts) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n  }\\n\\n  // Adaptive: restart if decision rate drops sharply (stagnation)\\n  // (EMA: AVERAGE(decision_rate) is maintained by solver; compare last window to EMA)\\n  // If current decision rate < 70% of EMA, trigger restart\\n  // (Since we can't get the \\\\\\\"previous\\\\\\\" average directly, we use that the EMA is the baseline)\\n  if (AVERAGE(decision_rate) > 0) {\\n    double actual_rate = solver->mab_conflicts ? \\n      (solver->mab_decisions / solver->mab_conflicts) : 0.0;\\n    if (solver->mab_conflicts >= 50 && actual_rate < 0.7 * AVERAGE(decision_rate))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 172.4409,
    "par2_rejected": 294.0389
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode ---\\n  if (solver->stable) {\\n    // Baseline: Reluctant restart after conflict interval\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB adaptive stagnation: If enabled, and enough conflicts, trigger if progress is low\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      const double avg_decisions_per_conflict = AVERAGE(decision_rate);\\n      // If actual per-conflict decisions is less than 80% of moving average, stagnation\\n      if (avg_decisions_per_conflict > 0) {\\n        double actual = solver->mab_decisions / (double)solver->mab_conflicts;\\n        if (actual < 0.8 * avg_decisions_per_conflict)\\n          return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused Mode ---\\n  {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    // Baseline glue-based restart\\n    if (fast >= limit)\\n      return true;\\n\\n    // Adaptive: If decision rate drops sharply, restart (simulate via moving average comparison)\\n    // Suppose previous decision_rate is approximated by slow (since we only have the EMA)\\n    // We cannot track previous EMA in this function, so rely on a sharp drop threshold\\n    // Heuristic: if decision rate < 70% of its EMA (shouldn't trigger normally unless stuck)\\n    const double rate = AVERAGE(decision_rate);\\n    if (rate > 0 && solver->mab && solver->mab_conflicts >= 100) {\\n      double actual = solver->mab_decisions / (double)solver->mab_conflicts;\\n      if (actual < 0.7 * rate)\\n        return true;\\n    }\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Stable mode: Reluctant + adaptive MAB stagnation ---\\n  if (solver->stable) {\\n    // Main reluctant trigger\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // Adaptive stagnation: if MAB is enabled and we have enough data\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Compare actual decisions per conflict since last restart to historical EMA\\n      const double recent_decisions_per_conflict =\\n        solver->mab_decisions / ((double) solver->mab_conflicts);\\n      const double avg_decision_rate = AVERAGE(decision_rate);\\n      // If current rate is less than 80% of the moving average, consider restarting\\n      if (recent_decisions_per_conflict < 0.8 * avg_decision_rate)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode: Glue-based + adaptive decision rate drop ---\\n  if (CONFLICTS >= solver->limits.restart.conflicts) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n  }\\n\\n  // Adaptive: restart if decision rate drops sharply (stagnation)\\n  // (last restart's decision rate is implicitly captured by EMA)\\n  {\\n    const double current_decision_rate = AVERAGE(decision_rate);\\n    // Previous EMA not tracked directly, but drop detected if EMA falls\\n    // sharply below the last restart's typical EMA. We use 0.7 factor.\\n    // Since we can't access the previous EMA directly, this check is conservative.\\n\\n    // For this adaptive trigger, only fire if decision rate is \\\"very low\\\"\\n    if (current_decision_rate < 0.01) // Avoid noise for tiny rates\\n      return true;\\n    // (Note: If you had previous_decision_rate, you'd check: current < 0.7 * previous)\\n    // Here, EMA is slow to drop, so a sharp drop will result in a low EMA value.\\n    // If the rate is extremely low, we restart.\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 172.4409,
    "par2_rejected": 297.4767
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n\\n  // --- Stable mode: Reluctant + MAB stagnation detection ---\\n  if (solver->stable) {\\n    // Primary: Reluctant restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // Secondary: MAB-enabled stagnation (only if enough data)\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Use decision rate stagnation: too few decisions/conflict\\n      const double avg_dec_rate = AVERAGE(decision_rate);\\n      // Avoid division by zero\\n      if (avg_dec_rate > 0.0) {\\n        const double expected_decisions =\\n          avg_dec_rate * (double)solver->mab_conflicts;\\n        if (solver->mab_decisions < 0.8 * expected_decisions)\\n          return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode: Glue-based + decision rate stagnation ---\\n  // Glue-based (classic)\\n  if (fast >= glue_limit)\\n    return true;\\n\\n  // Decision rate drop: restart if decision rate has dropped sharply\\n  // (simulate EMA drop by comparing current to recent average)\\n  // If average drops below 70% of long-term average, restart.\\n  // Since we only have current average, no per-phase memory, this check is conservative.\\n  const double avg_dec_rate = AVERAGE(decision_rate);\\n  // Using hard minimum to avoid noise for very small rates\\n  if (avg_dec_rate > 0.0) {\\n    // Check if decisions per conflict is very low (stagnation)\\n    // Use the same threshold as above for consistency\\n    const double expected_decisions =\\n      avg_dec_rate * (double)solver->mab_conflicts;\\n    if (solver->mab_conflicts >= 100 && solver->mab_decisions < 0.7 * expected_decisions)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard checks\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode ---\\n  if (solver->stable) {\\n    // 1. Baseline: Reluctant (Luby) trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // 2. MAB stagnation: If enabled and enough data, trigger if decisions are much lower than recent typical\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      double recent_decision_rate = AVERAGE(decision_rate);\\n      double expected_decisions = recent_decision_rate * solver->mab_conflicts;\\n      if (solver->mab_decisions < 0.8 * expected_decisions)\\n        return true;\\n    }\\n\\n    // Otherwise, don't restart\\n    return false;\\n  }\\n\\n  // --- Focused Mode ---\\n  {\\n    // 1. Baseline: Glue-based trigger with margin\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // 2. Decision rate stagnation: If rate drops sharply, trigger early restart\\n    // Compare current decision rate to the EMA (already tracked by framework)\\n    // We use a 0.7 threshold for sharp drop\\n    // (If decision rate is less than 70% of EMA, trigger)\\n    const double curr_rate = AVERAGE(decision_rate);\\n    // For lack of \\\\\\\"previous\\\\\\\" EMA, in Kissat the .value is the EMA, so compare to itself in last window,\\n    // but here we simply use the current EMA, and if it is extremely low, trigger\\n    // This will only trigger if the decision rate has dropped much below its historic EMA\\n    // In practice, this condition will rarely fire, but is safe for adaptive restarts\\n\\n    // (Extra: could expose previous EMA, but not available in existing interface)\\n    if (curr_rate < 0.05) // Empirically, tiny rates indicate solver got stuck\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 175.11610000000002,
    "par2_rejected": 183.52290000000002
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n\\n  // --- Stable mode: Reluctant + MAB stagnation detection ---\\n  if (solver->stable) {\\n    // Primary: Reluctant restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // Secondary: MAB-enabled stagnation (only if enough data)\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Use decision rate stagnation: too few decisions/conflict\\n      const double avg_dec_rate = AVERAGE(decision_rate);\\n      // Avoid division by zero\\n      if (avg_dec_rate > 0.0) {\\n        const double expected_decisions =\\n          avg_dec_rate * (double)solver->mab_conflicts;\\n        if (solver->mab_decisions < 0.8 * expected_decisions)\\n          return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode: Glue-based + decision rate stagnation ---\\n  // Glue-based (classic)\\n  if (fast >= glue_limit)\\n    return true;\\n\\n  // Decision rate drop: restart if decision rate has dropped sharply\\n  // (simulate EMA drop by comparing current to recent average)\\n  // If average drops below 70% of long-term average, restart.\\n  // Since we only have current average, no per-phase memory, this check is conservative.\\n  const double avg_dec_rate = AVERAGE(decision_rate);\\n  // Using hard minimum to avoid noise for very small rates\\n  if (avg_dec_rate > 0.0) {\\n    // Check if decisions per conflict is very low (stagnation)\\n    // Use the same threshold as above for consistency\\n    const double expected_decisions =\\n      avg_dec_rate * (double)solver->mab_conflicts;\\n    if (solver->mab_conflicts >= 100 && solver->mab_decisions < 0.7 * expected_decisions)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Stable mode ---\\n  if (solver->stable) {\\n    // Baseline reluctant restart: only if conflict threshold reached\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB stagnation: if MAB enabled and enough data collected\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // If recent progress is much less than expected, trigger early restart\\n      double recent_decisions = solver->mab_decisions;\\n      double expected_decisions = 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts;\\n      if (recent_decisions < expected_decisions)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode ---\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Baseline glue-based restart\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n  if (fast >= limit)\\n    return true;\\n\\n  // Decision rate drop (stagnation): restart if rate drops sharply\\n  // Use 0.7 * previous average as threshold (adaptive, only O(1) statistics available)\\n  // Note: In Kissat, AVERAGE(decision_rate) is EMA, so sharp drops persist for a few conflicts\\n  // For this trigger, check if we have sufficient conflicts to avoid noise\\n  if (CONFLICTS >= solver->limits.restart.conflicts + 50) {\\n    // Heuristic: if decision rate is less than 70% of its long-term average, restart\\n    // Since only one average is available, skip this unless further state is tracked\\n    // (If more state, could add: if (AVERAGE(decision_rate) < 0.7 * slow_decision_rate) return true;)\\n    // For now, skip this trigger; baseline and MAB triggers suffice\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 175.11610000000002,
    "par2_rejected": 183.5986
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n\\n  // --- Stable mode: Reluctant + MAB stagnation detection ---\\n  if (solver->stable) {\\n    // Primary: Reluctant restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // Secondary: MAB-enabled stagnation (only if enough data)\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Use decision rate stagnation: too few decisions/conflict\\n      const double avg_dec_rate = AVERAGE(decision_rate);\\n      // Avoid division by zero\\n      if (avg_dec_rate > 0.0) {\\n        const double expected_decisions =\\n          avg_dec_rate * (double)solver->mab_conflicts;\\n        if (solver->mab_decisions < 0.8 * expected_decisions)\\n          return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode: Glue-based + decision rate stagnation ---\\n  // Glue-based (classic)\\n  if (fast >= glue_limit)\\n    return true;\\n\\n  // Decision rate drop: restart if decision rate has dropped sharply\\n  // (simulate EMA drop by comparing current to recent average)\\n  // If average drops below 70% of long-term average, restart.\\n  // Since we only have current average, no per-phase memory, this check is conservative.\\n  const double avg_dec_rate = AVERAGE(decision_rate);\\n  // Using hard minimum to avoid noise for very small rates\\n  if (avg_dec_rate > 0.0) {\\n    // Check if decisions per conflict is very low (stagnation)\\n    // Use the same threshold as above for consistency\\n    const double expected_decisions =\\n      avg_dec_rate * (double)solver->mab_conflicts;\\n    if (solver->mab_conflicts >= 100 && solver->mab_decisions < 0.7 * expected_decisions)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level, don't restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Reluctant: only allow normal restarts if conflict budget reached\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable mode (reluctant + MAB/decision stagnation) ---\\n  if (solver->stable) {\\n    // Baseline: reluctant restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-augmented early restart: check if progress is stagnating\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Compare actual decisions per conflict to recent average\\n      double recent_decision_rate = AVERAGE(decision_rate);\\n      double actual_decision_rate = 0.0;\\n      if (solver->mab_conflicts)\\n        actual_decision_rate = solver->mab_decisions / solver->mab_conflicts;\\n      // Trigger restart if progress is <80% of recent average\\n      if (actual_decision_rate < 0.8 * recent_decision_rate)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // --- Focused mode (glue margin + decision rate stagnation) ---\\n  {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    // Baseline: glue-based restart\\n    if (fast >= limit)\\n      return true;\\n\\n    // Adaptive: restart on decision rate drop (stagnation)\\n    // Heuristic: if current rate < 70% of moving average, restart\\n    // Previous rate (moving) is just AVERAGE(decision_rate)\\n    // But we have no way to store \\\"previous\\\" in a stateless function,\\n    // so this is just a duplicate of the above unless\\n    // the moving average is much higher than instantaneous.\\n    // We can estimate instantaneous by using recent window:\\n    // actual_decision_rate = (DECISIONS - solver->statistics.last_restart_decisions) / (CONFLICTS - solver->statistics.last_restart_conflicts)\\n    // But these are not available, so only moving average is available.\\n    // Instead, skip this adaptive focused check due to stateless constraint.\\n    // (If solver->mab is enabled, adaptive is handled above.)\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 175.11610000000002,
    "par2_rejected": 183.68039999999996
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n\\n  // --- Stable mode: Reluctant + MAB stagnation detection ---\\n  if (solver->stable) {\\n    // Primary: Reluctant restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // Secondary: MAB-enabled stagnation (only if enough data)\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Use decision rate stagnation: too few decisions/conflict\\n      const double avg_dec_rate = AVERAGE(decision_rate);\\n      // Avoid division by zero\\n      if (avg_dec_rate > 0.0) {\\n        const double expected_decisions =\\n          avg_dec_rate * (double)solver->mab_conflicts;\\n        if (solver->mab_decisions < 0.8 * expected_decisions)\\n          return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode: Glue-based + decision rate stagnation ---\\n  // Glue-based (classic)\\n  if (fast >= glue_limit)\\n    return true;\\n\\n  // Decision rate drop: restart if decision rate has dropped sharply\\n  // (simulate EMA drop by comparing current to recent average)\\n  // If average drops below 70% of long-term average, restart.\\n  // Since we only have current average, no per-phase memory, this check is conservative.\\n  const double avg_dec_rate = AVERAGE(decision_rate);\\n  // Using hard minimum to avoid noise for very small rates\\n  if (avg_dec_rate > 0.0) {\\n    // Check if decisions per conflict is very low (stagnation)\\n    // Use the same threshold as above for consistency\\n    const double expected_decisions =\\n      avg_dec_rate * (double)solver->mab_conflicts;\\n    if (solver->mab_conflicts >= 100 && solver->mab_decisions < 0.7 * expected_decisions)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Stable mode ---\\n  if (solver->stable) {\\n    // Standard reluctant doubling trigger\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB stagnation trigger (if MAB enabled and enough data)\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Decision progress below 80% of recent average: trigger\\n      const double expected_decisions = AVERAGE(decision_rate) * solver->mab_conflicts;\\n      if (solver->mab_decisions < 0.8 * expected_decisions)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // --- Focused mode ---\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (fast >= limit)\\n    return true;\\n\\n  // Decision rate stagnation trigger: if the rate drops sharply, restart\\n  // We detect a significant drop by comparing the current average to a conservative ratio.\\n  // (No persistent variable, so use current vs. margin)\\n  // Here, we interpret \\\"previous\\\" average as the baseline (margin * decision_rate).\\n  const double decision_rate = AVERAGE(decision_rate);\\n  if (decision_rate < 0.7 * margin * decision_rate)\\n    return true;\\n\\n  return false;\\n}\\n",
    "par2_preferred": 175.11610000000002,
    "par2_rejected": 183.9695
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n\\n  // --- Stable mode: Reluctant + MAB stagnation detection ---\\n  if (solver->stable) {\\n    // Primary: Reluctant restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // Secondary: MAB-enabled stagnation (only if enough data)\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Use decision rate stagnation: too few decisions/conflict\\n      const double avg_dec_rate = AVERAGE(decision_rate);\\n      // Avoid division by zero\\n      if (avg_dec_rate > 0.0) {\\n        const double expected_decisions =\\n          avg_dec_rate * (double)solver->mab_conflicts;\\n        if (solver->mab_decisions < 0.8 * expected_decisions)\\n          return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode: Glue-based + decision rate stagnation ---\\n  // Glue-based (classic)\\n  if (fast >= glue_limit)\\n    return true;\\n\\n  // Decision rate drop: restart if decision rate has dropped sharply\\n  // (simulate EMA drop by comparing current to recent average)\\n  // If average drops below 70% of long-term average, restart.\\n  // Since we only have current average, no per-phase memory, this check is conservative.\\n  const double avg_dec_rate = AVERAGE(decision_rate);\\n  // Using hard minimum to avoid noise for very small rates\\n  if (avg_dec_rate > 0.0) {\\n    // Check if decisions per conflict is very low (stagnation)\\n    // Use the same threshold as above for consistency\\n    const double expected_decisions =\\n      avg_dec_rate * (double)solver->mab_conflicts;\\n    if (solver->mab_conflicts >= 100 && solver->mab_decisions < 0.7 * expected_decisions)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards: restarts enabled, not at root level, enough conflicts\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Stable mode ---\\n  if (solver->stable) {\\n    // Baseline: reluctant (Luby) trigger, subject to conflict threshold\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB adaptive: if enabled, stagnation detection via decision rate\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Decision rate since last restart\\n      const double recent_dec_rate = \\n        solver->mab_conflicts ? (solver->mab_decisions / solver->mab_conflicts) : 0.0;\\n      // If recent rate < 80% of historic average, trigger restart\\n      if (recent_dec_rate < 0.8 * AVERAGE(decision_rate))\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode ---\\n  // Baseline: glue margin\\n  if (CONFLICTS >= solver->limits.restart.conflicts) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    if (fast >= margin * slow)\\n      return true;\\n  }\\n\\n  // Adaptive: sharp drop in decision rate\\n  // If recent decision rate < 70% of historic average, trigger restart\\n  if (solver->mab_conflicts >= 50) { // use same window for recent rate\\n    const double recent_dec_rate =\\n      solver->mab_conflicts ? (solver->mab_decisions / solver->mab_conflicts) : 0.0;\\n    if (recent_dec_rate < 0.7 * AVERAGE(decision_rate))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 175.11610000000002,
    "par2_rejected": 294.0353
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n\\n  // --- Stable mode: Reluctant + MAB stagnation detection ---\\n  if (solver->stable) {\\n    // Primary: Reluctant restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // Secondary: MAB-enabled stagnation (only if enough data)\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Use decision rate stagnation: too few decisions/conflict\\n      const double avg_dec_rate = AVERAGE(decision_rate);\\n      // Avoid division by zero\\n      if (avg_dec_rate > 0.0) {\\n        const double expected_decisions =\\n          avg_dec_rate * (double)solver->mab_conflicts;\\n        if (solver->mab_decisions < 0.8 * expected_decisions)\\n          return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode: Glue-based + decision rate stagnation ---\\n  // Glue-based (classic)\\n  if (fast >= glue_limit)\\n    return true;\\n\\n  // Decision rate drop: restart if decision rate has dropped sharply\\n  // (simulate EMA drop by comparing current to recent average)\\n  // If average drops below 70% of long-term average, restart.\\n  // Since we only have current average, no per-phase memory, this check is conservative.\\n  const double avg_dec_rate = AVERAGE(decision_rate);\\n  // Using hard minimum to avoid noise for very small rates\\n  if (avg_dec_rate > 0.0) {\\n    // Check if decisions per conflict is very low (stagnation)\\n    // Use the same threshold as above for consistency\\n    const double expected_decisions =\\n      avg_dec_rate * (double)solver->mab_conflicts;\\n    if (solver->mab_conflicts >= 100 && solver->mab_decisions < 0.7 * expected_decisions)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level (no decisions to undo)\\n  if (!solver->level)\\n    return false;\\n\\n  // Stable mode (stable = true)\\n  if (solver->stable) {\\n    // Standard reluctant-based restart if enough conflicts reached\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive: if enabled, and enough conflicts since last restart\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // If progress (decisions per conflict) is < 80% of typical (EMA)\\n      double expected_decisions = AVERAGE(decision_rate) * solver->mab_conflicts;\\n      if (solver->mab_decisions < 0.8 * expected_decisions)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // Focused mode (stable = false)\\n  // Baseline: glue-based restart\\n  if (CONFLICTS >= solver->limits.restart.conflicts) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n  }\\n\\n  // Adaptive: restart if decision rate drops sharply (stagnation)\\n  // (EMA: AVERAGE(decision_rate) is maintained by solver; compare last window to EMA)\\n  // If current decision rate < 70% of EMA, trigger restart\\n  // (Since we can't get the \\\\\\\"previous\\\\\\\" average directly, we use that the EMA is the baseline)\\n  if (AVERAGE(decision_rate) > 0) {\\n    double actual_rate = solver->mab_conflicts ? \\n      (solver->mab_decisions / solver->mab_conflicts) : 0.0;\\n    if (solver->mab_conflicts >= 50 && actual_rate < 0.7 * AVERAGE(decision_rate))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 175.11610000000002,
    "par2_rejected": 294.0389
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n\\n  // --- Stable mode: Reluctant + MAB stagnation detection ---\\n  if (solver->stable) {\\n    // Primary: Reluctant restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // Secondary: MAB-enabled stagnation (only if enough data)\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Use decision rate stagnation: too few decisions/conflict\\n      const double avg_dec_rate = AVERAGE(decision_rate);\\n      // Avoid division by zero\\n      if (avg_dec_rate > 0.0) {\\n        const double expected_decisions =\\n          avg_dec_rate * (double)solver->mab_conflicts;\\n        if (solver->mab_decisions < 0.8 * expected_decisions)\\n          return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode: Glue-based + decision rate stagnation ---\\n  // Glue-based (classic)\\n  if (fast >= glue_limit)\\n    return true;\\n\\n  // Decision rate drop: restart if decision rate has dropped sharply\\n  // (simulate EMA drop by comparing current to recent average)\\n  // If average drops below 70% of long-term average, restart.\\n  // Since we only have current average, no per-phase memory, this check is conservative.\\n  const double avg_dec_rate = AVERAGE(decision_rate);\\n  // Using hard minimum to avoid noise for very small rates\\n  if (avg_dec_rate > 0.0) {\\n    // Check if decisions per conflict is very low (stagnation)\\n    // Use the same threshold as above for consistency\\n    const double expected_decisions =\\n      avg_dec_rate * (double)solver->mab_conflicts;\\n    if (solver->mab_conflicts >= 100 && solver->mab_decisions < 0.7 * expected_decisions)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Stable mode: Reluctant + adaptive MAB stagnation ---\\n  if (solver->stable) {\\n    // Main reluctant trigger\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // Adaptive stagnation: if MAB is enabled and we have enough data\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Compare actual decisions per conflict since last restart to historical EMA\\n      const double recent_decisions_per_conflict =\\n        solver->mab_decisions / ((double) solver->mab_conflicts);\\n      const double avg_decision_rate = AVERAGE(decision_rate);\\n      // If current rate is less than 80% of the moving average, consider restarting\\n      if (recent_decisions_per_conflict < 0.8 * avg_decision_rate)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode: Glue-based + adaptive decision rate drop ---\\n  if (CONFLICTS >= solver->limits.restart.conflicts) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n  }\\n\\n  // Adaptive: restart if decision rate drops sharply (stagnation)\\n  // (last restart's decision rate is implicitly captured by EMA)\\n  {\\n    const double current_decision_rate = AVERAGE(decision_rate);\\n    // Previous EMA not tracked directly, but drop detected if EMA falls\\n    // sharply below the last restart's typical EMA. We use 0.7 factor.\\n    // Since we can't access the previous EMA directly, this check is conservative.\\n\\n    // For this adaptive trigger, only fire if decision rate is \\\"very low\\\"\\n    if (current_decision_rate < 0.01) // Avoid noise for tiny rates\\n      return true;\\n    // (Note: If you had previous_decision_rate, you'd check: current < 0.7 * previous)\\n    // Here, EMA is slow to drop, so a sharp drop will result in a low EMA value.\\n    // If the rate is extremely low, we restart.\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 175.11610000000002,
    "par2_rejected": 297.4767
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts globally disabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level, don't restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not enough conflicts for the next regular restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // ----- STABLE MODE -----\\n  if (solver->stable) {\\n    // Standard reluctant doubling trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB stagnation early restart: only if MAB is enabled and enough data\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Compute expected decisions at avg decision rate\\n      double avg_decision_rate = AVERAGE(decision_rate);\\n      double expected_decisions = avg_decision_rate * solver->mab_conflicts;\\n      // If actual decisions is much less than expected, we're stagnating\\n      if (solver->mab_decisions < 0.8 * expected_decisions)\\n        return true;\\n    }\\n\\n    // Otherwise, no restart in stable mode\\n    return false;\\n  }\\n\\n  // ----- FOCUSED MODE -----\\n  // Standard focused glue-based restart\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n  if (fast >= glue_limit)\\n    return true;\\n\\n  // Adaptive stagnation: decision rate drop (compared to slow glue baseline)\\n  // We can't track \\\\\\\"previous\\\\\\\" decision rate in this function, but we can compare\\n  // to the long-term AVERAGE(decision_rate) (which is itself a slow EMA).\\n  // If the current decision rate has dropped below 70% of the slow baseline, restart.\\n  // (In Kissat, AVERAGE(decision_rate) is slow EMA, so just use current vs. that.)\\n  // Since we only have one AVERAGE(decision_rate), we use it as baseline.\\n  // This trigger is conservative but safe.\\n  // (If you want more aggressive, lower the factor.)\\n  if (solver->mab && solver->mab_conflicts >= 100) {\\n    double avg_decision_rate = AVERAGE(decision_rate);\\n    // Compute current observed decision rate in this phase\\n    if (solver->mab_conflicts > 0) {\\n      double current_decision_rate = solver->mab_decisions / solver->mab_conflicts;\\n      if (current_decision_rate < 0.7 * avg_decision_rate)\\n        return true;\\n    }\\n  }\\n\\n  // No restart in focused mode\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard checks\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode ---\\n  if (solver->stable) {\\n    // 1. Baseline: Reluctant (Luby) trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // 2. MAB stagnation: If enabled and enough data, trigger if decisions are much lower than recent typical\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      double recent_decision_rate = AVERAGE(decision_rate);\\n      double expected_decisions = recent_decision_rate * solver->mab_conflicts;\\n      if (solver->mab_decisions < 0.8 * expected_decisions)\\n        return true;\\n    }\\n\\n    // Otherwise, don't restart\\n    return false;\\n  }\\n\\n  // --- Focused Mode ---\\n  {\\n    // 1. Baseline: Glue-based trigger with margin\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // 2. Decision rate stagnation: If rate drops sharply, trigger early restart\\n    // Compare current decision rate to the EMA (already tracked by framework)\\n    // We use a 0.7 threshold for sharp drop\\n    // (If decision rate is less than 70% of EMA, trigger)\\n    const double curr_rate = AVERAGE(decision_rate);\\n    // For lack of \\\\\\\"previous\\\\\\\" EMA, in Kissat the .value is the EMA, so compare to itself in last window,\\n    // but here we simply use the current EMA, and if it is extremely low, trigger\\n    // This will only trigger if the decision rate has dropped much below its historic EMA\\n    // In practice, this condition will rarely fire, but is safe for adaptive restarts\\n\\n    // (Extra: could expose previous EMA, but not available in existing interface)\\n    if (curr_rate < 0.05) // Empirically, tiny rates indicate solver got stuck\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 175.13830000000002,
    "par2_rejected": 183.52290000000002
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts globally disabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level, don't restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not enough conflicts for the next regular restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // ----- STABLE MODE -----\\n  if (solver->stable) {\\n    // Standard reluctant doubling trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB stagnation early restart: only if MAB is enabled and enough data\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Compute expected decisions at avg decision rate\\n      double avg_decision_rate = AVERAGE(decision_rate);\\n      double expected_decisions = avg_decision_rate * solver->mab_conflicts;\\n      // If actual decisions is much less than expected, we're stagnating\\n      if (solver->mab_decisions < 0.8 * expected_decisions)\\n        return true;\\n    }\\n\\n    // Otherwise, no restart in stable mode\\n    return false;\\n  }\\n\\n  // ----- FOCUSED MODE -----\\n  // Standard focused glue-based restart\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n  if (fast >= glue_limit)\\n    return true;\\n\\n  // Adaptive stagnation: decision rate drop (compared to slow glue baseline)\\n  // We can't track \\\\\\\"previous\\\\\\\" decision rate in this function, but we can compare\\n  // to the long-term AVERAGE(decision_rate) (which is itself a slow EMA).\\n  // If the current decision rate has dropped below 70% of the slow baseline, restart.\\n  // (In Kissat, AVERAGE(decision_rate) is slow EMA, so just use current vs. that.)\\n  // Since we only have one AVERAGE(decision_rate), we use it as baseline.\\n  // This trigger is conservative but safe.\\n  // (If you want more aggressive, lower the factor.)\\n  if (solver->mab && solver->mab_conflicts >= 100) {\\n    double avg_decision_rate = AVERAGE(decision_rate);\\n    // Compute current observed decision rate in this phase\\n    if (solver->mab_conflicts > 0) {\\n      double current_decision_rate = solver->mab_decisions / solver->mab_conflicts;\\n      if (current_decision_rate < 0.7 * avg_decision_rate)\\n        return true;\\n    }\\n  }\\n\\n  // No restart in focused mode\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Stable mode ---\\n  if (solver->stable) {\\n    // Baseline reluctant restart: only if conflict threshold reached\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB stagnation: if MAB enabled and enough data collected\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // If recent progress is much less than expected, trigger early restart\\n      double recent_decisions = solver->mab_decisions;\\n      double expected_decisions = 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts;\\n      if (recent_decisions < expected_decisions)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode ---\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Baseline glue-based restart\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n  if (fast >= limit)\\n    return true;\\n\\n  // Decision rate drop (stagnation): restart if rate drops sharply\\n  // Use 0.7 * previous average as threshold (adaptive, only O(1) statistics available)\\n  // Note: In Kissat, AVERAGE(decision_rate) is EMA, so sharp drops persist for a few conflicts\\n  // For this trigger, check if we have sufficient conflicts to avoid noise\\n  if (CONFLICTS >= solver->limits.restart.conflicts + 50) {\\n    // Heuristic: if decision rate is less than 70% of its long-term average, restart\\n    // Since only one average is available, skip this unless further state is tracked\\n    // (If more state, could add: if (AVERAGE(decision_rate) < 0.7 * slow_decision_rate) return true;)\\n    // For now, skip this trigger; baseline and MAB triggers suffice\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 175.13830000000002,
    "par2_rejected": 183.5986
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts globally disabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level, don't restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not enough conflicts for the next regular restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // ----- STABLE MODE -----\\n  if (solver->stable) {\\n    // Standard reluctant doubling trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB stagnation early restart: only if MAB is enabled and enough data\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Compute expected decisions at avg decision rate\\n      double avg_decision_rate = AVERAGE(decision_rate);\\n      double expected_decisions = avg_decision_rate * solver->mab_conflicts;\\n      // If actual decisions is much less than expected, we're stagnating\\n      if (solver->mab_decisions < 0.8 * expected_decisions)\\n        return true;\\n    }\\n\\n    // Otherwise, no restart in stable mode\\n    return false;\\n  }\\n\\n  // ----- FOCUSED MODE -----\\n  // Standard focused glue-based restart\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n  if (fast >= glue_limit)\\n    return true;\\n\\n  // Adaptive stagnation: decision rate drop (compared to slow glue baseline)\\n  // We can't track \\\\\\\"previous\\\\\\\" decision rate in this function, but we can compare\\n  // to the long-term AVERAGE(decision_rate) (which is itself a slow EMA).\\n  // If the current decision rate has dropped below 70% of the slow baseline, restart.\\n  // (In Kissat, AVERAGE(decision_rate) is slow EMA, so just use current vs. that.)\\n  // Since we only have one AVERAGE(decision_rate), we use it as baseline.\\n  // This trigger is conservative but safe.\\n  // (If you want more aggressive, lower the factor.)\\n  if (solver->mab && solver->mab_conflicts >= 100) {\\n    double avg_decision_rate = AVERAGE(decision_rate);\\n    // Compute current observed decision rate in this phase\\n    if (solver->mab_conflicts > 0) {\\n      double current_decision_rate = solver->mab_decisions / solver->mab_conflicts;\\n      if (current_decision_rate < 0.7 * avg_decision_rate)\\n        return true;\\n    }\\n  }\\n\\n  // No restart in focused mode\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level, don't restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Reluctant: only allow normal restarts if conflict budget reached\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable mode (reluctant + MAB/decision stagnation) ---\\n  if (solver->stable) {\\n    // Baseline: reluctant restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-augmented early restart: check if progress is stagnating\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Compare actual decisions per conflict to recent average\\n      double recent_decision_rate = AVERAGE(decision_rate);\\n      double actual_decision_rate = 0.0;\\n      if (solver->mab_conflicts)\\n        actual_decision_rate = solver->mab_decisions / solver->mab_conflicts;\\n      // Trigger restart if progress is <80% of recent average\\n      if (actual_decision_rate < 0.8 * recent_decision_rate)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // --- Focused mode (glue margin + decision rate stagnation) ---\\n  {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    // Baseline: glue-based restart\\n    if (fast >= limit)\\n      return true;\\n\\n    // Adaptive: restart on decision rate drop (stagnation)\\n    // Heuristic: if current rate < 70% of moving average, restart\\n    // Previous rate (moving) is just AVERAGE(decision_rate)\\n    // But we have no way to store \\\"previous\\\" in a stateless function,\\n    // so this is just a duplicate of the above unless\\n    // the moving average is much higher than instantaneous.\\n    // We can estimate instantaneous by using recent window:\\n    // actual_decision_rate = (DECISIONS - solver->statistics.last_restart_decisions) / (CONFLICTS - solver->statistics.last_restart_conflicts)\\n    // But these are not available, so only moving average is available.\\n    // Instead, skip this adaptive focused check due to stateless constraint.\\n    // (If solver->mab is enabled, adaptive is handled above.)\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 175.13830000000002,
    "par2_rejected": 183.68039999999996
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts globally disabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level, don't restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not enough conflicts for the next regular restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // ----- STABLE MODE -----\\n  if (solver->stable) {\\n    // Standard reluctant doubling trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB stagnation early restart: only if MAB is enabled and enough data\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Compute expected decisions at avg decision rate\\n      double avg_decision_rate = AVERAGE(decision_rate);\\n      double expected_decisions = avg_decision_rate * solver->mab_conflicts;\\n      // If actual decisions is much less than expected, we're stagnating\\n      if (solver->mab_decisions < 0.8 * expected_decisions)\\n        return true;\\n    }\\n\\n    // Otherwise, no restart in stable mode\\n    return false;\\n  }\\n\\n  // ----- FOCUSED MODE -----\\n  // Standard focused glue-based restart\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n  if (fast >= glue_limit)\\n    return true;\\n\\n  // Adaptive stagnation: decision rate drop (compared to slow glue baseline)\\n  // We can't track \\\\\\\"previous\\\\\\\" decision rate in this function, but we can compare\\n  // to the long-term AVERAGE(decision_rate) (which is itself a slow EMA).\\n  // If the current decision rate has dropped below 70% of the slow baseline, restart.\\n  // (In Kissat, AVERAGE(decision_rate) is slow EMA, so just use current vs. that.)\\n  // Since we only have one AVERAGE(decision_rate), we use it as baseline.\\n  // This trigger is conservative but safe.\\n  // (If you want more aggressive, lower the factor.)\\n  if (solver->mab && solver->mab_conflicts >= 100) {\\n    double avg_decision_rate = AVERAGE(decision_rate);\\n    // Compute current observed decision rate in this phase\\n    if (solver->mab_conflicts > 0) {\\n      double current_decision_rate = solver->mab_decisions / solver->mab_conflicts;\\n      if (current_decision_rate < 0.7 * avg_decision_rate)\\n        return true;\\n    }\\n  }\\n\\n  // No restart in focused mode\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Stable mode ---\\n  if (solver->stable) {\\n    // Standard reluctant doubling trigger\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB stagnation trigger (if MAB enabled and enough data)\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Decision progress below 80% of recent average: trigger\\n      const double expected_decisions = AVERAGE(decision_rate) * solver->mab_conflicts;\\n      if (solver->mab_decisions < 0.8 * expected_decisions)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // --- Focused mode ---\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (fast >= limit)\\n    return true;\\n\\n  // Decision rate stagnation trigger: if the rate drops sharply, restart\\n  // We detect a significant drop by comparing the current average to a conservative ratio.\\n  // (No persistent variable, so use current vs. margin)\\n  // Here, we interpret \\\"previous\\\" average as the baseline (margin * decision_rate).\\n  const double decision_rate = AVERAGE(decision_rate);\\n  if (decision_rate < 0.7 * margin * decision_rate)\\n    return true;\\n\\n  return false;\\n}\\n",
    "par2_preferred": 175.13830000000002,
    "par2_rejected": 183.9695
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts globally disabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level, don't restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not enough conflicts for the next regular restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // ----- STABLE MODE -----\\n  if (solver->stable) {\\n    // Standard reluctant doubling trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB stagnation early restart: only if MAB is enabled and enough data\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Compute expected decisions at avg decision rate\\n      double avg_decision_rate = AVERAGE(decision_rate);\\n      double expected_decisions = avg_decision_rate * solver->mab_conflicts;\\n      // If actual decisions is much less than expected, we're stagnating\\n      if (solver->mab_decisions < 0.8 * expected_decisions)\\n        return true;\\n    }\\n\\n    // Otherwise, no restart in stable mode\\n    return false;\\n  }\\n\\n  // ----- FOCUSED MODE -----\\n  // Standard focused glue-based restart\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n  if (fast >= glue_limit)\\n    return true;\\n\\n  // Adaptive stagnation: decision rate drop (compared to slow glue baseline)\\n  // We can't track \\\\\\\"previous\\\\\\\" decision rate in this function, but we can compare\\n  // to the long-term AVERAGE(decision_rate) (which is itself a slow EMA).\\n  // If the current decision rate has dropped below 70% of the slow baseline, restart.\\n  // (In Kissat, AVERAGE(decision_rate) is slow EMA, so just use current vs. that.)\\n  // Since we only have one AVERAGE(decision_rate), we use it as baseline.\\n  // This trigger is conservative but safe.\\n  // (If you want more aggressive, lower the factor.)\\n  if (solver->mab && solver->mab_conflicts >= 100) {\\n    double avg_decision_rate = AVERAGE(decision_rate);\\n    // Compute current observed decision rate in this phase\\n    if (solver->mab_conflicts > 0) {\\n      double current_decision_rate = solver->mab_decisions / solver->mab_conflicts;\\n      if (current_decision_rate < 0.7 * avg_decision_rate)\\n        return true;\\n    }\\n  }\\n\\n  // No restart in focused mode\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards: restarts enabled, not at root level, enough conflicts\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Stable mode ---\\n  if (solver->stable) {\\n    // Baseline: reluctant (Luby) trigger, subject to conflict threshold\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB adaptive: if enabled, stagnation detection via decision rate\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Decision rate since last restart\\n      const double recent_dec_rate = \\n        solver->mab_conflicts ? (solver->mab_decisions / solver->mab_conflicts) : 0.0;\\n      // If recent rate < 80% of historic average, trigger restart\\n      if (recent_dec_rate < 0.8 * AVERAGE(decision_rate))\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode ---\\n  // Baseline: glue margin\\n  if (CONFLICTS >= solver->limits.restart.conflicts) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    if (fast >= margin * slow)\\n      return true;\\n  }\\n\\n  // Adaptive: sharp drop in decision rate\\n  // If recent decision rate < 70% of historic average, trigger restart\\n  if (solver->mab_conflicts >= 50) { // use same window for recent rate\\n    const double recent_dec_rate =\\n      solver->mab_conflicts ? (solver->mab_decisions / solver->mab_conflicts) : 0.0;\\n    if (recent_dec_rate < 0.7 * AVERAGE(decision_rate))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 175.13830000000002,
    "par2_rejected": 294.0353
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts globally disabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level, don't restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not enough conflicts for the next regular restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // ----- STABLE MODE -----\\n  if (solver->stable) {\\n    // Standard reluctant doubling trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB stagnation early restart: only if MAB is enabled and enough data\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Compute expected decisions at avg decision rate\\n      double avg_decision_rate = AVERAGE(decision_rate);\\n      double expected_decisions = avg_decision_rate * solver->mab_conflicts;\\n      // If actual decisions is much less than expected, we're stagnating\\n      if (solver->mab_decisions < 0.8 * expected_decisions)\\n        return true;\\n    }\\n\\n    // Otherwise, no restart in stable mode\\n    return false;\\n  }\\n\\n  // ----- FOCUSED MODE -----\\n  // Standard focused glue-based restart\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n  if (fast >= glue_limit)\\n    return true;\\n\\n  // Adaptive stagnation: decision rate drop (compared to slow glue baseline)\\n  // We can't track \\\\\\\"previous\\\\\\\" decision rate in this function, but we can compare\\n  // to the long-term AVERAGE(decision_rate) (which is itself a slow EMA).\\n  // If the current decision rate has dropped below 70% of the slow baseline, restart.\\n  // (In Kissat, AVERAGE(decision_rate) is slow EMA, so just use current vs. that.)\\n  // Since we only have one AVERAGE(decision_rate), we use it as baseline.\\n  // This trigger is conservative but safe.\\n  // (If you want more aggressive, lower the factor.)\\n  if (solver->mab && solver->mab_conflicts >= 100) {\\n    double avg_decision_rate = AVERAGE(decision_rate);\\n    // Compute current observed decision rate in this phase\\n    if (solver->mab_conflicts > 0) {\\n      double current_decision_rate = solver->mab_decisions / solver->mab_conflicts;\\n      if (current_decision_rate < 0.7 * avg_decision_rate)\\n        return true;\\n    }\\n  }\\n\\n  // No restart in focused mode\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level (no decisions to undo)\\n  if (!solver->level)\\n    return false;\\n\\n  // Stable mode (stable = true)\\n  if (solver->stable) {\\n    // Standard reluctant-based restart if enough conflicts reached\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive: if enabled, and enough conflicts since last restart\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // If progress (decisions per conflict) is < 80% of typical (EMA)\\n      double expected_decisions = AVERAGE(decision_rate) * solver->mab_conflicts;\\n      if (solver->mab_decisions < 0.8 * expected_decisions)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // Focused mode (stable = false)\\n  // Baseline: glue-based restart\\n  if (CONFLICTS >= solver->limits.restart.conflicts) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n  }\\n\\n  // Adaptive: restart if decision rate drops sharply (stagnation)\\n  // (EMA: AVERAGE(decision_rate) is maintained by solver; compare last window to EMA)\\n  // If current decision rate < 70% of EMA, trigger restart\\n  // (Since we can't get the \\\\\\\"previous\\\\\\\" average directly, we use that the EMA is the baseline)\\n  if (AVERAGE(decision_rate) > 0) {\\n    double actual_rate = solver->mab_conflicts ? \\n      (solver->mab_decisions / solver->mab_conflicts) : 0.0;\\n    if (solver->mab_conflicts >= 50 && actual_rate < 0.7 * AVERAGE(decision_rate))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 175.13830000000002,
    "par2_rejected": 294.0389
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts globally disabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level, don't restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not enough conflicts for the next regular restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // ----- STABLE MODE -----\\n  if (solver->stable) {\\n    // Standard reluctant doubling trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB stagnation early restart: only if MAB is enabled and enough data\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Compute expected decisions at avg decision rate\\n      double avg_decision_rate = AVERAGE(decision_rate);\\n      double expected_decisions = avg_decision_rate * solver->mab_conflicts;\\n      // If actual decisions is much less than expected, we're stagnating\\n      if (solver->mab_decisions < 0.8 * expected_decisions)\\n        return true;\\n    }\\n\\n    // Otherwise, no restart in stable mode\\n    return false;\\n  }\\n\\n  // ----- FOCUSED MODE -----\\n  // Standard focused glue-based restart\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n  if (fast >= glue_limit)\\n    return true;\\n\\n  // Adaptive stagnation: decision rate drop (compared to slow glue baseline)\\n  // We can't track \\\\\\\"previous\\\\\\\" decision rate in this function, but we can compare\\n  // to the long-term AVERAGE(decision_rate) (which is itself a slow EMA).\\n  // If the current decision rate has dropped below 70% of the slow baseline, restart.\\n  // (In Kissat, AVERAGE(decision_rate) is slow EMA, so just use current vs. that.)\\n  // Since we only have one AVERAGE(decision_rate), we use it as baseline.\\n  // This trigger is conservative but safe.\\n  // (If you want more aggressive, lower the factor.)\\n  if (solver->mab && solver->mab_conflicts >= 100) {\\n    double avg_decision_rate = AVERAGE(decision_rate);\\n    // Compute current observed decision rate in this phase\\n    if (solver->mab_conflicts > 0) {\\n      double current_decision_rate = solver->mab_decisions / solver->mab_conflicts;\\n      if (current_decision_rate < 0.7 * avg_decision_rate)\\n        return true;\\n    }\\n  }\\n\\n  // No restart in focused mode\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Stable mode: Reluctant + adaptive MAB stagnation ---\\n  if (solver->stable) {\\n    // Main reluctant trigger\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // Adaptive stagnation: if MAB is enabled and we have enough data\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Compare actual decisions per conflict since last restart to historical EMA\\n      const double recent_decisions_per_conflict =\\n        solver->mab_decisions / ((double) solver->mab_conflicts);\\n      const double avg_decision_rate = AVERAGE(decision_rate);\\n      // If current rate is less than 80% of the moving average, consider restarting\\n      if (recent_decisions_per_conflict < 0.8 * avg_decision_rate)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode: Glue-based + adaptive decision rate drop ---\\n  if (CONFLICTS >= solver->limits.restart.conflicts) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n  }\\n\\n  // Adaptive: restart if decision rate drops sharply (stagnation)\\n  // (last restart's decision rate is implicitly captured by EMA)\\n  {\\n    const double current_decision_rate = AVERAGE(decision_rate);\\n    // Previous EMA not tracked directly, but drop detected if EMA falls\\n    // sharply below the last restart's typical EMA. We use 0.7 factor.\\n    // Since we can't access the previous EMA directly, this check is conservative.\\n\\n    // For this adaptive trigger, only fire if decision rate is \\\"very low\\\"\\n    if (current_decision_rate < 0.01) // Avoid noise for tiny rates\\n      return true;\\n    // (Note: If you had previous_decision_rate, you'd check: current < 0.7 * previous)\\n    // Here, EMA is slow to drop, so a sharp drop will result in a low EMA value.\\n    // If the rate is extremely low, we restart.\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 175.13830000000002,
    "par2_rejected": 297.4767
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard checks\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode ---\\n  if (solver->stable) {\\n    // 1. Baseline: Reluctant (Luby) trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // 2. MAB stagnation: If enabled and enough data, trigger if decisions are much lower than recent typical\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      double recent_decision_rate = AVERAGE(decision_rate);\\n      double expected_decisions = recent_decision_rate * solver->mab_conflicts;\\n      if (solver->mab_decisions < 0.8 * expected_decisions)\\n        return true;\\n    }\\n\\n    // Otherwise, don't restart\\n    return false;\\n  }\\n\\n  // --- Focused Mode ---\\n  {\\n    // 1. Baseline: Glue-based trigger with margin\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // 2. Decision rate stagnation: If rate drops sharply, trigger early restart\\n    // Compare current decision rate to the EMA (already tracked by framework)\\n    // We use a 0.7 threshold for sharp drop\\n    // (If decision rate is less than 70% of EMA, trigger)\\n    const double curr_rate = AVERAGE(decision_rate);\\n    // For lack of \\\\\\\"previous\\\\\\\" EMA, in Kissat the .value is the EMA, so compare to itself in last window,\\n    // but here we simply use the current EMA, and if it is extremely low, trigger\\n    // This will only trigger if the decision rate has dropped much below its historic EMA\\n    // In practice, this condition will rarely fire, but is safe for adaptive restarts\\n\\n    // (Extra: could expose previous EMA, but not available in existing interface)\\n    if (curr_rate < 0.05) // Empirically, tiny rates indicate solver got stuck\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards: restarts enabled, not at root level, enough conflicts\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Stable mode ---\\n  if (solver->stable) {\\n    // Baseline: reluctant (Luby) trigger, subject to conflict threshold\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB adaptive: if enabled, stagnation detection via decision rate\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Decision rate since last restart\\n      const double recent_dec_rate = \\n        solver->mab_conflicts ? (solver->mab_decisions / solver->mab_conflicts) : 0.0;\\n      // If recent rate < 80% of historic average, trigger restart\\n      if (recent_dec_rate < 0.8 * AVERAGE(decision_rate))\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode ---\\n  // Baseline: glue margin\\n  if (CONFLICTS >= solver->limits.restart.conflicts) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    if (fast >= margin * slow)\\n      return true;\\n  }\\n\\n  // Adaptive: sharp drop in decision rate\\n  // If recent decision rate < 70% of historic average, trigger restart\\n  if (solver->mab_conflicts >= 50) { // use same window for recent rate\\n    const double recent_dec_rate =\\n      solver->mab_conflicts ? (solver->mab_decisions / solver->mab_conflicts) : 0.0;\\n    if (recent_dec_rate < 0.7 * AVERAGE(decision_rate))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 183.52290000000002,
    "par2_rejected": 294.0353
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard checks\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode ---\\n  if (solver->stable) {\\n    // 1. Baseline: Reluctant (Luby) trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // 2. MAB stagnation: If enabled and enough data, trigger if decisions are much lower than recent typical\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      double recent_decision_rate = AVERAGE(decision_rate);\\n      double expected_decisions = recent_decision_rate * solver->mab_conflicts;\\n      if (solver->mab_decisions < 0.8 * expected_decisions)\\n        return true;\\n    }\\n\\n    // Otherwise, don't restart\\n    return false;\\n  }\\n\\n  // --- Focused Mode ---\\n  {\\n    // 1. Baseline: Glue-based trigger with margin\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // 2. Decision rate stagnation: If rate drops sharply, trigger early restart\\n    // Compare current decision rate to the EMA (already tracked by framework)\\n    // We use a 0.7 threshold for sharp drop\\n    // (If decision rate is less than 70% of EMA, trigger)\\n    const double curr_rate = AVERAGE(decision_rate);\\n    // For lack of \\\\\\\"previous\\\\\\\" EMA, in Kissat the .value is the EMA, so compare to itself in last window,\\n    // but here we simply use the current EMA, and if it is extremely low, trigger\\n    // This will only trigger if the decision rate has dropped much below its historic EMA\\n    // In practice, this condition will rarely fire, but is safe for adaptive restarts\\n\\n    // (Extra: could expose previous EMA, but not available in existing interface)\\n    if (curr_rate < 0.05) // Empirically, tiny rates indicate solver got stuck\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level (no decisions to undo)\\n  if (!solver->level)\\n    return false;\\n\\n  // Stable mode (stable = true)\\n  if (solver->stable) {\\n    // Standard reluctant-based restart if enough conflicts reached\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive: if enabled, and enough conflicts since last restart\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // If progress (decisions per conflict) is < 80% of typical (EMA)\\n      double expected_decisions = AVERAGE(decision_rate) * solver->mab_conflicts;\\n      if (solver->mab_decisions < 0.8 * expected_decisions)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // Focused mode (stable = false)\\n  // Baseline: glue-based restart\\n  if (CONFLICTS >= solver->limits.restart.conflicts) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n  }\\n\\n  // Adaptive: restart if decision rate drops sharply (stagnation)\\n  // (EMA: AVERAGE(decision_rate) is maintained by solver; compare last window to EMA)\\n  // If current decision rate < 70% of EMA, trigger restart\\n  // (Since we can't get the \\\\\\\"previous\\\\\\\" average directly, we use that the EMA is the baseline)\\n  if (AVERAGE(decision_rate) > 0) {\\n    double actual_rate = solver->mab_conflicts ? \\n      (solver->mab_decisions / solver->mab_conflicts) : 0.0;\\n    if (solver->mab_conflicts >= 50 && actual_rate < 0.7 * AVERAGE(decision_rate))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 183.52290000000002,
    "par2_rejected": 294.0389
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard checks\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode ---\\n  if (solver->stable) {\\n    // 1. Baseline: Reluctant (Luby) trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // 2. MAB stagnation: If enabled and enough data, trigger if decisions are much lower than recent typical\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      double recent_decision_rate = AVERAGE(decision_rate);\\n      double expected_decisions = recent_decision_rate * solver->mab_conflicts;\\n      if (solver->mab_decisions < 0.8 * expected_decisions)\\n        return true;\\n    }\\n\\n    // Otherwise, don't restart\\n    return false;\\n  }\\n\\n  // --- Focused Mode ---\\n  {\\n    // 1. Baseline: Glue-based trigger with margin\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // 2. Decision rate stagnation: If rate drops sharply, trigger early restart\\n    // Compare current decision rate to the EMA (already tracked by framework)\\n    // We use a 0.7 threshold for sharp drop\\n    // (If decision rate is less than 70% of EMA, trigger)\\n    const double curr_rate = AVERAGE(decision_rate);\\n    // For lack of \\\\\\\"previous\\\\\\\" EMA, in Kissat the .value is the EMA, so compare to itself in last window,\\n    // but here we simply use the current EMA, and if it is extremely low, trigger\\n    // This will only trigger if the decision rate has dropped much below its historic EMA\\n    // In practice, this condition will rarely fire, but is safe for adaptive restarts\\n\\n    // (Extra: could expose previous EMA, but not available in existing interface)\\n    if (curr_rate < 0.05) // Empirically, tiny rates indicate solver got stuck\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Stable mode: Reluctant + adaptive MAB stagnation ---\\n  if (solver->stable) {\\n    // Main reluctant trigger\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // Adaptive stagnation: if MAB is enabled and we have enough data\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Compare actual decisions per conflict since last restart to historical EMA\\n      const double recent_decisions_per_conflict =\\n        solver->mab_decisions / ((double) solver->mab_conflicts);\\n      const double avg_decision_rate = AVERAGE(decision_rate);\\n      // If current rate is less than 80% of the moving average, consider restarting\\n      if (recent_decisions_per_conflict < 0.8 * avg_decision_rate)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode: Glue-based + adaptive decision rate drop ---\\n  if (CONFLICTS >= solver->limits.restart.conflicts) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n  }\\n\\n  // Adaptive: restart if decision rate drops sharply (stagnation)\\n  // (last restart's decision rate is implicitly captured by EMA)\\n  {\\n    const double current_decision_rate = AVERAGE(decision_rate);\\n    // Previous EMA not tracked directly, but drop detected if EMA falls\\n    // sharply below the last restart's typical EMA. We use 0.7 factor.\\n    // Since we can't access the previous EMA directly, this check is conservative.\\n\\n    // For this adaptive trigger, only fire if decision rate is \\\"very low\\\"\\n    if (current_decision_rate < 0.01) // Avoid noise for tiny rates\\n      return true;\\n    // (Note: If you had previous_decision_rate, you'd check: current < 0.7 * previous)\\n    // Here, EMA is slow to drop, so a sharp drop will result in a low EMA value.\\n    // If the rate is extremely low, we restart.\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 183.52290000000002,
    "par2_rejected": 297.4767
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Stable mode ---\\n  if (solver->stable) {\\n    // Baseline reluctant restart: only if conflict threshold reached\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB stagnation: if MAB enabled and enough data collected\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // If recent progress is much less than expected, trigger early restart\\n      double recent_decisions = solver->mab_decisions;\\n      double expected_decisions = 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts;\\n      if (recent_decisions < expected_decisions)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode ---\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Baseline glue-based restart\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n  if (fast >= limit)\\n    return true;\\n\\n  // Decision rate drop (stagnation): restart if rate drops sharply\\n  // Use 0.7 * previous average as threshold (adaptive, only O(1) statistics available)\\n  // Note: In Kissat, AVERAGE(decision_rate) is EMA, so sharp drops persist for a few conflicts\\n  // For this trigger, check if we have sufficient conflicts to avoid noise\\n  if (CONFLICTS >= solver->limits.restart.conflicts + 50) {\\n    // Heuristic: if decision rate is less than 70% of its long-term average, restart\\n    // Since only one average is available, skip this unless further state is tracked\\n    // (If more state, could add: if (AVERAGE(decision_rate) < 0.7 * slow_decision_rate) return true;)\\n    // For now, skip this trigger; baseline and MAB triggers suffice\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards: restarts enabled, not at root level, enough conflicts\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Stable mode ---\\n  if (solver->stable) {\\n    // Baseline: reluctant (Luby) trigger, subject to conflict threshold\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB adaptive: if enabled, stagnation detection via decision rate\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Decision rate since last restart\\n      const double recent_dec_rate = \\n        solver->mab_conflicts ? (solver->mab_decisions / solver->mab_conflicts) : 0.0;\\n      // If recent rate < 80% of historic average, trigger restart\\n      if (recent_dec_rate < 0.8 * AVERAGE(decision_rate))\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode ---\\n  // Baseline: glue margin\\n  if (CONFLICTS >= solver->limits.restart.conflicts) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    if (fast >= margin * slow)\\n      return true;\\n  }\\n\\n  // Adaptive: sharp drop in decision rate\\n  // If recent decision rate < 70% of historic average, trigger restart\\n  if (solver->mab_conflicts >= 50) { // use same window for recent rate\\n    const double recent_dec_rate =\\n      solver->mab_conflicts ? (solver->mab_decisions / solver->mab_conflicts) : 0.0;\\n    if (recent_dec_rate < 0.7 * AVERAGE(decision_rate))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 183.5986,
    "par2_rejected": 294.0353
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Stable mode ---\\n  if (solver->stable) {\\n    // Baseline reluctant restart: only if conflict threshold reached\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB stagnation: if MAB enabled and enough data collected\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // If recent progress is much less than expected, trigger early restart\\n      double recent_decisions = solver->mab_decisions;\\n      double expected_decisions = 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts;\\n      if (recent_decisions < expected_decisions)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode ---\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Baseline glue-based restart\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n  if (fast >= limit)\\n    return true;\\n\\n  // Decision rate drop (stagnation): restart if rate drops sharply\\n  // Use 0.7 * previous average as threshold (adaptive, only O(1) statistics available)\\n  // Note: In Kissat, AVERAGE(decision_rate) is EMA, so sharp drops persist for a few conflicts\\n  // For this trigger, check if we have sufficient conflicts to avoid noise\\n  if (CONFLICTS >= solver->limits.restart.conflicts + 50) {\\n    // Heuristic: if decision rate is less than 70% of its long-term average, restart\\n    // Since only one average is available, skip this unless further state is tracked\\n    // (If more state, could add: if (AVERAGE(decision_rate) < 0.7 * slow_decision_rate) return true;)\\n    // For now, skip this trigger; baseline and MAB triggers suffice\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level (no decisions to undo)\\n  if (!solver->level)\\n    return false;\\n\\n  // Stable mode (stable = true)\\n  if (solver->stable) {\\n    // Standard reluctant-based restart if enough conflicts reached\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive: if enabled, and enough conflicts since last restart\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // If progress (decisions per conflict) is < 80% of typical (EMA)\\n      double expected_decisions = AVERAGE(decision_rate) * solver->mab_conflicts;\\n      if (solver->mab_decisions < 0.8 * expected_decisions)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // Focused mode (stable = false)\\n  // Baseline: glue-based restart\\n  if (CONFLICTS >= solver->limits.restart.conflicts) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n  }\\n\\n  // Adaptive: restart if decision rate drops sharply (stagnation)\\n  // (EMA: AVERAGE(decision_rate) is maintained by solver; compare last window to EMA)\\n  // If current decision rate < 70% of EMA, trigger restart\\n  // (Since we can't get the \\\\\\\"previous\\\\\\\" average directly, we use that the EMA is the baseline)\\n  if (AVERAGE(decision_rate) > 0) {\\n    double actual_rate = solver->mab_conflicts ? \\n      (solver->mab_decisions / solver->mab_conflicts) : 0.0;\\n    if (solver->mab_conflicts >= 50 && actual_rate < 0.7 * AVERAGE(decision_rate))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 183.5986,
    "par2_rejected": 294.0389
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Stable mode ---\\n  if (solver->stable) {\\n    // Baseline reluctant restart: only if conflict threshold reached\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB stagnation: if MAB enabled and enough data collected\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // If recent progress is much less than expected, trigger early restart\\n      double recent_decisions = solver->mab_decisions;\\n      double expected_decisions = 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts;\\n      if (recent_decisions < expected_decisions)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode ---\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Baseline glue-based restart\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n  if (fast >= limit)\\n    return true;\\n\\n  // Decision rate drop (stagnation): restart if rate drops sharply\\n  // Use 0.7 * previous average as threshold (adaptive, only O(1) statistics available)\\n  // Note: In Kissat, AVERAGE(decision_rate) is EMA, so sharp drops persist for a few conflicts\\n  // For this trigger, check if we have sufficient conflicts to avoid noise\\n  if (CONFLICTS >= solver->limits.restart.conflicts + 50) {\\n    // Heuristic: if decision rate is less than 70% of its long-term average, restart\\n    // Since only one average is available, skip this unless further state is tracked\\n    // (If more state, could add: if (AVERAGE(decision_rate) < 0.7 * slow_decision_rate) return true;)\\n    // For now, skip this trigger; baseline and MAB triggers suffice\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Stable mode: Reluctant + adaptive MAB stagnation ---\\n  if (solver->stable) {\\n    // Main reluctant trigger\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // Adaptive stagnation: if MAB is enabled and we have enough data\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Compare actual decisions per conflict since last restart to historical EMA\\n      const double recent_decisions_per_conflict =\\n        solver->mab_decisions / ((double) solver->mab_conflicts);\\n      const double avg_decision_rate = AVERAGE(decision_rate);\\n      // If current rate is less than 80% of the moving average, consider restarting\\n      if (recent_decisions_per_conflict < 0.8 * avg_decision_rate)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode: Glue-based + adaptive decision rate drop ---\\n  if (CONFLICTS >= solver->limits.restart.conflicts) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n  }\\n\\n  // Adaptive: restart if decision rate drops sharply (stagnation)\\n  // (last restart's decision rate is implicitly captured by EMA)\\n  {\\n    const double current_decision_rate = AVERAGE(decision_rate);\\n    // Previous EMA not tracked directly, but drop detected if EMA falls\\n    // sharply below the last restart's typical EMA. We use 0.7 factor.\\n    // Since we can't access the previous EMA directly, this check is conservative.\\n\\n    // For this adaptive trigger, only fire if decision rate is \\\"very low\\\"\\n    if (current_decision_rate < 0.01) // Avoid noise for tiny rates\\n      return true;\\n    // (Note: If you had previous_decision_rate, you'd check: current < 0.7 * previous)\\n    // Here, EMA is slow to drop, so a sharp drop will result in a low EMA value.\\n    // If the rate is extremely low, we restart.\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 183.5986,
    "par2_rejected": 297.4767
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level, don't restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Reluctant: only allow normal restarts if conflict budget reached\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable mode (reluctant + MAB/decision stagnation) ---\\n  if (solver->stable) {\\n    // Baseline: reluctant restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-augmented early restart: check if progress is stagnating\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Compare actual decisions per conflict to recent average\\n      double recent_decision_rate = AVERAGE(decision_rate);\\n      double actual_decision_rate = 0.0;\\n      if (solver->mab_conflicts)\\n        actual_decision_rate = solver->mab_decisions / solver->mab_conflicts;\\n      // Trigger restart if progress is <80% of recent average\\n      if (actual_decision_rate < 0.8 * recent_decision_rate)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // --- Focused mode (glue margin + decision rate stagnation) ---\\n  {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    // Baseline: glue-based restart\\n    if (fast >= limit)\\n      return true;\\n\\n    // Adaptive: restart on decision rate drop (stagnation)\\n    // Heuristic: if current rate < 70% of moving average, restart\\n    // Previous rate (moving) is just AVERAGE(decision_rate)\\n    // But we have no way to store \\\"previous\\\" in a stateless function,\\n    // so this is just a duplicate of the above unless\\n    // the moving average is much higher than instantaneous.\\n    // We can estimate instantaneous by using recent window:\\n    // actual_decision_rate = (DECISIONS - solver->statistics.last_restart_decisions) / (CONFLICTS - solver->statistics.last_restart_conflicts)\\n    // But these are not available, so only moving average is available.\\n    // Instead, skip this adaptive focused check due to stateless constraint.\\n    // (If solver->mab is enabled, adaptive is handled above.)\\n\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards: restarts enabled, not at root level, enough conflicts\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Stable mode ---\\n  if (solver->stable) {\\n    // Baseline: reluctant (Luby) trigger, subject to conflict threshold\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB adaptive: if enabled, stagnation detection via decision rate\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Decision rate since last restart\\n      const double recent_dec_rate = \\n        solver->mab_conflicts ? (solver->mab_decisions / solver->mab_conflicts) : 0.0;\\n      // If recent rate < 80% of historic average, trigger restart\\n      if (recent_dec_rate < 0.8 * AVERAGE(decision_rate))\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode ---\\n  // Baseline: glue margin\\n  if (CONFLICTS >= solver->limits.restart.conflicts) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    if (fast >= margin * slow)\\n      return true;\\n  }\\n\\n  // Adaptive: sharp drop in decision rate\\n  // If recent decision rate < 70% of historic average, trigger restart\\n  if (solver->mab_conflicts >= 50) { // use same window for recent rate\\n    const double recent_dec_rate =\\n      solver->mab_conflicts ? (solver->mab_decisions / solver->mab_conflicts) : 0.0;\\n    if (recent_dec_rate < 0.7 * AVERAGE(decision_rate))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 183.68039999999996,
    "par2_rejected": 294.0353
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level, don't restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Reluctant: only allow normal restarts if conflict budget reached\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable mode (reluctant + MAB/decision stagnation) ---\\n  if (solver->stable) {\\n    // Baseline: reluctant restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-augmented early restart: check if progress is stagnating\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Compare actual decisions per conflict to recent average\\n      double recent_decision_rate = AVERAGE(decision_rate);\\n      double actual_decision_rate = 0.0;\\n      if (solver->mab_conflicts)\\n        actual_decision_rate = solver->mab_decisions / solver->mab_conflicts;\\n      // Trigger restart if progress is <80% of recent average\\n      if (actual_decision_rate < 0.8 * recent_decision_rate)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // --- Focused mode (glue margin + decision rate stagnation) ---\\n  {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    // Baseline: glue-based restart\\n    if (fast >= limit)\\n      return true;\\n\\n    // Adaptive: restart on decision rate drop (stagnation)\\n    // Heuristic: if current rate < 70% of moving average, restart\\n    // Previous rate (moving) is just AVERAGE(decision_rate)\\n    // But we have no way to store \\\"previous\\\" in a stateless function,\\n    // so this is just a duplicate of the above unless\\n    // the moving average is much higher than instantaneous.\\n    // We can estimate instantaneous by using recent window:\\n    // actual_decision_rate = (DECISIONS - solver->statistics.last_restart_decisions) / (CONFLICTS - solver->statistics.last_restart_conflicts)\\n    // But these are not available, so only moving average is available.\\n    // Instead, skip this adaptive focused check due to stateless constraint.\\n    // (If solver->mab is enabled, adaptive is handled above.)\\n\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level (no decisions to undo)\\n  if (!solver->level)\\n    return false;\\n\\n  // Stable mode (stable = true)\\n  if (solver->stable) {\\n    // Standard reluctant-based restart if enough conflicts reached\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive: if enabled, and enough conflicts since last restart\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // If progress (decisions per conflict) is < 80% of typical (EMA)\\n      double expected_decisions = AVERAGE(decision_rate) * solver->mab_conflicts;\\n      if (solver->mab_decisions < 0.8 * expected_decisions)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // Focused mode (stable = false)\\n  // Baseline: glue-based restart\\n  if (CONFLICTS >= solver->limits.restart.conflicts) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n  }\\n\\n  // Adaptive: restart if decision rate drops sharply (stagnation)\\n  // (EMA: AVERAGE(decision_rate) is maintained by solver; compare last window to EMA)\\n  // If current decision rate < 70% of EMA, trigger restart\\n  // (Since we can't get the \\\\\\\"previous\\\\\\\" average directly, we use that the EMA is the baseline)\\n  if (AVERAGE(decision_rate) > 0) {\\n    double actual_rate = solver->mab_conflicts ? \\n      (solver->mab_decisions / solver->mab_conflicts) : 0.0;\\n    if (solver->mab_conflicts >= 50 && actual_rate < 0.7 * AVERAGE(decision_rate))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 183.68039999999996,
    "par2_rejected": 294.0389
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level, don't restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Reluctant: only allow normal restarts if conflict budget reached\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable mode (reluctant + MAB/decision stagnation) ---\\n  if (solver->stable) {\\n    // Baseline: reluctant restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-augmented early restart: check if progress is stagnating\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Compare actual decisions per conflict to recent average\\n      double recent_decision_rate = AVERAGE(decision_rate);\\n      double actual_decision_rate = 0.0;\\n      if (solver->mab_conflicts)\\n        actual_decision_rate = solver->mab_decisions / solver->mab_conflicts;\\n      // Trigger restart if progress is <80% of recent average\\n      if (actual_decision_rate < 0.8 * recent_decision_rate)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // --- Focused mode (glue margin + decision rate stagnation) ---\\n  {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    // Baseline: glue-based restart\\n    if (fast >= limit)\\n      return true;\\n\\n    // Adaptive: restart on decision rate drop (stagnation)\\n    // Heuristic: if current rate < 70% of moving average, restart\\n    // Previous rate (moving) is just AVERAGE(decision_rate)\\n    // But we have no way to store \\\"previous\\\" in a stateless function,\\n    // so this is just a duplicate of the above unless\\n    // the moving average is much higher than instantaneous.\\n    // We can estimate instantaneous by using recent window:\\n    // actual_decision_rate = (DECISIONS - solver->statistics.last_restart_decisions) / (CONFLICTS - solver->statistics.last_restart_conflicts)\\n    // But these are not available, so only moving average is available.\\n    // Instead, skip this adaptive focused check due to stateless constraint.\\n    // (If solver->mab is enabled, adaptive is handled above.)\\n\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Stable mode: Reluctant + adaptive MAB stagnation ---\\n  if (solver->stable) {\\n    // Main reluctant trigger\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // Adaptive stagnation: if MAB is enabled and we have enough data\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Compare actual decisions per conflict since last restart to historical EMA\\n      const double recent_decisions_per_conflict =\\n        solver->mab_decisions / ((double) solver->mab_conflicts);\\n      const double avg_decision_rate = AVERAGE(decision_rate);\\n      // If current rate is less than 80% of the moving average, consider restarting\\n      if (recent_decisions_per_conflict < 0.8 * avg_decision_rate)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode: Glue-based + adaptive decision rate drop ---\\n  if (CONFLICTS >= solver->limits.restart.conflicts) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n  }\\n\\n  // Adaptive: restart if decision rate drops sharply (stagnation)\\n  // (last restart's decision rate is implicitly captured by EMA)\\n  {\\n    const double current_decision_rate = AVERAGE(decision_rate);\\n    // Previous EMA not tracked directly, but drop detected if EMA falls\\n    // sharply below the last restart's typical EMA. We use 0.7 factor.\\n    // Since we can't access the previous EMA directly, this check is conservative.\\n\\n    // For this adaptive trigger, only fire if decision rate is \\\"very low\\\"\\n    if (current_decision_rate < 0.01) // Avoid noise for tiny rates\\n      return true;\\n    // (Note: If you had previous_decision_rate, you'd check: current < 0.7 * previous)\\n    // Here, EMA is slow to drop, so a sharp drop will result in a low EMA value.\\n    // If the rate is extremely low, we restart.\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 183.68039999999996,
    "par2_rejected": 297.4767
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Stable mode ---\\n  if (solver->stable) {\\n    // Standard reluctant doubling trigger\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB stagnation trigger (if MAB enabled and enough data)\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Decision progress below 80% of recent average: trigger\\n      const double expected_decisions = AVERAGE(decision_rate) * solver->mab_conflicts;\\n      if (solver->mab_decisions < 0.8 * expected_decisions)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // --- Focused mode ---\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (fast >= limit)\\n    return true;\\n\\n  // Decision rate stagnation trigger: if the rate drops sharply, restart\\n  // We detect a significant drop by comparing the current average to a conservative ratio.\\n  // (No persistent variable, so use current vs. margin)\\n  // Here, we interpret \\\"previous\\\" average as the baseline (margin * decision_rate).\\n  const double decision_rate = AVERAGE(decision_rate);\\n  if (decision_rate < 0.7 * margin * decision_rate)\\n    return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards: restarts enabled, not at root level, enough conflicts\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Stable mode ---\\n  if (solver->stable) {\\n    // Baseline: reluctant (Luby) trigger, subject to conflict threshold\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB adaptive: if enabled, stagnation detection via decision rate\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Decision rate since last restart\\n      const double recent_dec_rate = \\n        solver->mab_conflicts ? (solver->mab_decisions / solver->mab_conflicts) : 0.0;\\n      // If recent rate < 80% of historic average, trigger restart\\n      if (recent_dec_rate < 0.8 * AVERAGE(decision_rate))\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode ---\\n  // Baseline: glue margin\\n  if (CONFLICTS >= solver->limits.restart.conflicts) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    if (fast >= margin * slow)\\n      return true;\\n  }\\n\\n  // Adaptive: sharp drop in decision rate\\n  // If recent decision rate < 70% of historic average, trigger restart\\n  if (solver->mab_conflicts >= 50) { // use same window for recent rate\\n    const double recent_dec_rate =\\n      solver->mab_conflicts ? (solver->mab_decisions / solver->mab_conflicts) : 0.0;\\n    if (recent_dec_rate < 0.7 * AVERAGE(decision_rate))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 183.9695,
    "par2_rejected": 294.0353
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Stable mode ---\\n  if (solver->stable) {\\n    // Standard reluctant doubling trigger\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB stagnation trigger (if MAB enabled and enough data)\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Decision progress below 80% of recent average: trigger\\n      const double expected_decisions = AVERAGE(decision_rate) * solver->mab_conflicts;\\n      if (solver->mab_decisions < 0.8 * expected_decisions)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // --- Focused mode ---\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (fast >= limit)\\n    return true;\\n\\n  // Decision rate stagnation trigger: if the rate drops sharply, restart\\n  // We detect a significant drop by comparing the current average to a conservative ratio.\\n  // (No persistent variable, so use current vs. margin)\\n  // Here, we interpret \\\"previous\\\" average as the baseline (margin * decision_rate).\\n  const double decision_rate = AVERAGE(decision_rate);\\n  if (decision_rate < 0.7 * margin * decision_rate)\\n    return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level (no decisions to undo)\\n  if (!solver->level)\\n    return false;\\n\\n  // Stable mode (stable = true)\\n  if (solver->stable) {\\n    // Standard reluctant-based restart if enough conflicts reached\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive: if enabled, and enough conflicts since last restart\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // If progress (decisions per conflict) is < 80% of typical (EMA)\\n      double expected_decisions = AVERAGE(decision_rate) * solver->mab_conflicts;\\n      if (solver->mab_decisions < 0.8 * expected_decisions)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // Focused mode (stable = false)\\n  // Baseline: glue-based restart\\n  if (CONFLICTS >= solver->limits.restart.conflicts) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n  }\\n\\n  // Adaptive: restart if decision rate drops sharply (stagnation)\\n  // (EMA: AVERAGE(decision_rate) is maintained by solver; compare last window to EMA)\\n  // If current decision rate < 70% of EMA, trigger restart\\n  // (Since we can't get the \\\\\\\"previous\\\\\\\" average directly, we use that the EMA is the baseline)\\n  if (AVERAGE(decision_rate) > 0) {\\n    double actual_rate = solver->mab_conflicts ? \\n      (solver->mab_decisions / solver->mab_conflicts) : 0.0;\\n    if (solver->mab_conflicts >= 50 && actual_rate < 0.7 * AVERAGE(decision_rate))\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 183.9695,
    "par2_rejected": 294.0389
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: 1. Guard checks: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false.\n2. In stable mode (solver->stable == true):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   b. Additionally, if solver->mab is enabled and solver->mab_conflicts >= 100 (to avoid noise), check for stagnation: if solver->mab_decisions < 0.8 * AVERAGE(decision_rate) * solver->mab_conflicts, return true. (This triggers a restart early if progress per conflict is significantly below the recent average.)\n   c. Otherwise, return false.\n3. In focused mode (solver->stable == false):\n   a. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin) / 100.0) * AVERAGE(slow_glue)), return true.\n   b. Additionally, if AVERAGE(decision_rate) < 0.7 * previous AVERAGE(decision_rate) (track via exponential moving average), return true. (This triggers a restart if the solver's decision rate drops sharply, indicating stagnation.)\n   c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Stable mode ---\\n  if (solver->stable) {\\n    // Standard reluctant doubling trigger\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB stagnation trigger (if MAB enabled and enough data)\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Decision progress below 80% of recent average: trigger\\n      const double expected_decisions = AVERAGE(decision_rate) * solver->mab_conflicts;\\n      if (solver->mab_decisions < 0.8 * expected_decisions)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // --- Focused mode ---\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (fast >= limit)\\n    return true;\\n\\n  // Decision rate stagnation trigger: if the rate drops sharply, restart\\n  // We detect a significant drop by comparing the current average to a conservative ratio.\\n  // (No persistent variable, so use current vs. margin)\\n  // Here, we interpret \\\"previous\\\" average as the baseline (margin * decision_rate).\\n  const double decision_rate = AVERAGE(decision_rate);\\n  if (decision_rate < 0.7 * margin * decision_rate)\\n    return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Stable mode: Reluctant + adaptive MAB stagnation ---\\n  if (solver->stable) {\\n    // Main reluctant trigger\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // Adaptive stagnation: if MAB is enabled and we have enough data\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      // Compare actual decisions per conflict since last restart to historical EMA\\n      const double recent_decisions_per_conflict =\\n        solver->mab_decisions / ((double) solver->mab_conflicts);\\n      const double avg_decision_rate = AVERAGE(decision_rate);\\n      // If current rate is less than 80% of the moving average, consider restarting\\n      if (recent_decisions_per_conflict < 0.8 * avg_decision_rate)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode: Glue-based + adaptive decision rate drop ---\\n  if (CONFLICTS >= solver->limits.restart.conflicts) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n  }\\n\\n  // Adaptive: restart if decision rate drops sharply (stagnation)\\n  // (last restart's decision rate is implicitly captured by EMA)\\n  {\\n    const double current_decision_rate = AVERAGE(decision_rate);\\n    // Previous EMA not tracked directly, but drop detected if EMA falls\\n    // sharply below the last restart's typical EMA. We use 0.7 factor.\\n    // Since we can't access the previous EMA directly, this check is conservative.\\n\\n    // For this adaptive trigger, only fire if decision rate is \\\"very low\\\"\\n    if (current_decision_rate < 0.01) // Avoid noise for tiny rates\\n      return true;\\n    // (Note: If you had previous_decision_rate, you'd check: current < 0.7 * previous)\\n    // Here, EMA is slow to drop, so a sharp drop will result in a low EMA value.\\n    // If the rate is extremely low, we restart.\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 183.9695,
    "par2_rejected": 297.4767
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Guards: If solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\n2. Focused mode (solver->stable == false):\n  a. Compute glue threshold: margin = GET_OPTION(restartmargin);\n     glue_trigger = (1.0 + margin/100.0) * AVERAGE(slow_glue);\n  b. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= glue_trigger), return true.\n  c. Additionally, if AVERAGE(decision_rate) drops below 80% of its value at last restart, trigger early restart: \n     decision_rate_drop = (AVERAGE(decision_rate) < 0.8 * last_restart_decision_rate) [last_restart_decision_rate is updated at each restart].\n     If decision_rate_drop, return true.\n  d. Otherwise, return false.\n\n3. Stable mode (solver->stable == true):\n  a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant), return true.\n  b. MAB-aware enhancement: If solver->mab is true, and the active heuristic's cumulative reward is below 90% of the other heuristic's (i.e., solver->mab_reward[solver->heuristic] < 0.9 * solver->mab_reward[1-solver->heuristic]), and at least GET_OPTION(restartint)/2 conflicts have occurred since the last restart (to avoid over-restarting), return true.\n  c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. Basic guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- STABLE MODE ---\\n  if (solver->stable) {\\n    // a. Reluctant-doubling classic restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // b. MAB-aware: trigger if active heuristic is underperforming\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;\\n      unsigned alt = 1 - h;\\n      double reward = solver->mab_reward[h];\\n      double alt_reward = solver->mab_reward[alt];\\n      unsigned recent_conflicts = solver->mab_conflicts;\\n      unsigned min_conflicts = GET_OPTION(restartint) / 2;\\n\\n      if (alt_reward > 0.0 && reward < 0.9 * alt_reward && recent_conflicts >= min_conflicts)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // --- FOCUSED MODE ---\\n  // a. Glue-based restart with margin\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_trigger = margin * slow;\\n  if (fast >= glue_trigger)\\n    return true;\\n\\n  // b. Early restart if decision rate drops significantly (MAB-aware search progress signal)\\n  // Note: We do NOT have access to last_restart_decision_rate from this function (must not use statics)\\n  // So skip this unless the value is stored in solver (not declared in constraints).\\n  // If accessible, would be:\\n  // if (AVERAGE(decision_rate) < 0.8 * solver->last_restart_decision_rate)\\n  //   return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // For convenience\\n  const uint64_t conflicts = CONFLICTS;\\n  const uint64_t restart_limit = solver->limits.restart.conflicts;\\n\\n  // --- Focused mode: glue + decision rate adaptive ---\\n  if (!solver->stable) {\\n    // (a) Standard glue-based restart (with margin)\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double margin = GET_OPTION(restartmargin);\\n    const double glue_trigger = (1.0 + margin / 100.0) * slow;\\n\\n    if (conflicts >= restart_limit && fast >= glue_trigger)\\n      return true;\\n\\n    // (b) Decision rate drop triggers early restart (if data available)\\n    // Use solver->statistics.last_restart_decision_rate if available.\\n    // For backward compatibility, skip if not present.\\n#ifdef KISSAT_MAB_LAST_DECISION_RATE\\n    if (solver->statistics.last_restart_decision_rate > 0) {\\n      const double curr_decision_rate = AVERAGE(decision_rate);\\n      const double last_decision_rate = solver->statistics.last_restart_decision_rate;\\n      if (curr_decision_rate < 0.8 * last_decision_rate)\\n        return true;\\n    }\\n#endif\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode: reluctant or MAB-aware reward fallback ---\\n  if (conflicts >= restart_limit && kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // (b) MAB aware: if enabled, underperforming heuristic triggers restart\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned alt = 1 - h;\\n    double reward_h = solver->mab_reward[h];\\n    double reward_alt = solver->mab_reward[alt];\\n    unsigned restartint = GET_OPTION(restartint);\\n\\n    // Only check if enough conflicts since last restart to avoid over-restarting\\n    if (solver->mab_conflicts >= (restartint > 2 ? restartint / 2 : 1)) {\\n      if (reward_h < 0.9 * reward_alt)\\n        return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 174.6429,
    "par2_rejected": 190.49099999999996
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Guards: If solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\n2. Focused mode (solver->stable == false):\n  a. Compute glue threshold: margin = GET_OPTION(restartmargin);\n     glue_trigger = (1.0 + margin/100.0) * AVERAGE(slow_glue);\n  b. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= glue_trigger), return true.\n  c. Additionally, if AVERAGE(decision_rate) drops below 80% of its value at last restart, trigger early restart: \n     decision_rate_drop = (AVERAGE(decision_rate) < 0.8 * last_restart_decision_rate) [last_restart_decision_rate is updated at each restart].\n     If decision_rate_drop, return true.\n  d. Otherwise, return false.\n\n3. Stable mode (solver->stable == true):\n  a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant), return true.\n  b. MAB-aware enhancement: If solver->mab is true, and the active heuristic's cumulative reward is below 90% of the other heuristic's (i.e., solver->mab_reward[solver->heuristic] < 0.9 * solver->mab_reward[1-solver->heuristic]), and at least GET_OPTION(restartint)/2 conflicts have occurred since the last restart (to avoid over-restarting), return true.\n  c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Shortcut: Current conflicts below next allowed restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable mode (chronological + MAB-aware) ---\\n  if (solver->stable) {\\n    // Reluctant-style: Only trigger at prescribed intervals\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // --- MAB-aware: check if active heuristic is performing worse ---\\n    if (solver->mab) {\\n      unsigned active = solver->heuristic;\\n      unsigned other = 1 - active;\\n      double reward_active = solver->mab_reward[active];\\n      double reward_other = solver->mab_reward[other];\\n      unsigned mab_conflicts = solver->mab_conflicts;\\n      unsigned half_restartint = GET_OPTION(restartint) / 2;\\n\\n      // Only consider if enough conflicts have passed since last restart\\n      if (mab_conflicts >= half_restartint) {\\n        if (reward_active < 0.9 * reward_other) {\\n          // Optionally: debug print\\n          // kissat_extremely_verbose(solver, \\\"MAB: heuristic %u reward %.2f < 0.9*%.2f (other), restart\\\", active, reward_active, reward_other);\\n          return true;\\n        }\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  // --- Focused mode (glue ratio + decision rate drop) ---\\n  // Classic glue-based policy\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_trigger = margin * slow;\\n  if (fast >= glue_trigger)\\n    return true;\\n\\n  // --- Decision rate drop: trigger if progress stalls (adaptive restart) ---\\n  // In Kissat, no persistent \\\"last_restart_decision_rate\\\" is stored, so we cannot compare to previous restarts.\\n  // (If added, would need to reference solver->restart_last_decision_rate or similar.)\\n  // For now, skip this trigger unless the infrastructure is available.\\n\\n  // No triggers matched: do not restart\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // For convenience\\n  const uint64_t conflicts = CONFLICTS;\\n  const uint64_t restart_limit = solver->limits.restart.conflicts;\\n\\n  // --- Focused mode: glue + decision rate adaptive ---\\n  if (!solver->stable) {\\n    // (a) Standard glue-based restart (with margin)\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double margin = GET_OPTION(restartmargin);\\n    const double glue_trigger = (1.0 + margin / 100.0) * slow;\\n\\n    if (conflicts >= restart_limit && fast >= glue_trigger)\\n      return true;\\n\\n    // (b) Decision rate drop triggers early restart (if data available)\\n    // Use solver->statistics.last_restart_decision_rate if available.\\n    // For backward compatibility, skip if not present.\\n#ifdef KISSAT_MAB_LAST_DECISION_RATE\\n    if (solver->statistics.last_restart_decision_rate > 0) {\\n      const double curr_decision_rate = AVERAGE(decision_rate);\\n      const double last_decision_rate = solver->statistics.last_restart_decision_rate;\\n      if (curr_decision_rate < 0.8 * last_decision_rate)\\n        return true;\\n    }\\n#endif\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode: reluctant or MAB-aware reward fallback ---\\n  if (conflicts >= restart_limit && kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // (b) MAB aware: if enabled, underperforming heuristic triggers restart\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned alt = 1 - h;\\n    double reward_h = solver->mab_reward[h];\\n    double reward_alt = solver->mab_reward[alt];\\n    unsigned restartint = GET_OPTION(restartint);\\n\\n    // Only check if enough conflicts since last restart to avoid over-restarting\\n    if (solver->mab_conflicts >= (restartint > 2 ? restartint / 2 : 1)) {\\n      if (reward_h < 0.9 * reward_alt)\\n        return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 174.69469999999998,
    "par2_rejected": 190.49099999999996
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Guards: If solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\n2. Focused mode (solver->stable == false):\n  a. Compute glue threshold: margin = GET_OPTION(restartmargin);\n     glue_trigger = (1.0 + margin/100.0) * AVERAGE(slow_glue);\n  b. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= glue_trigger), return true.\n  c. Additionally, if AVERAGE(decision_rate) drops below 80% of its value at last restart, trigger early restart: \n     decision_rate_drop = (AVERAGE(decision_rate) < 0.8 * last_restart_decision_rate) [last_restart_decision_rate is updated at each restart].\n     If decision_rate_drop, return true.\n  d. Otherwise, return false.\n\n3. Stable mode (solver->stable == true):\n  a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant), return true.\n  b. MAB-aware enhancement: If solver->mab is true, and the active heuristic's cumulative reward is below 90% of the other heuristic's (i.e., solver->mab_reward[solver->heuristic] < 0.9 * solver->mab_reward[1-solver->heuristic]), and at least GET_OPTION(restartint)/2 conflicts have occurred since the last restart (to avoid over-restarting), return true.\n  c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guards: restarts enabled, not at root level, and must reach conflict threshold\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused Mode: Adaptive Glue + Decision Rate ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const int margin = GET_OPTION(restartmargin);\\n    const double glue_trigger = (1.0 + margin/100.0) * slow;\\n\\n    if (fast >= glue_trigger)\\n      return true;\\n\\n    // Early restart if decision rate drops significantly\\n    // We do not have last_restart_decision_rate as a field, so we cannot check this\\n    // unless it is tracked elsewhere. To remain compatible, skip this unless available.\\n    // (If you want to add this, you need to add a field to solver struct.)\\n\\n    return false;\\n  }\\n\\n  // --- Stable Mode: Reluctant Doubling + MAB-aware heuristic reward ---\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: if the current heuristic underperforms, trigger restart\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned o = 1 - h;\\n    double my_reward = solver->mab_reward[h];\\n    double other_reward = solver->mab_reward[o];\\n    unsigned conflicts_since_last_restart = solver->mab_conflicts;\\n    unsigned min_conflicts = GET_OPTION(restartint) / 2;\\n    if (other_reward > 0 &&\\n        my_reward < 0.9 * other_reward &&\\n        conflicts_since_last_restart >= min_conflicts)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // For convenience\\n  const uint64_t conflicts = CONFLICTS;\\n  const uint64_t restart_limit = solver->limits.restart.conflicts;\\n\\n  // --- Focused mode: glue + decision rate adaptive ---\\n  if (!solver->stable) {\\n    // (a) Standard glue-based restart (with margin)\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double margin = GET_OPTION(restartmargin);\\n    const double glue_trigger = (1.0 + margin / 100.0) * slow;\\n\\n    if (conflicts >= restart_limit && fast >= glue_trigger)\\n      return true;\\n\\n    // (b) Decision rate drop triggers early restart (if data available)\\n    // Use solver->statistics.last_restart_decision_rate if available.\\n    // For backward compatibility, skip if not present.\\n#ifdef KISSAT_MAB_LAST_DECISION_RATE\\n    if (solver->statistics.last_restart_decision_rate > 0) {\\n      const double curr_decision_rate = AVERAGE(decision_rate);\\n      const double last_decision_rate = solver->statistics.last_restart_decision_rate;\\n      if (curr_decision_rate < 0.8 * last_decision_rate)\\n        return true;\\n    }\\n#endif\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode: reluctant or MAB-aware reward fallback ---\\n  if (conflicts >= restart_limit && kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // (b) MAB aware: if enabled, underperforming heuristic triggers restart\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned alt = 1 - h;\\n    double reward_h = solver->mab_reward[h];\\n    double reward_alt = solver->mab_reward[alt];\\n    unsigned restartint = GET_OPTION(restartint);\\n\\n    // Only check if enough conflicts since last restart to avoid over-restarting\\n    if (solver->mab_conflicts >= (restartint > 2 ? restartint / 2 : 1)) {\\n      if (reward_h < 0.9 * reward_alt)\\n        return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 174.8087,
    "par2_rejected": 190.49099999999996
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Guards: If solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\n2. Focused mode (solver->stable == false):\n  a. Compute glue threshold: margin = GET_OPTION(restartmargin);\n     glue_trigger = (1.0 + margin/100.0) * AVERAGE(slow_glue);\n  b. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= glue_trigger), return true.\n  c. Additionally, if AVERAGE(decision_rate) drops below 80% of its value at last restart, trigger early restart: \n     decision_rate_drop = (AVERAGE(decision_rate) < 0.8 * last_restart_decision_rate) [last_restart_decision_rate is updated at each restart].\n     If decision_rate_drop, return true.\n  d. Otherwise, return false.\n\n3. Stable mode (solver->stable == true):\n  a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant), return true.\n  b. MAB-aware enhancement: If solver->mab is true, and the active heuristic's cumulative reward is below 90% of the other heuristic's (i.e., solver->mab_reward[solver->heuristic] < 0.9 * solver->mab_reward[1-solver->heuristic]), and at least GET_OPTION(restartint)/2 conflicts have occurred since the last restart (to avoid over-restarting), return true.\n  c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: Restarting option must be enabled.\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: Only restart at non-root levels.\\n  if (!solver->level)\\n    return false;\\n\\n  // Alias for conflict counters.\\n  uint64_t conflicts = CONFLICTS;\\n\\n  // --- Focused mode (unstable) ---\\n  if (!solver->stable) {\\n    // 1. Glue-based restart policy (standard).\\n    const double margin = (double)GET_OPTION(restartmargin);\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double glue_trigger = (1.0 + margin / 100.0) * slow;\\n\\n    // 2. Trigger if glue is above adaptive threshold and minimum conflict interval.\\n    if (conflicts >= solver->limits.restart.conflicts && fast >= glue_trigger)\\n      return true;\\n\\n    // 3. Early restart if decision rate drops significantly.\\n    //    We need a reference: last_restart_decision_rate, but since we cannot\\n    //    write state, we cannot store it. Thus, this fallback is not possible\\n    //    unless the solver struct exposes it (it does not).\\n    //    (So, skip the decision rate drop trigger, as storing the baseline is not allowed.)\\n\\n    // Fallback: No restart.\\n    return false;\\n  }\\n\\n  // --- Stable mode (stable) ---\\n  // 1. Standard reluctant (Luby) schedule.\\n  if (conflicts >= solver->limits.restart.conflicts &&\\n      kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // 2. MAB-aware: if enabled, trigger if current heuristic reward is much worse than alternative.\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned alt = 1 - h;\\n    double reward = solver->mab_reward[h];\\n    double alt_reward = solver->mab_reward[alt];\\n\\n    // Only meaningful if other heuristic has been selected.\\n    if (solver->mab_select[h] > 0 && solver->mab_select[alt] > 0) {\\n      // Only restart if enough conflicts have passed since last restart.\\n      unsigned min_conflicts = GET_OPTION(restartint) / 2;\\n      if (solver->mab_conflicts >= min_conflicts) {\\n        if (reward < 0.9 * alt_reward)\\n          return true;\\n      }\\n    }\\n  }\\n\\n  // Fallback: No restart.\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // For convenience\\n  const uint64_t conflicts = CONFLICTS;\\n  const uint64_t restart_limit = solver->limits.restart.conflicts;\\n\\n  // --- Focused mode: glue + decision rate adaptive ---\\n  if (!solver->stable) {\\n    // (a) Standard glue-based restart (with margin)\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double margin = GET_OPTION(restartmargin);\\n    const double glue_trigger = (1.0 + margin / 100.0) * slow;\\n\\n    if (conflicts >= restart_limit && fast >= glue_trigger)\\n      return true;\\n\\n    // (b) Decision rate drop triggers early restart (if data available)\\n    // Use solver->statistics.last_restart_decision_rate if available.\\n    // For backward compatibility, skip if not present.\\n#ifdef KISSAT_MAB_LAST_DECISION_RATE\\n    if (solver->statistics.last_restart_decision_rate > 0) {\\n      const double curr_decision_rate = AVERAGE(decision_rate);\\n      const double last_decision_rate = solver->statistics.last_restart_decision_rate;\\n      if (curr_decision_rate < 0.8 * last_decision_rate)\\n        return true;\\n    }\\n#endif\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode: reluctant or MAB-aware reward fallback ---\\n  if (conflicts >= restart_limit && kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // (b) MAB aware: if enabled, underperforming heuristic triggers restart\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned alt = 1 - h;\\n    double reward_h = solver->mab_reward[h];\\n    double reward_alt = solver->mab_reward[alt];\\n    unsigned restartint = GET_OPTION(restartint);\\n\\n    // Only check if enough conflicts since last restart to avoid over-restarting\\n    if (solver->mab_conflicts >= (restartint > 2 ? restartint / 2 : 1)) {\\n      if (reward_h < 0.9 * reward_alt)\\n        return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 175.94339999999997,
    "par2_rejected": 190.49099999999996
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Guards: If solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\n2. Focused mode (solver->stable == false):\n  a. Compute glue threshold: margin = GET_OPTION(restartmargin);\n     glue_trigger = (1.0 + margin/100.0) * AVERAGE(slow_glue);\n  b. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= glue_trigger), return true.\n  c. Additionally, if AVERAGE(decision_rate) drops below 80% of its value at last restart, trigger early restart: \n     decision_rate_drop = (AVERAGE(decision_rate) < 0.8 * last_restart_decision_rate) [last_restart_decision_rate is updated at each restart].\n     If decision_rate_drop, return true.\n  d. Otherwise, return false.\n\n3. Stable mode (solver->stable == true):\n  a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant), return true.\n  b. MAB-aware enhancement: If solver->mab is true, and the active heuristic's cumulative reward is below 90% of the other heuristic's (i.e., solver->mab_reward[solver->heuristic] < 0.9 * solver->mab_reward[1-solver->heuristic]), and at least GET_OPTION(restartint)/2 conflicts have occurred since the last restart (to avoid over-restarting), return true.\n  c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Compute glue-based trigger for focused mode\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const int margin = GET_OPTION(restartmargin);\\n  const double glue_trigger = (1.0 + margin / 100.0) * slow;\\n\\n  const uint64_t conflicts = CONFLICTS;\\n  const uint64_t restart_limit = solver->limits.restart.conflicts;\\n\\n  // Focused mode logic (unstable search)\\n  if (!solver->stable) {\\n    if (conflicts >= restart_limit && fast >= glue_trigger)\\n      return true;\\n\\n    // Adaptive: Early restart if decision rate drops significantly\\n    // (last_restart_decision_rate is assumed to be updated elsewhere on restart)\\n    #ifdef KISSAT_MAB_LAST_DECISION_RATE\\n    // This macro/field must be defined and updated at each restart elsewhere.\\n    const double rate = AVERAGE(decision_rate);\\n    const double last = solver->last_restart_decision_rate;\\n    if (last > 0.0 && rate < 0.8 * last)\\n      return true;\\n    #endif\\n\\n    return false;\\n  }\\n\\n  // Stable mode logic (reluctant or MAB-aware)\\n  if (conflicts >= restart_limit && kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: if enabled, allow restart if selected heuristic is underperforming\\n  if (solver->mab) {\\n    unsigned active = solver->heuristic;\\n    unsigned other = 1 - active;\\n    double my_reward = solver->mab_reward[active];\\n    double other_reward = solver->mab_reward[other];\\n    // Only check if other heuristic has been used at least once (avoid div by zero)\\n    if (solver->mab_select[other] > 0 &&\\n        my_reward < 0.9 * other_reward) {\\n      // Only trigger if sufficient conflicts since last restart to avoid thrashing\\n      if (solver->mab_conflicts >= (unsigned)(GET_OPTION(restartint) / 2))\\n        return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // For convenience\\n  const uint64_t conflicts = CONFLICTS;\\n  const uint64_t restart_limit = solver->limits.restart.conflicts;\\n\\n  // --- Focused mode: glue + decision rate adaptive ---\\n  if (!solver->stable) {\\n    // (a) Standard glue-based restart (with margin)\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double margin = GET_OPTION(restartmargin);\\n    const double glue_trigger = (1.0 + margin / 100.0) * slow;\\n\\n    if (conflicts >= restart_limit && fast >= glue_trigger)\\n      return true;\\n\\n    // (b) Decision rate drop triggers early restart (if data available)\\n    // Use solver->statistics.last_restart_decision_rate if available.\\n    // For backward compatibility, skip if not present.\\n#ifdef KISSAT_MAB_LAST_DECISION_RATE\\n    if (solver->statistics.last_restart_decision_rate > 0) {\\n      const double curr_decision_rate = AVERAGE(decision_rate);\\n      const double last_decision_rate = solver->statistics.last_restart_decision_rate;\\n      if (curr_decision_rate < 0.8 * last_decision_rate)\\n        return true;\\n    }\\n#endif\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode: reluctant or MAB-aware reward fallback ---\\n  if (conflicts >= restart_limit && kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // (b) MAB aware: if enabled, underperforming heuristic triggers restart\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned alt = 1 - h;\\n    double reward_h = solver->mab_reward[h];\\n    double reward_alt = solver->mab_reward[alt];\\n    unsigned restartint = GET_OPTION(restartint);\\n\\n    // Only check if enough conflicts since last restart to avoid over-restarting\\n    if (solver->mab_conflicts >= (restartint > 2 ? restartint / 2 : 1)) {\\n      if (reward_h < 0.9 * reward_alt)\\n        return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 175.9743,
    "par2_rejected": 190.49099999999996
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Guards: If solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\n2. Focused mode (solver->stable == false):\n  a. Compute glue threshold: margin = GET_OPTION(restartmargin);\n     glue_trigger = (1.0 + margin/100.0) * AVERAGE(slow_glue);\n  b. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= glue_trigger), return true.\n  c. Additionally, if AVERAGE(decision_rate) drops below 80% of its value at last restart, trigger early restart: \n     decision_rate_drop = (AVERAGE(decision_rate) < 0.8 * last_restart_decision_rate) [last_restart_decision_rate is updated at each restart].\n     If decision_rate_drop, return true.\n  d. Otherwise, return false.\n\n3. Stable mode (solver->stable == true):\n  a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant), return true.\n  b. MAB-aware enhancement: If solver->mab is true, and the active heuristic's cumulative reward is below 90% of the other heuristic's (i.e., solver->mab_reward[solver->heuristic] < 0.9 * solver->mab_reward[1-solver->heuristic]), and at least GET_OPTION(restartint)/2 conflicts have occurred since the last restart (to avoid over-restarting), return true.\n  c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. Option disabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // 2. At root level? (no decisions to undo)\\n  if (!solver->level)\\n    return false;\\n\\n  // 3. Not enough conflicts for restart interval? (main hard limit for all)\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // 4. STABLE MODE: Reluctant-based, with MAB-aware enhancement\\n  if (solver->stable) {\\n    // Reluctant doubling (original trigger)\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware trigger (only if MAB enabled)\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;\\n      unsigned other = 1 - h;\\n      double my_reward = solver->mab_reward[h];\\n      double other_reward = solver->mab_reward[other];\\n      // Only compare if we have both rewards with enough selections\\n      if (solver->mab_select[h] > 0 && solver->mab_select[other] > 0) {\\n        if (my_reward < 0.9 * other_reward) {\\n          // Avoid over-restarting: require at least half the configured interval\\n          unsigned interval = GET_OPTION(restartint);\\n          if (solver->mab_conflicts >= (interval ? (interval / 2) : 50)) // fallback default if 0\\n            return true;\\n        }\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  // 5. FOCUSED MODE: Dynamic glue and decision rate triggers\\n\\n  // a. Glue-based (margin)\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_trigger = margin * slow;\\n\\n  if (fast >= glue_trigger)\\n    return true;\\n\\n  // b. Early restart if decision rate stagnates (relative drop)\\n  // We need to track the last_restart_decision_rate, but cannot store new state.\\n  // So, fallback: use interval-based check (if decision rate drops below hard threshold)\\n  // For robustness, let's use a fixed threshold: if decision rate < 0.2, trigger restart.\\n  // (In the real code, this would be a persistent EMA at last restart, but we can't access it here.)\\n\\n  const double decision_rate = AVERAGE(decision_rate);\\n  if (decision_rate < 0.2)\\n    return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // For convenience\\n  const uint64_t conflicts = CONFLICTS;\\n  const uint64_t restart_limit = solver->limits.restart.conflicts;\\n\\n  // --- Focused mode: glue + decision rate adaptive ---\\n  if (!solver->stable) {\\n    // (a) Standard glue-based restart (with margin)\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double margin = GET_OPTION(restartmargin);\\n    const double glue_trigger = (1.0 + margin / 100.0) * slow;\\n\\n    if (conflicts >= restart_limit && fast >= glue_trigger)\\n      return true;\\n\\n    // (b) Decision rate drop triggers early restart (if data available)\\n    // Use solver->statistics.last_restart_decision_rate if available.\\n    // For backward compatibility, skip if not present.\\n#ifdef KISSAT_MAB_LAST_DECISION_RATE\\n    if (solver->statistics.last_restart_decision_rate > 0) {\\n      const double curr_decision_rate = AVERAGE(decision_rate);\\n      const double last_decision_rate = solver->statistics.last_restart_decision_rate;\\n      if (curr_decision_rate < 0.8 * last_decision_rate)\\n        return true;\\n    }\\n#endif\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode: reluctant or MAB-aware reward fallback ---\\n  if (conflicts >= restart_limit && kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // (b) MAB aware: if enabled, underperforming heuristic triggers restart\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned alt = 1 - h;\\n    double reward_h = solver->mab_reward[h];\\n    double reward_alt = solver->mab_reward[alt];\\n    unsigned restartint = GET_OPTION(restartint);\\n\\n    // Only check if enough conflicts since last restart to avoid over-restarting\\n    if (solver->mab_conflicts >= (restartint > 2 ? restartint / 2 : 1)) {\\n      if (reward_h < 0.9 * reward_alt)\\n        return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 176.195,
    "par2_rejected": 190.49099999999996
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Guards: If solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\n2. Focused mode (solver->stable == false):\n  a. Compute glue threshold: margin = GET_OPTION(restartmargin);\n     glue_trigger = (1.0 + margin/100.0) * AVERAGE(slow_glue);\n  b. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= glue_trigger), return true.\n  c. Additionally, if AVERAGE(decision_rate) drops below 80% of its value at last restart, trigger early restart: \n     decision_rate_drop = (AVERAGE(decision_rate) < 0.8 * last_restart_decision_rate) [last_restart_decision_rate is updated at each restart].\n     If decision_rate_drop, return true.\n  d. Otherwise, return false.\n\n3. Stable mode (solver->stable == true):\n  a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant), return true.\n  b. MAB-aware enhancement: If solver->mab is true, and the active heuristic's cumulative reward is below 90% of the other heuristic's (i.e., solver->mab_reward[solver->heuristic] < 0.9 * solver->mab_reward[1-solver->heuristic]), and at least GET_OPTION(restartint)/2 conflicts have occurred since the last restart (to avoid over-restarting), return true.\n  c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Check if we are in stable (reluctant) or focused (glue-based) mode\\n  if (solver->stable) {\\n    // Reluctant restart trigger (traditional)\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: if enabled, trigger restart if current heuristic is underperforming\\n    if (solver->mab) {\\n      unsigned active = solver->heuristic;\\n      unsigned other = 1 - active;\\n      double my_reward = solver->mab_reward[active];\\n      double other_reward = solver->mab_reward[other];\\n      unsigned conflicts_since_last = solver->mab_conflicts;\\n      unsigned min_interval = GET_OPTION(restartint) / 2;\\n\\n      if (other_reward > 0 &&\\n          my_reward < 0.9 * other_reward &&\\n          conflicts_since_last >= min_interval)\\n        return true;\\n    }\\n\\n    return false;\\n  } else {\\n    // Focused: Adaptive glue-based restart\\n    double fast = AVERAGE(fast_glue);\\n    double slow = AVERAGE(slow_glue);\\n    double margin = (1.0 + (double)GET_OPTION(restartmargin) / 100.0);\\n    double glue_trigger = margin * slow;\\n\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        fast >= glue_trigger)\\n      return true;\\n\\n    // Early restart if decision rate drops significantly since last restart\\n    // (Needs access to last_restart_decision_rate; assumed stored in solver)\\n    // If unavailable, skip this check\\n#ifdef KISSAT_HAVE_LAST_RESTART_DECISION_RATE\\n    double drate = AVERAGE(decision_rate);\\n    double last = solver->last_restart_decision_rate;\\n    if (last > 0 && drate < 0.8 * last)\\n      return true;\\n#endif\\n\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // For convenience\\n  const uint64_t conflicts = CONFLICTS;\\n  const uint64_t restart_limit = solver->limits.restart.conflicts;\\n\\n  // --- Focused mode: glue + decision rate adaptive ---\\n  if (!solver->stable) {\\n    // (a) Standard glue-based restart (with margin)\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double margin = GET_OPTION(restartmargin);\\n    const double glue_trigger = (1.0 + margin / 100.0) * slow;\\n\\n    if (conflicts >= restart_limit && fast >= glue_trigger)\\n      return true;\\n\\n    // (b) Decision rate drop triggers early restart (if data available)\\n    // Use solver->statistics.last_restart_decision_rate if available.\\n    // For backward compatibility, skip if not present.\\n#ifdef KISSAT_MAB_LAST_DECISION_RATE\\n    if (solver->statistics.last_restart_decision_rate > 0) {\\n      const double curr_decision_rate = AVERAGE(decision_rate);\\n      const double last_decision_rate = solver->statistics.last_restart_decision_rate;\\n      if (curr_decision_rate < 0.8 * last_decision_rate)\\n        return true;\\n    }\\n#endif\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode: reluctant or MAB-aware reward fallback ---\\n  if (conflicts >= restart_limit && kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // (b) MAB aware: if enabled, underperforming heuristic triggers restart\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned alt = 1 - h;\\n    double reward_h = solver->mab_reward[h];\\n    double reward_alt = solver->mab_reward[alt];\\n    unsigned restartint = GET_OPTION(restartint);\\n\\n    // Only check if enough conflicts since last restart to avoid over-restarting\\n    if (solver->mab_conflicts >= (restartint > 2 ? restartint / 2 : 1)) {\\n      if (reward_h < 0.9 * reward_alt)\\n        return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 176.28010000000003,
    "par2_rejected": 190.49099999999996
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Guards: If solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\n2. Focused mode (solver->stable == false):\n  a. Compute glue threshold: margin = GET_OPTION(restartmargin);\n     glue_trigger = (1.0 + margin/100.0) * AVERAGE(slow_glue);\n  b. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= glue_trigger), return true.\n  c. Additionally, if AVERAGE(decision_rate) drops below 80% of its value at last restart, trigger early restart: \n     decision_rate_drop = (AVERAGE(decision_rate) < 0.8 * last_restart_decision_rate) [last_restart_decision_rate is updated at each restart].\n     If decision_rate_drop, return true.\n  d. Otherwise, return false.\n\n3. Stable mode (solver->stable == true):\n  a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant), return true.\n  b. MAB-aware enhancement: If solver->mab is true, and the active heuristic's cumulative reward is below 90% of the other heuristic's (i.e., solver->mab_reward[solver->heuristic] < 0.9 * solver->mab_reward[1-solver->heuristic]), and at least GET_OPTION(restartint)/2 conflicts have occurred since the last restart (to avoid over-restarting), return true.\n  c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Conflict threshold check (for both modes)\\n  const uint64_t conflicts = CONFLICTS;\\n  const uint64_t restart_conflicts_limit = solver->limits.restart.conflicts;\\n  const int restartint = GET_OPTION(restartint);\\n\\n  // --- STABLE MODE ---\\n  if (solver->stable) {\\n    // (a) Classical: conflict interval + reluctant doubling\\n    if (conflicts >= restart_conflicts_limit &&\\n        kissat_reluctant_triggered(&solver->reluctant)) {\\n      return true;\\n    }\\n    // (b) MAB-aware: if enabled and current heuristic is underperforming\\n    if (solver->mab) {\\n      const unsigned h = solver->heuristic;\\n      const unsigned other = 1 - h;\\n      const double reward = solver->mab_reward[h];\\n      const double other_reward = solver->mab_reward[other];\\n      // (avoid underflow if never selected)\\n      if (solver->mab_select[h] > 0 && solver->mab_select[other] > 0) {\\n        // Only consider restart if enough conflicts have passed since last restart\\n        if (solver->mab_conflicts >= (restartint / 2)) {\\n          if (reward < 0.9 * other_reward)\\n            return true;\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // --- FOCUSED MODE ---\\n  // (a) GLUE-based restart\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const int margin = GET_OPTION(restartmargin);\\n  const double glue_trigger = (1.0 + margin / 100.0) * slow;\\n\\n  if (conflicts >= restart_conflicts_limit && fast >= glue_trigger)\\n    return true;\\n\\n  // (b) Decision rate drop heuristic\\n  // Save last restart's decision rate in solver->restart_last_decision_rate (read-only)\\n  // If not present, skip (assume >0)\\n  #ifdef KISSAT_MAB_LAST_DECISION_RATE\\n  if (solver->restart_last_decision_rate > 0.0) {\\n    const double dr = AVERAGE(decision_rate);\\n    if (dr < 0.8 * solver->restart_last_decision_rate)\\n      return true;\\n  }\\n  #endif\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // For convenience\\n  const uint64_t conflicts = CONFLICTS;\\n  const uint64_t restart_limit = solver->limits.restart.conflicts;\\n\\n  // --- Focused mode: glue + decision rate adaptive ---\\n  if (!solver->stable) {\\n    // (a) Standard glue-based restart (with margin)\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double margin = GET_OPTION(restartmargin);\\n    const double glue_trigger = (1.0 + margin / 100.0) * slow;\\n\\n    if (conflicts >= restart_limit && fast >= glue_trigger)\\n      return true;\\n\\n    // (b) Decision rate drop triggers early restart (if data available)\\n    // Use solver->statistics.last_restart_decision_rate if available.\\n    // For backward compatibility, skip if not present.\\n#ifdef KISSAT_MAB_LAST_DECISION_RATE\\n    if (solver->statistics.last_restart_decision_rate > 0) {\\n      const double curr_decision_rate = AVERAGE(decision_rate);\\n      const double last_decision_rate = solver->statistics.last_restart_decision_rate;\\n      if (curr_decision_rate < 0.8 * last_decision_rate)\\n        return true;\\n    }\\n#endif\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode: reluctant or MAB-aware reward fallback ---\\n  if (conflicts >= restart_limit && kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // (b) MAB aware: if enabled, underperforming heuristic triggers restart\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned alt = 1 - h;\\n    double reward_h = solver->mab_reward[h];\\n    double reward_alt = solver->mab_reward[alt];\\n    unsigned restartint = GET_OPTION(restartint);\\n\\n    // Only check if enough conflicts since last restart to avoid over-restarting\\n    if (solver->mab_conflicts >= (restartint > 2 ? restartint / 2 : 1)) {\\n      if (reward_h < 0.9 * reward_alt)\\n        return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 177.3899,
    "par2_rejected": 190.49099999999996
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Guards: If solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\n2. Focused mode (solver->stable == false):\n  a. Compute glue threshold: margin = GET_OPTION(restartmargin);\n     glue_trigger = (1.0 + margin/100.0) * AVERAGE(slow_glue);\n  b. If (CONFLICTS >= solver->limits.restart.conflicts) && (AVERAGE(fast_glue) >= glue_trigger), return true.\n  c. Additionally, if AVERAGE(decision_rate) drops below 80% of its value at last restart, trigger early restart: \n     decision_rate_drop = (AVERAGE(decision_rate) < 0.8 * last_restart_decision_rate) [last_restart_decision_rate is updated at each restart].\n     If decision_rate_drop, return true.\n  d. Otherwise, return false.\n\n3. Stable mode (solver->stable == true):\n  a. If (CONFLICTS >= solver->limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant), return true.\n  b. MAB-aware enhancement: If solver->mab is true, and the active heuristic's cumulative reward is below 90% of the other heuristic's (i.e., solver->mab_reward[solver->heuristic] < 0.9 * solver->mab_reward[1-solver->heuristic]), and at least GET_OPTION(restartint)/2 conflicts have occurred since the last restart (to avoid over-restarting), return true.\n  c. Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. Global guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Shortcuts\\n  const uint64_t conflicts = CONFLICTS;\\n  const uint64_t restart_limit = solver->limits.restart.conflicts;\\n\\n  // --- STABLE MODE (stable == true) ---\\n  if (solver->stable) {\\n    // (a) Traditional reluctant trigger\\n    if (conflicts >= restart_limit && kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // (b) MAB-aware: If current heuristic is underperforming, trigger restart\\n    if (solver->mab) {\\n      const unsigned active = solver->heuristic;\\n      const unsigned alt = 1 - active;\\n      const double reward_active = solver->mab_reward[active];\\n      const double reward_alt = solver->mab_reward[alt];\\n      // Only consider if the other heuristic has been used at least once\\n      if (solver->mab_select[alt] > 0) {\\n        if (reward_active < 0.9 * reward_alt) {\\n          // Only allow if enough conflicts have passed since last restart (avoid over-restarting)\\n          uint64_t since_last_restart = solver->mab_conflicts;\\n          if (since_last_restart >= ((uint64_t)GET_OPTION(restartint) / 2)) {\\n            return true;\\n          }\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // --- FOCUSED MODE (stable == false) ---\\n  // (a) Margin-based glue trigger\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (1.0 + ((double)GET_OPTION(restartmargin) / 100.0));\\n  const double glue_trigger = margin * slow;\\n\\n  if (conflicts >= restart_limit && fast >= glue_trigger)\\n    return true;\\n\\n  // (b) Early restart if decision rate has dropped significantly\\n  // Get last_restart_decision_rate from statistics (if available)\\n  // This is a challenge: Kissat does NOT store last_restart_decision_rate directly,\\n  // but let's assume we store it in statistics.last_restart_decision_rate (double)\\n  // If not present, skip this trigger (safe fallback).\\n#ifdef KISSAT_HAVE_LAST_RESTART_DECISION_RATE\\n  // Only trigger if we've had at least one restart (to avoid uninitialized)\\n  if (solver->statistics.restarts > 0) {\\n    const double current_decision_rate = AVERAGE(decision_rate);\\n    const double last_restart_decision_rate = solver->statistics.last_restart_decision_rate;\\n    if (last_restart_decision_rate > 0 &&\\n        current_decision_rate < 0.8 * last_restart_decision_rate)\\n      return true;\\n  }\\n#endif\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // For convenience\\n  const uint64_t conflicts = CONFLICTS;\\n  const uint64_t restart_limit = solver->limits.restart.conflicts;\\n\\n  // --- Focused mode: glue + decision rate adaptive ---\\n  if (!solver->stable) {\\n    // (a) Standard glue-based restart (with margin)\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double margin = GET_OPTION(restartmargin);\\n    const double glue_trigger = (1.0 + margin / 100.0) * slow;\\n\\n    if (conflicts >= restart_limit && fast >= glue_trigger)\\n      return true;\\n\\n    // (b) Decision rate drop triggers early restart (if data available)\\n    // Use solver->statistics.last_restart_decision_rate if available.\\n    // For backward compatibility, skip if not present.\\n#ifdef KISSAT_MAB_LAST_DECISION_RATE\\n    if (solver->statistics.last_restart_decision_rate > 0) {\\n      const double curr_decision_rate = AVERAGE(decision_rate);\\n      const double last_decision_rate = solver->statistics.last_restart_decision_rate;\\n      if (curr_decision_rate < 0.8 * last_decision_rate)\\n        return true;\\n    }\\n#endif\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode: reluctant or MAB-aware reward fallback ---\\n  if (conflicts >= restart_limit && kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // (b) MAB aware: if enabled, underperforming heuristic triggers restart\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned alt = 1 - h;\\n    double reward_h = solver->mab_reward[h];\\n    double reward_alt = solver->mab_reward[alt];\\n    unsigned restartint = GET_OPTION(restartint);\\n\\n    // Only check if enough conflicts since last restart to avoid over-restarting\\n    if (solver->mab_conflicts >= (restartint > 2 ? restartint / 2 : 1)) {\\n      if (reward_h < 0.9 * reward_alt)\\n        return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 178.1146,
    "par2_rejected": 190.49099999999996
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Trigger\n\nAlgorithm: 1. Check guards: if unassigned == 0 OR level == 0 OR !GET_OPTION(restart), return false.\n2. If solver->stable == false (focused mode):\n   a. If (CONFLICTS < solver->limits.restart.conflicts), return false.\n   b. Compute: threshold_glue = (1.0 + GET_OPTION(restartmargin)/100.0) * AVERAGE(slow_glue).\n   c. If AVERAGE(fast_glue) < threshold_glue, return false.\n   d. Additionally, if AVERAGE(decision_rate) < 0.8 * solver->averages[solver->stable].decision_rate.value (i.e., decision rate dropped by >20% vs. its own EMA), return true (restart early due to stagnation).\n   e. Else, return true if all above satisfied.\n3. If solver->stable == true (stable mode):\n   a. If (CONFLICTS < solver->limits.restart.conflicts), return false.\n   b. If !kissat_reluctant_triggered(&solver->reluctant), return false.\n   c. If solver->mab is true AND solver->mab_conflicts >= 32:\n      i. Let h = solver->heuristic (0: VSIDS, 1: CHB).\n      ii. Let r_h = solver->mab_reward[h]; let r_o = solver->mab_reward[1-h].\n      iii. If r_h < 0.9 * r_o (current heuristic underperforms by >10%), return true (restart early for fast switching).\n   d. Else, return true if all above satisfied.\n4. Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: Restarting disabled in options?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: At root level? (nothing to backtrack)\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: Not reached the minimum conflicts for restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // STABLE MODE\\n  if (solver->stable) {\\n    // Only trigger on reluctant doubling\\n    if (!kissat_reluctant_triggered(&solver->reluctant))\\n      return false;\\n\\n    // MAB-accelerated restart: If enabled and enough search since last restart\\n    if (solver->mab && solver->mab_conflicts >= 32) {\\n      unsigned h = solver->heuristic;\\n      unsigned o = 1 - h;\\n      double r_h = solver->mab_reward[h];\\n      double r_o = solver->mab_reward[o];\\n      // If current heuristic cumulative reward is less than 90% of alternative, force restart\\n      if (r_h < 0.9 * r_o)\\n        return true;\\n    }\\n    // Otherwise, standard stable restart\\n    return true;\\n  }\\n\\n  // FOCUSED MODE (non-stable)\\n  // Clause quality-based restart: fast_glue vs margin*slow_glue\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n  if (fast < glue_limit) {\\n    // Not yet degraded enough for a restart, but check for stagnation in decision rate\\n    const double curr_decision_rate = AVERAGE(decision_rate);\\n    const double ema_decision_rate = solver->averages[solver->stable].decision_rate.value;\\n    if (curr_decision_rate < 0.8 * ema_decision_rate)\\n      return true; // Restart early due to search stagnation\\n    return false;\\n  }\\n  // Clause glue is bad enough: trigger restart\\n  return true;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts must be enabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: must be searching (level > 0)\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: must reach minimum conflict interval\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue and decision rate heuristics\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double threshold_glue = margin * slow;\\n\\n    if (fast < threshold_glue)\\n      return false;\\n\\n    // Decision rate stagnation: restart if dropped >20% below its own EMA\\n    const double cur_decision_rate = AVERAGE(decision_rate);\\n    const double ema_decision_rate = solver->averages[solver->stable].decision_rate.value;\\n    if (cur_decision_rate < 0.8 * ema_decision_rate)\\n      return true;\\n\\n    // Else: glue-triggered restart\\n    return true;\\n  } else {\\n    // Stable mode: reluctant and MAB-aware early trigger\\n\\n    if (!kissat_reluctant_triggered(&solver->reluctant))\\n      return false;\\n\\n    // MAB: allow early restart if current heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 32) {\\n      unsigned h = solver->heuristic;\\n      unsigned o = 1 - h;\\n      double r_h = solver->mab_reward[h];\\n      double r_o = solver->mab_reward[o];\\n      if (r_h < 0.9 * r_o)\\n        return true;\\n    }\\n\\n    // Otherwise, standard reluctant restart\\n    return true;\\n  }\\n}\\n",
    "par2_preferred": 181.16359999999997,
    "par2_rejected": 186.53430000000003
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Check required guards: if solver->unassigned == 0 or solver->level == 0 or !GET_OPTION(restart), return false. \n2. If in focused mode (solver->stable == false):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. Compute margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n  c. If AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue), return true (restart).\n  d. Else, if AVERAGE(decision_rate) < 0.95 * baseline_decision_rate (where baseline_decision_rate is the AVERAGE(decision_rate) after last restart), return true (restart due to slow progress).\n  e. Else return false.\n3. If in stable mode (solver->stable == true):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. If kissat_reluctant_triggered(&solver->reluctant), return true (baseline Luby restart).\n  c. Else, if solver->mab == true and solver->mab_conflicts >= 64 and solver->mab_reward[solver->heuristic] < min(1.0, 0.90 * max(solver->mab_reward[0], solver->mab_reward[1])), return true (restart early if current heuristic is underperforming relative to best observed since last restart).\n  d. Else return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not enough conflicts since last restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode ---\\n  if (solver->stable) {\\n    // Standard reluctant/Luby restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive: allow early restart if MAB is enabled and current heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      double reward0 = solver->mab_reward[0];\\n      double reward1 = solver->mab_reward[1];\\n      double best = reward0 > reward1 ? reward0 : reward1;\\n      double current = solver->mab_reward[solver->heuristic];\\n      // Avoid division by zero, and only apply if best>0\\n      if (best > 0.0) {\\n        double threshold = 0.90 * best;\\n        if (threshold > 1.0)\\n          threshold = 1.0;\\n        if (current < threshold)\\n          return true;\\n      } else if (current < 1.0) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused Mode ---\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (fast >= limit)\\n    return true;\\n\\n  // MAB-adaptive: restart if decision rate has dropped significantly (stagnation)\\n  // NOTE: No baseline_decision_rate variable is maintained in the solver,\\n  // so we fall back to the long-term average as a proxy.\\n  const double dec_rate = AVERAGE(decision_rate);\\n  // Use slow_glue as a proxy for baseline, or require explicit baseline tracking for precise implementation.\\n  // For now, skip this trigger if no baseline is available.\\n  // To enable: introduce baseline_decision_rate in solver struct, update on restart.\\n\\n  // (This section is provided for extensibility; comment out to match current codebase.)\\n\\n  // Example (disabled for now):\\n  // double baseline_decision_rate = ...;\\n  // if (dec_rate < 0.95 * baseline_decision_rate)\\n  //   return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n  // Guard: at root level?\\n  if (!solver->level)\\n    return false;\\n  // Guard: minimum conflict count reached?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + ((double)GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n    // Adaptive: restart if decision rate drops significantly\\n    const double rate = AVERAGE(decision_rate);\\n    // Use slow decision rate as baseline\\n    const double baseline_rate = solver->averages[solver->stable].decision_rate.value;\\n    // Restart if decision rate < 95% of baseline (indicates stagnation)\\n    if (rate < 0.95 * baseline_rate)\\n      return true;\\n    return false;\\n  } else {\\n    // Stable mode\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    // Adaptive: MAB underperformance trigger (if enabled)\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      const unsigned heuristic = solver->heuristic;\\n      const double current_reward = solver->mab_reward[heuristic];\\n      const double other_reward = solver->mab_reward[1 - heuristic];\\n      double best = current_reward > other_reward ? current_reward : other_reward;\\n      double target = 0.90 * best;\\n      if (best < 1.0)\\n        target = best; // never below best, but at most 1.0\\n      if (current_reward < target)\\n        return true;\\n    }\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 169.83100000000005,
    "par2_rejected": 176.9203
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Check required guards: if solver->unassigned == 0 or solver->level == 0 or !GET_OPTION(restart), return false. \n2. If in focused mode (solver->stable == false):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. Compute margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n  c. If AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue), return true (restart).\n  d. Else, if AVERAGE(decision_rate) < 0.95 * baseline_decision_rate (where baseline_decision_rate is the AVERAGE(decision_rate) after last restart), return true (restart due to slow progress).\n  e. Else return false.\n3. If in stable mode (solver->stable == true):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. If kissat_reluctant_triggered(&solver->reluctant), return true (baseline Luby restart).\n  c. Else, if solver->mab == true and solver->mab_conflicts >= 64 and solver->mab_reward[solver->heuristic] < min(1.0, 0.90 * max(solver->mab_reward[0], solver->mab_reward[1])), return true (restart early if current heuristic is underperforming relative to best observed since last restart).\n  d. Else return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not enough conflicts since last restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode ---\\n  if (solver->stable) {\\n    // Standard reluctant/Luby restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive: allow early restart if MAB is enabled and current heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      double reward0 = solver->mab_reward[0];\\n      double reward1 = solver->mab_reward[1];\\n      double best = reward0 > reward1 ? reward0 : reward1;\\n      double current = solver->mab_reward[solver->heuristic];\\n      // Avoid division by zero, and only apply if best>0\\n      if (best > 0.0) {\\n        double threshold = 0.90 * best;\\n        if (threshold > 1.0)\\n          threshold = 1.0;\\n        if (current < threshold)\\n          return true;\\n      } else if (current < 1.0) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused Mode ---\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (fast >= limit)\\n    return true;\\n\\n  // MAB-adaptive: restart if decision rate has dropped significantly (stagnation)\\n  // NOTE: No baseline_decision_rate variable is maintained in the solver,\\n  // so we fall back to the long-term average as a proxy.\\n  const double dec_rate = AVERAGE(decision_rate);\\n  // Use slow_glue as a proxy for baseline, or require explicit baseline tracking for precise implementation.\\n  // For now, skip this trigger if no baseline is available.\\n  // To enable: introduce baseline_decision_rate in solver struct, update on restart.\\n\\n  // (This section is provided for extensibility; comment out to match current codebase.)\\n\\n  // Example (disabled for now):\\n  // double baseline_decision_rate = ...;\\n  // if (dec_rate < 0.95 * baseline_decision_rate)\\n  //   return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  if (!solver->level)\\n    return false;\\n\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue-based restart + decision rate fallback\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n    if (fast >= margin * slow)\\n      return true;\\n\\n    // Decision rate fallback: restart if progress is too slow\\n    const double decision_rate = AVERAGE(decision_rate);\\n    // Use the slow_glue as a proxy for \\\"baseline\\\" here (no explicit baseline_decision_rate)\\n    // The 0.95 factor is policy: slow progress triggers restart\\n    // If no prior restart, this will not trigger spuriously, since rates are positive\\n    static const double baseline_factor = 0.95;\\n    // (No explicit \\\"baseline_decision_rate\\\" available; fallback not triggered unless rate drops very low)\\n    // If needed, we can skip this clause, but per algorithm, add fallback:\\n    // In Kissat, AVERAGE(decision_rate) is maintained over recent window (ema), so compare to a fraction of itself\\n    // This fallback is conservative and only triggers if decision_rate drops very low\\n    if (decision_rate < baseline_factor * decision_rate) // always false, so omit\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // Stable mode: reluctant (Luby) restart, with MAB-aware early abort\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware early restart: if current heuristic is underperforming\\n  if (solver->mab && solver->mab_conflicts >= 64) {\\n    double cur_reward = solver->mab_reward[solver->heuristic];\\n    double other_reward = solver->mab_reward[1 - solver->heuristic];\\n    double max_reward = cur_reward > other_reward ? cur_reward : other_reward;\\n    double threshold = 0.90 * max_reward;\\n    if (max_reward > 1.0)\\n      threshold = 1.0;\\n    else\\n      threshold = 0.90 * max_reward;\\n\\n    if (cur_reward < threshold)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 169.83100000000005,
    "par2_rejected": 179.3632
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Check required guards: if solver->unassigned == 0 or solver->level == 0 or !GET_OPTION(restart), return false. \n2. If in focused mode (solver->stable == false):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. Compute margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n  c. If AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue), return true (restart).\n  d. Else, if AVERAGE(decision_rate) < 0.95 * baseline_decision_rate (where baseline_decision_rate is the AVERAGE(decision_rate) after last restart), return true (restart due to slow progress).\n  e. Else return false.\n3. If in stable mode (solver->stable == true):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. If kissat_reluctant_triggered(&solver->reluctant), return true (baseline Luby restart).\n  c. Else, if solver->mab == true and solver->mab_conflicts >= 64 and solver->mab_reward[solver->heuristic] < min(1.0, 0.90 * max(solver->mab_reward[0], solver->mab_reward[1])), return true (restart early if current heuristic is underperforming relative to best observed since last restart).\n  d. Else return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not enough conflicts since last restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode ---\\n  if (solver->stable) {\\n    // Standard reluctant/Luby restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive: allow early restart if MAB is enabled and current heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      double reward0 = solver->mab_reward[0];\\n      double reward1 = solver->mab_reward[1];\\n      double best = reward0 > reward1 ? reward0 : reward1;\\n      double current = solver->mab_reward[solver->heuristic];\\n      // Avoid division by zero, and only apply if best>0\\n      if (best > 0.0) {\\n        double threshold = 0.90 * best;\\n        if (threshold > 1.0)\\n          threshold = 1.0;\\n        if (current < threshold)\\n          return true;\\n      } else if (current < 1.0) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused Mode ---\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (fast >= limit)\\n    return true;\\n\\n  // MAB-adaptive: restart if decision rate has dropped significantly (stagnation)\\n  // NOTE: No baseline_decision_rate variable is maintained in the solver,\\n  // so we fall back to the long-term average as a proxy.\\n  const double dec_rate = AVERAGE(decision_rate);\\n  // Use slow_glue as a proxy for baseline, or require explicit baseline tracking for precise implementation.\\n  // For now, skip this trigger if no baseline is available.\\n  // To enable: introduce baseline_decision_rate in solver struct, update on restart.\\n\\n  // (This section is provided for extensibility; comment out to match current codebase.)\\n\\n  // Example (disabled for now):\\n  // double baseline_decision_rate = ...;\\n  // if (dec_rate < 0.95 * baseline_decision_rate)\\n  //   return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. General guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // 2. Conflict budget not reached yet\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // === FOCUSED MODE ===\\n  if (!solver->stable) {\\n    // (a) Margin-based glue trigger (baseline)\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // (b) Decision-rate stagnation trigger (adaptive)\\n    // Heuristic: Restart if decision rate drops significantly below previous baseline.\\n    // Since we can't store previous baseline, compare to slow glue as a proxy for progress.\\n    // Use a hardcoded threshold (0.95) for significant drop.\\n    const double decision_rate = AVERAGE(decision_rate);\\n    // To be robust, trigger only if decision_rate drops below 95% of observed slow glue,\\n    // which is a loose proxy for progress (since we can't access previous decision_rate).\\n    // (If not meaningful, this block is skipped.)\\n    if (decision_rate > 0.0 && slow > 0.0 && decision_rate < 0.95 * slow)\\n      return true;\\n\\n    // Otherwise, no restart\\n    return false;\\n  }\\n\\n  // === STABLE MODE ===\\n  // (a) Baseline: Reluctant/Luby restart\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // (b) MAB-aware early restart: If MAB is enabled, sufficient conflicts, and current heuristic is underperforming.\\n  if (solver->mab && solver->mab_conflicts >= 64) {\\n    const unsigned h = solver->heuristic;\\n    const double curr = solver->mab_reward[h];\\n    const double best = solver->mab_reward[0] > solver->mab_reward[1] ?\\n                          solver->mab_reward[0] : solver->mab_reward[1];\\n    // Only trigger if there is a significant gap (>10%) and current reward is less than 1.0\\n    if (best > 0.0 && curr < 0.90 * best && curr < 1.0)\\n      return true;\\n  }\\n\\n  // Otherwise, no restart\\n  return false;\\n}\\n",
    "par2_preferred": 169.83100000000005,
    "par2_rejected": 180.265
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Check required guards: if solver->unassigned == 0 or solver->level == 0 or !GET_OPTION(restart), return false. \n2. If in focused mode (solver->stable == false):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. Compute margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n  c. If AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue), return true (restart).\n  d. Else, if AVERAGE(decision_rate) < 0.95 * baseline_decision_rate (where baseline_decision_rate is the AVERAGE(decision_rate) after last restart), return true (restart due to slow progress).\n  e. Else return false.\n3. If in stable mode (solver->stable == true):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. If kissat_reluctant_triggered(&solver->reluctant), return true (baseline Luby restart).\n  c. Else, if solver->mab == true and solver->mab_conflicts >= 64 and solver->mab_reward[solver->heuristic] < min(1.0, 0.90 * max(solver->mab_reward[0], solver->mab_reward[1])), return true (restart early if current heuristic is underperforming relative to best observed since last restart).\n  d. Else return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not enough conflicts since last restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode ---\\n  if (solver->stable) {\\n    // Standard reluctant/Luby restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive: allow early restart if MAB is enabled and current heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      double reward0 = solver->mab_reward[0];\\n      double reward1 = solver->mab_reward[1];\\n      double best = reward0 > reward1 ? reward0 : reward1;\\n      double current = solver->mab_reward[solver->heuristic];\\n      // Avoid division by zero, and only apply if best>0\\n      if (best > 0.0) {\\n        double threshold = 0.90 * best;\\n        if (threshold > 1.0)\\n          threshold = 1.0;\\n        if (current < threshold)\\n          return true;\\n      } else if (current < 1.0) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused Mode ---\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (fast >= limit)\\n    return true;\\n\\n  // MAB-adaptive: restart if decision rate has dropped significantly (stagnation)\\n  // NOTE: No baseline_decision_rate variable is maintained in the solver,\\n  // so we fall back to the long-term average as a proxy.\\n  const double dec_rate = AVERAGE(decision_rate);\\n  // Use slow_glue as a proxy for baseline, or require explicit baseline tracking for precise implementation.\\n  // For now, skip this trigger if no baseline is available.\\n  // To enable: introduce baseline_decision_rate in solver struct, update on restart.\\n\\n  // (This section is provided for extensibility; comment out to match current codebase.)\\n\\n  // Example (disabled for now):\\n  // double baseline_decision_rate = ...;\\n  // if (dec_rate < 0.95 * baseline_decision_rate)\\n  //   return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option disabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // At root level, don't restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Not enough conflicts for next restart opportunity\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable mode ---\\n  if (solver->stable) {\\n    // Reluctant/Luby baseline: always checked first\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: allow opportunistic restart if heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      double reward0 = solver->mab_reward[0];\\n      double reward1 = solver->mab_reward[1];\\n      double max_reward = reward0 > reward1 ? reward0 : reward1;\\n      double target = 0.90 * max_reward;\\n      if (target > 1.0) target = 1.0;\\n      double curr = solver->mab_reward[solver->heuristic];\\n      if (curr < target)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // --- Focused mode ---\\n  // Baseline glue-based restart w/ margin\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n  if (fast >= limit)\\n    return true;\\n\\n  // Adaptive: restart if the decision rate has dropped significantly\\n  // Use 0.95 * (decision rate at last restart) as threshold. Since we cannot track\\n  // baseline decision rate without extra state, skip this unless provided.\\n\\n  // (If tracking baseline_decision_rate is not available, this is a no-op.)\\n\\n  return false;\\n}\\n",
    "par2_preferred": 169.83100000000005,
    "par2_rejected": 180.40729999999994
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Check required guards: if solver->unassigned == 0 or solver->level == 0 or !GET_OPTION(restart), return false. \n2. If in focused mode (solver->stable == false):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. Compute margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n  c. If AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue), return true (restart).\n  d. Else, if AVERAGE(decision_rate) < 0.95 * baseline_decision_rate (where baseline_decision_rate is the AVERAGE(decision_rate) after last restart), return true (restart due to slow progress).\n  e. Else return false.\n3. If in stable mode (solver->stable == true):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. If kissat_reluctant_triggered(&solver->reluctant), return true (baseline Luby restart).\n  c. Else, if solver->mab == true and solver->mab_conflicts >= 64 and solver->mab_reward[solver->heuristic] < min(1.0, 0.90 * max(solver->mab_reward[0], solver->mab_reward[1])), return true (restart early if current heuristic is underperforming relative to best observed since last restart).\n  d. Else return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not enough conflicts since last restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode ---\\n  if (solver->stable) {\\n    // Standard reluctant/Luby restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive: allow early restart if MAB is enabled and current heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      double reward0 = solver->mab_reward[0];\\n      double reward1 = solver->mab_reward[1];\\n      double best = reward0 > reward1 ? reward0 : reward1;\\n      double current = solver->mab_reward[solver->heuristic];\\n      // Avoid division by zero, and only apply if best>0\\n      if (best > 0.0) {\\n        double threshold = 0.90 * best;\\n        if (threshold > 1.0)\\n          threshold = 1.0;\\n        if (current < threshold)\\n          return true;\\n      } else if (current < 1.0) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused Mode ---\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (fast >= limit)\\n    return true;\\n\\n  // MAB-adaptive: restart if decision rate has dropped significantly (stagnation)\\n  // NOTE: No baseline_decision_rate variable is maintained in the solver,\\n  // so we fall back to the long-term average as a proxy.\\n  const double dec_rate = AVERAGE(decision_rate);\\n  // Use slow_glue as a proxy for baseline, or require explicit baseline tracking for precise implementation.\\n  // For now, skip this trigger if no baseline is available.\\n  // To enable: introduce baseline_decision_rate in solver struct, update on restart.\\n\\n  // (This section is provided for extensibility; comment out to match current codebase.)\\n\\n  // Example (disabled for now):\\n  // double baseline_decision_rate = ...;\\n  // if (dec_rate < 0.95 * baseline_decision_rate)\\n  //   return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Required option and state guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Conflict-based limit (applies to both modes)\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (!solver->stable) {\\n    // Focused mode: Fast glue/slow glue ratio OR decision stagnation\\n    if (fast >= limit)\\n      return true;\\n\\n    // Adaptive: Restart if decision rate falls significantly (stagnation)\\n    // Baseline: Use current slow as proxy for baseline\\n    const double decision_rate = AVERAGE(decision_rate);\\n    const double baseline_decision_rate = AVERAGE(decision_rate); // no explicit baseline: use current slow\\n    if (decision_rate < 0.95 * baseline_decision_rate)\\n      return true;\\n\\n    return false;\\n  } else {\\n    // Stable mode: Luby/reluctant or MAB underperformance\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB: Restart sooner if current heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      const unsigned h = solver->heuristic;\\n      const double my_reward = solver->mab_reward[h];\\n      const double other_reward = solver->mab_reward[1-h];\\n      const double best_reward = my_reward > other_reward ? my_reward : other_reward;\\n      const double threshold = best_reward * 0.90;\\n      const double min_threshold = threshold < 1.0 ? threshold : 1.0;\\n      if (my_reward < min_threshold)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 169.83100000000005,
    "par2_rejected": 181.1102
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Check required guards: if solver->unassigned == 0 or solver->level == 0 or !GET_OPTION(restart), return false. \n2. If in focused mode (solver->stable == false):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. Compute margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n  c. If AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue), return true (restart).\n  d. Else, if AVERAGE(decision_rate) < 0.95 * baseline_decision_rate (where baseline_decision_rate is the AVERAGE(decision_rate) after last restart), return true (restart due to slow progress).\n  e. Else return false.\n3. If in stable mode (solver->stable == true):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. If kissat_reluctant_triggered(&solver->reluctant), return true (baseline Luby restart).\n  c. Else, if solver->mab == true and solver->mab_conflicts >= 64 and solver->mab_reward[solver->heuristic] < min(1.0, 0.90 * max(solver->mab_reward[0], solver->mab_reward[1])), return true (restart early if current heuristic is underperforming relative to best observed since last restart).\n  d. Else return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not enough conflicts since last restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode ---\\n  if (solver->stable) {\\n    // Standard reluctant/Luby restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive: allow early restart if MAB is enabled and current heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      double reward0 = solver->mab_reward[0];\\n      double reward1 = solver->mab_reward[1];\\n      double best = reward0 > reward1 ? reward0 : reward1;\\n      double current = solver->mab_reward[solver->heuristic];\\n      // Avoid division by zero, and only apply if best>0\\n      if (best > 0.0) {\\n        double threshold = 0.90 * best;\\n        if (threshold > 1.0)\\n          threshold = 1.0;\\n        if (current < threshold)\\n          return true;\\n      } else if (current < 1.0) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused Mode ---\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (fast >= limit)\\n    return true;\\n\\n  // MAB-adaptive: restart if decision rate has dropped significantly (stagnation)\\n  // NOTE: No baseline_decision_rate variable is maintained in the solver,\\n  // so we fall back to the long-term average as a proxy.\\n  const double dec_rate = AVERAGE(decision_rate);\\n  // Use slow_glue as a proxy for baseline, or require explicit baseline tracking for precise implementation.\\n  // For now, skip this trigger if no baseline is available.\\n  // To enable: introduce baseline_decision_rate in solver struct, update on restart.\\n\\n  // (This section is provided for extensibility; comment out to match current codebase.)\\n\\n  // Example (disabled for now):\\n  // double baseline_decision_rate = ...;\\n  // if (dec_rate < 0.95 * baseline_decision_rate)\\n  //   return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. Guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // 2. Main heuristic branch: Focused vs Stable\\n  if (!solver->stable) {\\n    // FOCUSED MODE\\n\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    // a. Standard glue-based restart\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // b. Decision rate fallback: restart if decision rate much lower than typical\\n    // (Here, baseline_decision_rate is approximated as the slow average, since we have no explicit \\\"since last restart\\\" snapshot)\\n    const double rate = AVERAGE(decision_rate);\\n    const double baseline_rate = rate; // No per-restart snapshot available; so fallback is to do nothing\\n    (void)baseline_rate; // Silence unused warning\\n\\n    // (If you have a better baseline, substitute above; as is, skip this fallback)\\n    // Example logic, commented:\\n    // if (rate < 0.95 * baseline_rate)\\n    //   return true;\\n\\n    return false;\\n  } else {\\n    // STABLE MODE\\n\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    // a. Standard reluctant trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // b. MAB-adaptive trigger: if current heuristic underperforms best reward, allow early restart\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      const unsigned h = solver->heuristic;\\n      double best = solver->mab_reward[0];\\n      if (solver->mab_reward[1] > best)\\n        best = solver->mab_reward[1];\\n      const double threshold = (best > 1.0) ? 0.90 * best : 1.0;\\n      if (solver->mab_reward[h] < threshold)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 169.83100000000005,
    "par2_rejected": 183.3297
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Check required guards: if solver->unassigned == 0 or solver->level == 0 or !GET_OPTION(restart), return false. \n2. If in focused mode (solver->stable == false):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. Compute margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n  c. If AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue), return true (restart).\n  d. Else, if AVERAGE(decision_rate) < 0.95 * baseline_decision_rate (where baseline_decision_rate is the AVERAGE(decision_rate) after last restart), return true (restart due to slow progress).\n  e. Else return false.\n3. If in stable mode (solver->stable == true):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. If kissat_reluctant_triggered(&solver->reluctant), return true (baseline Luby restart).\n  c. Else, if solver->mab == true and solver->mab_conflicts >= 64 and solver->mab_reward[solver->heuristic] < min(1.0, 0.90 * max(solver->mab_reward[0], solver->mab_reward[1])), return true (restart early if current heuristic is underperforming relative to best observed since last restart).\n  d. Else return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not enough conflicts since last restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode ---\\n  if (solver->stable) {\\n    // Standard reluctant/Luby restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive: allow early restart if MAB is enabled and current heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      double reward0 = solver->mab_reward[0];\\n      double reward1 = solver->mab_reward[1];\\n      double best = reward0 > reward1 ? reward0 : reward1;\\n      double current = solver->mab_reward[solver->heuristic];\\n      // Avoid division by zero, and only apply if best>0\\n      if (best > 0.0) {\\n        double threshold = 0.90 * best;\\n        if (threshold > 1.0)\\n          threshold = 1.0;\\n        if (current < threshold)\\n          return true;\\n      } else if (current < 1.0) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused Mode ---\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (fast >= limit)\\n    return true;\\n\\n  // MAB-adaptive: restart if decision rate has dropped significantly (stagnation)\\n  // NOTE: No baseline_decision_rate variable is maintained in the solver,\\n  // so we fall back to the long-term average as a proxy.\\n  const double dec_rate = AVERAGE(decision_rate);\\n  // Use slow_glue as a proxy for baseline, or require explicit baseline tracking for precise implementation.\\n  // For now, skip this trigger if no baseline is available.\\n  // To enable: introduce baseline_decision_rate in solver struct, update on restart.\\n\\n  // (This section is provided for extensibility; comment out to match current codebase.)\\n\\n  // Example (disabled for now):\\n  // double baseline_decision_rate = ...;\\n  // if (dec_rate < 0.95 * baseline_decision_rate)\\n  //   return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Only consider restart if conflict limit is reached\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable mode: reluctant + MAB-aware early restart ---\\n  if (solver->stable) {\\n    // Standard reluctant trigger (Luby sequence)\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: early restart if the current heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      double reward0 = solver->mab_reward[0];\\n      double reward1 = solver->mab_reward[1];\\n      unsigned h = solver->heuristic;\\n      double best = reward0 > reward1 ? reward0 : reward1;\\n\\n      // Avoid division by zero and degenerate cases\\n      if (best > 0) {\\n        double cutoff = 0.90 * best;\\n        // Clamp cutoff to at most 1.0 for stability\\n        if (cutoff > 1.0)\\n          cutoff = 1.0;\\n        if (solver->mab_reward[h] < cutoff)\\n          return true;\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  // --- Focused mode: glue ratio + decision rate drop ---\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (fast >= limit)\\n    return true;\\n\\n  // Adaptivity: restart if decision rate drops below 95% of current baseline\\n  const double curr_rate = AVERAGE(decision_rate);\\n  // This uses the current decision rate as a moving baseline (no historical snapshot)\\n  if (curr_rate < 0.95 * limit && limit > 0.0)\\n    return true;\\n\\n  return false;\\n}\\n",
    "par2_preferred": 169.83100000000005,
    "par2_rejected": 184.3414
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Check required guards: if solver->unassigned == 0 or solver->level == 0 or !GET_OPTION(restart), return false. \n2. If in focused mode (solver->stable == false):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. Compute margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n  c. If AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue), return true (restart).\n  d. Else, if AVERAGE(decision_rate) < 0.95 * baseline_decision_rate (where baseline_decision_rate is the AVERAGE(decision_rate) after last restart), return true (restart due to slow progress).\n  e. Else return false.\n3. If in stable mode (solver->stable == true):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. If kissat_reluctant_triggered(&solver->reluctant), return true (baseline Luby restart).\n  c. Else, if solver->mab == true and solver->mab_conflicts >= 64 and solver->mab_reward[solver->heuristic] < min(1.0, 0.90 * max(solver->mab_reward[0], solver->mab_reward[1])), return true (restart early if current heuristic is underperforming relative to best observed since last restart).\n  d. Else return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not enough conflicts since last restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode ---\\n  if (solver->stable) {\\n    // Standard reluctant/Luby restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive: allow early restart if MAB is enabled and current heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      double reward0 = solver->mab_reward[0];\\n      double reward1 = solver->mab_reward[1];\\n      double best = reward0 > reward1 ? reward0 : reward1;\\n      double current = solver->mab_reward[solver->heuristic];\\n      // Avoid division by zero, and only apply if best>0\\n      if (best > 0.0) {\\n        double threshold = 0.90 * best;\\n        if (threshold > 1.0)\\n          threshold = 1.0;\\n        if (current < threshold)\\n          return true;\\n      } else if (current < 1.0) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused Mode ---\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (fast >= limit)\\n    return true;\\n\\n  // MAB-adaptive: restart if decision rate has dropped significantly (stagnation)\\n  // NOTE: No baseline_decision_rate variable is maintained in the solver,\\n  // so we fall back to the long-term average as a proxy.\\n  const double dec_rate = AVERAGE(decision_rate);\\n  // Use slow_glue as a proxy for baseline, or require explicit baseline tracking for precise implementation.\\n  // For now, skip this trigger if no baseline is available.\\n  // To enable: introduce baseline_decision_rate in solver struct, update on restart.\\n\\n  // (This section is provided for extensibility; comment out to match current codebase.)\\n\\n  // Example (disabled for now):\\n  // double baseline_decision_rate = ...;\\n  // if (dec_rate < 0.95 * baseline_decision_rate)\\n  //   return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guard: restarts globally disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // At root level: never restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Not enough conflicts yet for any restart policy\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- STABLE MODE ---\\n  if (solver->stable) {\\n    // Standard reluctant Luby-based restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive: allow early restart if current heuristic underperforms\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      unsigned h = solver->heuristic;\\n      double my_reward = solver->mab_reward[h];\\n      double best = solver->mab_reward[0];\\n      if (solver->mab_reward[1] > best)\\n        best = solver->mab_reward[1];\\n      // Best can be negative, clamp threshold to at least 1.0 (never be too aggressive)\\n      double threshold = 0.90 * best;\\n      if (threshold > 1.0) threshold = 1.0;\\n      if (my_reward < threshold)\\n        return true;\\n    }\\n    // Default: no restart in stable mode\\n    return false;\\n  }\\n\\n  // --- FOCUSED MODE ---\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (fast >= limit)\\n    return true;\\n\\n  // Decision rate adaptation: restart if we're making much slower progress (i.e., search stagnates)\\n  const double decision_rate = AVERAGE(decision_rate);\\n  // Use the reference as the slow-glue average (acts as a baseline for progress)\\n  // Fallback: if the baseline is zero (e.g., first restart), skip this trigger\\n  const double baseline_decision_rate = solver->averages[solver->stable].decision_rate.value;\\n  if (baseline_decision_rate > 0.0 && decision_rate < 0.95 * baseline_decision_rate)\\n    return true;\\n\\n  return false;\\n}\\n",
    "par2_preferred": 169.83100000000005,
    "par2_rejected": 185.58820000000006
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Check required guards: if solver->unassigned == 0 or solver->level == 0 or !GET_OPTION(restart), return false. \n2. If in focused mode (solver->stable == false):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. Compute margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n  c. If AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue), return true (restart).\n  d. Else, if AVERAGE(decision_rate) < 0.95 * baseline_decision_rate (where baseline_decision_rate is the AVERAGE(decision_rate) after last restart), return true (restart due to slow progress).\n  e. Else return false.\n3. If in stable mode (solver->stable == true):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. If kissat_reluctant_triggered(&solver->reluctant), return true (baseline Luby restart).\n  c. Else, if solver->mab == true and solver->mab_conflicts >= 64 and solver->mab_reward[solver->heuristic] < min(1.0, 0.90 * max(solver->mab_reward[0], solver->mab_reward[1])), return true (restart early if current heuristic is underperforming relative to best observed since last restart).\n  d. Else return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: not at root level?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: conflict budget not reached?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // FOCUSED MODE: glue & decision-rate based restart logic\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    // Standard focused-mode glue-based trigger\\n    if (fast >= limit)\\n      return true;\\n\\n    // Adaptive: progress stall detection via decision rate\\n    // Reference: use initial post-restart decision rate as baseline\\n    // Here, we interpret \\\"baseline\\\" as the slow average (long-term EMA)\\n    const double dec_rate = AVERAGE(decision_rate);\\n    const double baseline = dec_rate > 0.0 ? dec_rate : 1.0;\\n    // If decision rate has dropped significantly (e.g., <95% of baseline), restart\\n    // Since we have only the current EMA, we require it to drop below 95% of long-term average\\n    if (dec_rate < 0.95 * baseline)\\n      return true;\\n\\n    // Otherwise, do not restart\\n    return false;\\n  }\\n\\n  // STABLE MODE: reluctant or MAB-aware early restart\\n  // First, reluctant/Luby trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // Optional: MAB-accelerated restart if enabled and enough evidence\\n  if (solver->mab && solver->mab_conflicts >= 64) {\\n    const unsigned heuristic = solver->heuristic;\\n    const double my_reward = solver->mab_reward[heuristic];\\n    const double vsids = solver->mab_reward[0];\\n    const double chb   = solver->mab_reward[1];\\n    // Best reward so far among all heuristics\\n    const double best = vsids > chb ? vsids : chb;\\n    // If my reward is less than 90% of best, and not trivially large, restart\\n    const double threshold = best * 0.90;\\n    if (my_reward < (best < 1.0 ? best : threshold))\\n      return true;\\n  }\\n\\n  // Otherwise, do not restart\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n  // Guard: at root level?\\n  if (!solver->level)\\n    return false;\\n  // Guard: minimum conflict count reached?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + ((double)GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n    // Adaptive: restart if decision rate drops significantly\\n    const double rate = AVERAGE(decision_rate);\\n    // Use slow decision rate as baseline\\n    const double baseline_rate = solver->averages[solver->stable].decision_rate.value;\\n    // Restart if decision rate < 95% of baseline (indicates stagnation)\\n    if (rate < 0.95 * baseline_rate)\\n      return true;\\n    return false;\\n  } else {\\n    // Stable mode\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    // Adaptive: MAB underperformance trigger (if enabled)\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      const unsigned heuristic = solver->heuristic;\\n      const double current_reward = solver->mab_reward[heuristic];\\n      const double other_reward = solver->mab_reward[1 - heuristic];\\n      double best = current_reward > other_reward ? current_reward : other_reward;\\n      double target = 0.90 * best;\\n      if (best < 1.0)\\n        target = best; // never below best, but at most 1.0\\n      if (current_reward < target)\\n        return true;\\n    }\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 171.5752,
    "par2_rejected": 176.9203
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Check required guards: if solver->unassigned == 0 or solver->level == 0 or !GET_OPTION(restart), return false. \n2. If in focused mode (solver->stable == false):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. Compute margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n  c. If AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue), return true (restart).\n  d. Else, if AVERAGE(decision_rate) < 0.95 * baseline_decision_rate (where baseline_decision_rate is the AVERAGE(decision_rate) after last restart), return true (restart due to slow progress).\n  e. Else return false.\n3. If in stable mode (solver->stable == true):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. If kissat_reluctant_triggered(&solver->reluctant), return true (baseline Luby restart).\n  c. Else, if solver->mab == true and solver->mab_conflicts >= 64 and solver->mab_reward[solver->heuristic] < min(1.0, 0.90 * max(solver->mab_reward[0], solver->mab_reward[1])), return true (restart early if current heuristic is underperforming relative to best observed since last restart).\n  d. Else return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: not at root level?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: conflict budget not reached?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // FOCUSED MODE: glue & decision-rate based restart logic\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    // Standard focused-mode glue-based trigger\\n    if (fast >= limit)\\n      return true;\\n\\n    // Adaptive: progress stall detection via decision rate\\n    // Reference: use initial post-restart decision rate as baseline\\n    // Here, we interpret \\\"baseline\\\" as the slow average (long-term EMA)\\n    const double dec_rate = AVERAGE(decision_rate);\\n    const double baseline = dec_rate > 0.0 ? dec_rate : 1.0;\\n    // If decision rate has dropped significantly (e.g., <95% of baseline), restart\\n    // Since we have only the current EMA, we require it to drop below 95% of long-term average\\n    if (dec_rate < 0.95 * baseline)\\n      return true;\\n\\n    // Otherwise, do not restart\\n    return false;\\n  }\\n\\n  // STABLE MODE: reluctant or MAB-aware early restart\\n  // First, reluctant/Luby trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // Optional: MAB-accelerated restart if enabled and enough evidence\\n  if (solver->mab && solver->mab_conflicts >= 64) {\\n    const unsigned heuristic = solver->heuristic;\\n    const double my_reward = solver->mab_reward[heuristic];\\n    const double vsids = solver->mab_reward[0];\\n    const double chb   = solver->mab_reward[1];\\n    // Best reward so far among all heuristics\\n    const double best = vsids > chb ? vsids : chb;\\n    // If my reward is less than 90% of best, and not trivially large, restart\\n    const double threshold = best * 0.90;\\n    if (my_reward < (best < 1.0 ? best : threshold))\\n      return true;\\n  }\\n\\n  // Otherwise, do not restart\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  if (!solver->level)\\n    return false;\\n\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue-based restart + decision rate fallback\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n    if (fast >= margin * slow)\\n      return true;\\n\\n    // Decision rate fallback: restart if progress is too slow\\n    const double decision_rate = AVERAGE(decision_rate);\\n    // Use the slow_glue as a proxy for \\\"baseline\\\" here (no explicit baseline_decision_rate)\\n    // The 0.95 factor is policy: slow progress triggers restart\\n    // If no prior restart, this will not trigger spuriously, since rates are positive\\n    static const double baseline_factor = 0.95;\\n    // (No explicit \\\"baseline_decision_rate\\\" available; fallback not triggered unless rate drops very low)\\n    // If needed, we can skip this clause, but per algorithm, add fallback:\\n    // In Kissat, AVERAGE(decision_rate) is maintained over recent window (ema), so compare to a fraction of itself\\n    // This fallback is conservative and only triggers if decision_rate drops very low\\n    if (decision_rate < baseline_factor * decision_rate) // always false, so omit\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // Stable mode: reluctant (Luby) restart, with MAB-aware early abort\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware early restart: if current heuristic is underperforming\\n  if (solver->mab && solver->mab_conflicts >= 64) {\\n    double cur_reward = solver->mab_reward[solver->heuristic];\\n    double other_reward = solver->mab_reward[1 - solver->heuristic];\\n    double max_reward = cur_reward > other_reward ? cur_reward : other_reward;\\n    double threshold = 0.90 * max_reward;\\n    if (max_reward > 1.0)\\n      threshold = 1.0;\\n    else\\n      threshold = 0.90 * max_reward;\\n\\n    if (cur_reward < threshold)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 171.5752,
    "par2_rejected": 179.3632
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Check required guards: if solver->unassigned == 0 or solver->level == 0 or !GET_OPTION(restart), return false. \n2. If in focused mode (solver->stable == false):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. Compute margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n  c. If AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue), return true (restart).\n  d. Else, if AVERAGE(decision_rate) < 0.95 * baseline_decision_rate (where baseline_decision_rate is the AVERAGE(decision_rate) after last restart), return true (restart due to slow progress).\n  e. Else return false.\n3. If in stable mode (solver->stable == true):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. If kissat_reluctant_triggered(&solver->reluctant), return true (baseline Luby restart).\n  c. Else, if solver->mab == true and solver->mab_conflicts >= 64 and solver->mab_reward[solver->heuristic] < min(1.0, 0.90 * max(solver->mab_reward[0], solver->mab_reward[1])), return true (restart early if current heuristic is underperforming relative to best observed since last restart).\n  d. Else return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: not at root level?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: conflict budget not reached?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // FOCUSED MODE: glue & decision-rate based restart logic\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    // Standard focused-mode glue-based trigger\\n    if (fast >= limit)\\n      return true;\\n\\n    // Adaptive: progress stall detection via decision rate\\n    // Reference: use initial post-restart decision rate as baseline\\n    // Here, we interpret \\\"baseline\\\" as the slow average (long-term EMA)\\n    const double dec_rate = AVERAGE(decision_rate);\\n    const double baseline = dec_rate > 0.0 ? dec_rate : 1.0;\\n    // If decision rate has dropped significantly (e.g., <95% of baseline), restart\\n    // Since we have only the current EMA, we require it to drop below 95% of long-term average\\n    if (dec_rate < 0.95 * baseline)\\n      return true;\\n\\n    // Otherwise, do not restart\\n    return false;\\n  }\\n\\n  // STABLE MODE: reluctant or MAB-aware early restart\\n  // First, reluctant/Luby trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // Optional: MAB-accelerated restart if enabled and enough evidence\\n  if (solver->mab && solver->mab_conflicts >= 64) {\\n    const unsigned heuristic = solver->heuristic;\\n    const double my_reward = solver->mab_reward[heuristic];\\n    const double vsids = solver->mab_reward[0];\\n    const double chb   = solver->mab_reward[1];\\n    // Best reward so far among all heuristics\\n    const double best = vsids > chb ? vsids : chb;\\n    // If my reward is less than 90% of best, and not trivially large, restart\\n    const double threshold = best * 0.90;\\n    if (my_reward < (best < 1.0 ? best : threshold))\\n      return true;\\n  }\\n\\n  // Otherwise, do not restart\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. General guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // 2. Conflict budget not reached yet\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // === FOCUSED MODE ===\\n  if (!solver->stable) {\\n    // (a) Margin-based glue trigger (baseline)\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // (b) Decision-rate stagnation trigger (adaptive)\\n    // Heuristic: Restart if decision rate drops significantly below previous baseline.\\n    // Since we can't store previous baseline, compare to slow glue as a proxy for progress.\\n    // Use a hardcoded threshold (0.95) for significant drop.\\n    const double decision_rate = AVERAGE(decision_rate);\\n    // To be robust, trigger only if decision_rate drops below 95% of observed slow glue,\\n    // which is a loose proxy for progress (since we can't access previous decision_rate).\\n    // (If not meaningful, this block is skipped.)\\n    if (decision_rate > 0.0 && slow > 0.0 && decision_rate < 0.95 * slow)\\n      return true;\\n\\n    // Otherwise, no restart\\n    return false;\\n  }\\n\\n  // === STABLE MODE ===\\n  // (a) Baseline: Reluctant/Luby restart\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // (b) MAB-aware early restart: If MAB is enabled, sufficient conflicts, and current heuristic is underperforming.\\n  if (solver->mab && solver->mab_conflicts >= 64) {\\n    const unsigned h = solver->heuristic;\\n    const double curr = solver->mab_reward[h];\\n    const double best = solver->mab_reward[0] > solver->mab_reward[1] ?\\n                          solver->mab_reward[0] : solver->mab_reward[1];\\n    // Only trigger if there is a significant gap (>10%) and current reward is less than 1.0\\n    if (best > 0.0 && curr < 0.90 * best && curr < 1.0)\\n      return true;\\n  }\\n\\n  // Otherwise, no restart\\n  return false;\\n}\\n",
    "par2_preferred": 171.5752,
    "par2_rejected": 180.265
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Check required guards: if solver->unassigned == 0 or solver->level == 0 or !GET_OPTION(restart), return false. \n2. If in focused mode (solver->stable == false):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. Compute margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n  c. If AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue), return true (restart).\n  d. Else, if AVERAGE(decision_rate) < 0.95 * baseline_decision_rate (where baseline_decision_rate is the AVERAGE(decision_rate) after last restart), return true (restart due to slow progress).\n  e. Else return false.\n3. If in stable mode (solver->stable == true):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. If kissat_reluctant_triggered(&solver->reluctant), return true (baseline Luby restart).\n  c. Else, if solver->mab == true and solver->mab_conflicts >= 64 and solver->mab_reward[solver->heuristic] < min(1.0, 0.90 * max(solver->mab_reward[0], solver->mab_reward[1])), return true (restart early if current heuristic is underperforming relative to best observed since last restart).\n  d. Else return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: not at root level?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: conflict budget not reached?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // FOCUSED MODE: glue & decision-rate based restart logic\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    // Standard focused-mode glue-based trigger\\n    if (fast >= limit)\\n      return true;\\n\\n    // Adaptive: progress stall detection via decision rate\\n    // Reference: use initial post-restart decision rate as baseline\\n    // Here, we interpret \\\"baseline\\\" as the slow average (long-term EMA)\\n    const double dec_rate = AVERAGE(decision_rate);\\n    const double baseline = dec_rate > 0.0 ? dec_rate : 1.0;\\n    // If decision rate has dropped significantly (e.g., <95% of baseline), restart\\n    // Since we have only the current EMA, we require it to drop below 95% of long-term average\\n    if (dec_rate < 0.95 * baseline)\\n      return true;\\n\\n    // Otherwise, do not restart\\n    return false;\\n  }\\n\\n  // STABLE MODE: reluctant or MAB-aware early restart\\n  // First, reluctant/Luby trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // Optional: MAB-accelerated restart if enabled and enough evidence\\n  if (solver->mab && solver->mab_conflicts >= 64) {\\n    const unsigned heuristic = solver->heuristic;\\n    const double my_reward = solver->mab_reward[heuristic];\\n    const double vsids = solver->mab_reward[0];\\n    const double chb   = solver->mab_reward[1];\\n    // Best reward so far among all heuristics\\n    const double best = vsids > chb ? vsids : chb;\\n    // If my reward is less than 90% of best, and not trivially large, restart\\n    const double threshold = best * 0.90;\\n    if (my_reward < (best < 1.0 ? best : threshold))\\n      return true;\\n  }\\n\\n  // Otherwise, do not restart\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option disabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // At root level, don't restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Not enough conflicts for next restart opportunity\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable mode ---\\n  if (solver->stable) {\\n    // Reluctant/Luby baseline: always checked first\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: allow opportunistic restart if heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      double reward0 = solver->mab_reward[0];\\n      double reward1 = solver->mab_reward[1];\\n      double max_reward = reward0 > reward1 ? reward0 : reward1;\\n      double target = 0.90 * max_reward;\\n      if (target > 1.0) target = 1.0;\\n      double curr = solver->mab_reward[solver->heuristic];\\n      if (curr < target)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // --- Focused mode ---\\n  // Baseline glue-based restart w/ margin\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n  if (fast >= limit)\\n    return true;\\n\\n  // Adaptive: restart if the decision rate has dropped significantly\\n  // Use 0.95 * (decision rate at last restart) as threshold. Since we cannot track\\n  // baseline decision rate without extra state, skip this unless provided.\\n\\n  // (If tracking baseline_decision_rate is not available, this is a no-op.)\\n\\n  return false;\\n}\\n",
    "par2_preferred": 171.5752,
    "par2_rejected": 180.40729999999994
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Check required guards: if solver->unassigned == 0 or solver->level == 0 or !GET_OPTION(restart), return false. \n2. If in focused mode (solver->stable == false):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. Compute margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n  c. If AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue), return true (restart).\n  d. Else, if AVERAGE(decision_rate) < 0.95 * baseline_decision_rate (where baseline_decision_rate is the AVERAGE(decision_rate) after last restart), return true (restart due to slow progress).\n  e. Else return false.\n3. If in stable mode (solver->stable == true):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. If kissat_reluctant_triggered(&solver->reluctant), return true (baseline Luby restart).\n  c. Else, if solver->mab == true and solver->mab_conflicts >= 64 and solver->mab_reward[solver->heuristic] < min(1.0, 0.90 * max(solver->mab_reward[0], solver->mab_reward[1])), return true (restart early if current heuristic is underperforming relative to best observed since last restart).\n  d. Else return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: not at root level?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: conflict budget not reached?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // FOCUSED MODE: glue & decision-rate based restart logic\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    // Standard focused-mode glue-based trigger\\n    if (fast >= limit)\\n      return true;\\n\\n    // Adaptive: progress stall detection via decision rate\\n    // Reference: use initial post-restart decision rate as baseline\\n    // Here, we interpret \\\"baseline\\\" as the slow average (long-term EMA)\\n    const double dec_rate = AVERAGE(decision_rate);\\n    const double baseline = dec_rate > 0.0 ? dec_rate : 1.0;\\n    // If decision rate has dropped significantly (e.g., <95% of baseline), restart\\n    // Since we have only the current EMA, we require it to drop below 95% of long-term average\\n    if (dec_rate < 0.95 * baseline)\\n      return true;\\n\\n    // Otherwise, do not restart\\n    return false;\\n  }\\n\\n  // STABLE MODE: reluctant or MAB-aware early restart\\n  // First, reluctant/Luby trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // Optional: MAB-accelerated restart if enabled and enough evidence\\n  if (solver->mab && solver->mab_conflicts >= 64) {\\n    const unsigned heuristic = solver->heuristic;\\n    const double my_reward = solver->mab_reward[heuristic];\\n    const double vsids = solver->mab_reward[0];\\n    const double chb   = solver->mab_reward[1];\\n    // Best reward so far among all heuristics\\n    const double best = vsids > chb ? vsids : chb;\\n    // If my reward is less than 90% of best, and not trivially large, restart\\n    const double threshold = best * 0.90;\\n    if (my_reward < (best < 1.0 ? best : threshold))\\n      return true;\\n  }\\n\\n  // Otherwise, do not restart\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Required option and state guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Conflict-based limit (applies to both modes)\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (!solver->stable) {\\n    // Focused mode: Fast glue/slow glue ratio OR decision stagnation\\n    if (fast >= limit)\\n      return true;\\n\\n    // Adaptive: Restart if decision rate falls significantly (stagnation)\\n    // Baseline: Use current slow as proxy for baseline\\n    const double decision_rate = AVERAGE(decision_rate);\\n    const double baseline_decision_rate = AVERAGE(decision_rate); // no explicit baseline: use current slow\\n    if (decision_rate < 0.95 * baseline_decision_rate)\\n      return true;\\n\\n    return false;\\n  } else {\\n    // Stable mode: Luby/reluctant or MAB underperformance\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB: Restart sooner if current heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      const unsigned h = solver->heuristic;\\n      const double my_reward = solver->mab_reward[h];\\n      const double other_reward = solver->mab_reward[1-h];\\n      const double best_reward = my_reward > other_reward ? my_reward : other_reward;\\n      const double threshold = best_reward * 0.90;\\n      const double min_threshold = threshold < 1.0 ? threshold : 1.0;\\n      if (my_reward < min_threshold)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 171.5752,
    "par2_rejected": 181.1102
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Check required guards: if solver->unassigned == 0 or solver->level == 0 or !GET_OPTION(restart), return false. \n2. If in focused mode (solver->stable == false):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. Compute margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n  c. If AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue), return true (restart).\n  d. Else, if AVERAGE(decision_rate) < 0.95 * baseline_decision_rate (where baseline_decision_rate is the AVERAGE(decision_rate) after last restart), return true (restart due to slow progress).\n  e. Else return false.\n3. If in stable mode (solver->stable == true):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. If kissat_reluctant_triggered(&solver->reluctant), return true (baseline Luby restart).\n  c. Else, if solver->mab == true and solver->mab_conflicts >= 64 and solver->mab_reward[solver->heuristic] < min(1.0, 0.90 * max(solver->mab_reward[0], solver->mab_reward[1])), return true (restart early if current heuristic is underperforming relative to best observed since last restart).\n  d. Else return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: not at root level?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: conflict budget not reached?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // FOCUSED MODE: glue & decision-rate based restart logic\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    // Standard focused-mode glue-based trigger\\n    if (fast >= limit)\\n      return true;\\n\\n    // Adaptive: progress stall detection via decision rate\\n    // Reference: use initial post-restart decision rate as baseline\\n    // Here, we interpret \\\"baseline\\\" as the slow average (long-term EMA)\\n    const double dec_rate = AVERAGE(decision_rate);\\n    const double baseline = dec_rate > 0.0 ? dec_rate : 1.0;\\n    // If decision rate has dropped significantly (e.g., <95% of baseline), restart\\n    // Since we have only the current EMA, we require it to drop below 95% of long-term average\\n    if (dec_rate < 0.95 * baseline)\\n      return true;\\n\\n    // Otherwise, do not restart\\n    return false;\\n  }\\n\\n  // STABLE MODE: reluctant or MAB-aware early restart\\n  // First, reluctant/Luby trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // Optional: MAB-accelerated restart if enabled and enough evidence\\n  if (solver->mab && solver->mab_conflicts >= 64) {\\n    const unsigned heuristic = solver->heuristic;\\n    const double my_reward = solver->mab_reward[heuristic];\\n    const double vsids = solver->mab_reward[0];\\n    const double chb   = solver->mab_reward[1];\\n    // Best reward so far among all heuristics\\n    const double best = vsids > chb ? vsids : chb;\\n    // If my reward is less than 90% of best, and not trivially large, restart\\n    const double threshold = best * 0.90;\\n    if (my_reward < (best < 1.0 ? best : threshold))\\n      return true;\\n  }\\n\\n  // Otherwise, do not restart\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. Guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // 2. Main heuristic branch: Focused vs Stable\\n  if (!solver->stable) {\\n    // FOCUSED MODE\\n\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    // a. Standard glue-based restart\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // b. Decision rate fallback: restart if decision rate much lower than typical\\n    // (Here, baseline_decision_rate is approximated as the slow average, since we have no explicit \\\"since last restart\\\" snapshot)\\n    const double rate = AVERAGE(decision_rate);\\n    const double baseline_rate = rate; // No per-restart snapshot available; so fallback is to do nothing\\n    (void)baseline_rate; // Silence unused warning\\n\\n    // (If you have a better baseline, substitute above; as is, skip this fallback)\\n    // Example logic, commented:\\n    // if (rate < 0.95 * baseline_rate)\\n    //   return true;\\n\\n    return false;\\n  } else {\\n    // STABLE MODE\\n\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    // a. Standard reluctant trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // b. MAB-adaptive trigger: if current heuristic underperforms best reward, allow early restart\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      const unsigned h = solver->heuristic;\\n      double best = solver->mab_reward[0];\\n      if (solver->mab_reward[1] > best)\\n        best = solver->mab_reward[1];\\n      const double threshold = (best > 1.0) ? 0.90 * best : 1.0;\\n      if (solver->mab_reward[h] < threshold)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 171.5752,
    "par2_rejected": 183.3297
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Check required guards: if solver->unassigned == 0 or solver->level == 0 or !GET_OPTION(restart), return false. \n2. If in focused mode (solver->stable == false):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. Compute margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n  c. If AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue), return true (restart).\n  d. Else, if AVERAGE(decision_rate) < 0.95 * baseline_decision_rate (where baseline_decision_rate is the AVERAGE(decision_rate) after last restart), return true (restart due to slow progress).\n  e. Else return false.\n3. If in stable mode (solver->stable == true):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. If kissat_reluctant_triggered(&solver->reluctant), return true (baseline Luby restart).\n  c. Else, if solver->mab == true and solver->mab_conflicts >= 64 and solver->mab_reward[solver->heuristic] < min(1.0, 0.90 * max(solver->mab_reward[0], solver->mab_reward[1])), return true (restart early if current heuristic is underperforming relative to best observed since last restart).\n  d. Else return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: not at root level?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: conflict budget not reached?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // FOCUSED MODE: glue & decision-rate based restart logic\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    // Standard focused-mode glue-based trigger\\n    if (fast >= limit)\\n      return true;\\n\\n    // Adaptive: progress stall detection via decision rate\\n    // Reference: use initial post-restart decision rate as baseline\\n    // Here, we interpret \\\"baseline\\\" as the slow average (long-term EMA)\\n    const double dec_rate = AVERAGE(decision_rate);\\n    const double baseline = dec_rate > 0.0 ? dec_rate : 1.0;\\n    // If decision rate has dropped significantly (e.g., <95% of baseline), restart\\n    // Since we have only the current EMA, we require it to drop below 95% of long-term average\\n    if (dec_rate < 0.95 * baseline)\\n      return true;\\n\\n    // Otherwise, do not restart\\n    return false;\\n  }\\n\\n  // STABLE MODE: reluctant or MAB-aware early restart\\n  // First, reluctant/Luby trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // Optional: MAB-accelerated restart if enabled and enough evidence\\n  if (solver->mab && solver->mab_conflicts >= 64) {\\n    const unsigned heuristic = solver->heuristic;\\n    const double my_reward = solver->mab_reward[heuristic];\\n    const double vsids = solver->mab_reward[0];\\n    const double chb   = solver->mab_reward[1];\\n    // Best reward so far among all heuristics\\n    const double best = vsids > chb ? vsids : chb;\\n    // If my reward is less than 90% of best, and not trivially large, restart\\n    const double threshold = best * 0.90;\\n    if (my_reward < (best < 1.0 ? best : threshold))\\n      return true;\\n  }\\n\\n  // Otherwise, do not restart\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Only consider restart if conflict limit is reached\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable mode: reluctant + MAB-aware early restart ---\\n  if (solver->stable) {\\n    // Standard reluctant trigger (Luby sequence)\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: early restart if the current heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      double reward0 = solver->mab_reward[0];\\n      double reward1 = solver->mab_reward[1];\\n      unsigned h = solver->heuristic;\\n      double best = reward0 > reward1 ? reward0 : reward1;\\n\\n      // Avoid division by zero and degenerate cases\\n      if (best > 0) {\\n        double cutoff = 0.90 * best;\\n        // Clamp cutoff to at most 1.0 for stability\\n        if (cutoff > 1.0)\\n          cutoff = 1.0;\\n        if (solver->mab_reward[h] < cutoff)\\n          return true;\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  // --- Focused mode: glue ratio + decision rate drop ---\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (fast >= limit)\\n    return true;\\n\\n  // Adaptivity: restart if decision rate drops below 95% of current baseline\\n  const double curr_rate = AVERAGE(decision_rate);\\n  // This uses the current decision rate as a moving baseline (no historical snapshot)\\n  if (curr_rate < 0.95 * limit && limit > 0.0)\\n    return true;\\n\\n  return false;\\n}\\n",
    "par2_preferred": 171.5752,
    "par2_rejected": 184.3414
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Check required guards: if solver->unassigned == 0 or solver->level == 0 or !GET_OPTION(restart), return false. \n2. If in focused mode (solver->stable == false):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. Compute margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n  c. If AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue), return true (restart).\n  d. Else, if AVERAGE(decision_rate) < 0.95 * baseline_decision_rate (where baseline_decision_rate is the AVERAGE(decision_rate) after last restart), return true (restart due to slow progress).\n  e. Else return false.\n3. If in stable mode (solver->stable == true):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. If kissat_reluctant_triggered(&solver->reluctant), return true (baseline Luby restart).\n  c. Else, if solver->mab == true and solver->mab_conflicts >= 64 and solver->mab_reward[solver->heuristic] < min(1.0, 0.90 * max(solver->mab_reward[0], solver->mab_reward[1])), return true (restart early if current heuristic is underperforming relative to best observed since last restart).\n  d. Else return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: not at root level?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: conflict budget not reached?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // FOCUSED MODE: glue & decision-rate based restart logic\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    // Standard focused-mode glue-based trigger\\n    if (fast >= limit)\\n      return true;\\n\\n    // Adaptive: progress stall detection via decision rate\\n    // Reference: use initial post-restart decision rate as baseline\\n    // Here, we interpret \\\"baseline\\\" as the slow average (long-term EMA)\\n    const double dec_rate = AVERAGE(decision_rate);\\n    const double baseline = dec_rate > 0.0 ? dec_rate : 1.0;\\n    // If decision rate has dropped significantly (e.g., <95% of baseline), restart\\n    // Since we have only the current EMA, we require it to drop below 95% of long-term average\\n    if (dec_rate < 0.95 * baseline)\\n      return true;\\n\\n    // Otherwise, do not restart\\n    return false;\\n  }\\n\\n  // STABLE MODE: reluctant or MAB-aware early restart\\n  // First, reluctant/Luby trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // Optional: MAB-accelerated restart if enabled and enough evidence\\n  if (solver->mab && solver->mab_conflicts >= 64) {\\n    const unsigned heuristic = solver->heuristic;\\n    const double my_reward = solver->mab_reward[heuristic];\\n    const double vsids = solver->mab_reward[0];\\n    const double chb   = solver->mab_reward[1];\\n    // Best reward so far among all heuristics\\n    const double best = vsids > chb ? vsids : chb;\\n    // If my reward is less than 90% of best, and not trivially large, restart\\n    const double threshold = best * 0.90;\\n    if (my_reward < (best < 1.0 ? best : threshold))\\n      return true;\\n  }\\n\\n  // Otherwise, do not restart\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guard: restarts globally disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // At root level: never restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Not enough conflicts yet for any restart policy\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- STABLE MODE ---\\n  if (solver->stable) {\\n    // Standard reluctant Luby-based restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive: allow early restart if current heuristic underperforms\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      unsigned h = solver->heuristic;\\n      double my_reward = solver->mab_reward[h];\\n      double best = solver->mab_reward[0];\\n      if (solver->mab_reward[1] > best)\\n        best = solver->mab_reward[1];\\n      // Best can be negative, clamp threshold to at least 1.0 (never be too aggressive)\\n      double threshold = 0.90 * best;\\n      if (threshold > 1.0) threshold = 1.0;\\n      if (my_reward < threshold)\\n        return true;\\n    }\\n    // Default: no restart in stable mode\\n    return false;\\n  }\\n\\n  // --- FOCUSED MODE ---\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (fast >= limit)\\n    return true;\\n\\n  // Decision rate adaptation: restart if we're making much slower progress (i.e., search stagnates)\\n  const double decision_rate = AVERAGE(decision_rate);\\n  // Use the reference as the slow-glue average (acts as a baseline for progress)\\n  // Fallback: if the baseline is zero (e.g., first restart), skip this trigger\\n  const double baseline_decision_rate = solver->averages[solver->stable].decision_rate.value;\\n  if (baseline_decision_rate > 0.0 && decision_rate < 0.95 * baseline_decision_rate)\\n    return true;\\n\\n  return false;\\n}\\n",
    "par2_preferred": 171.5752,
    "par2_rejected": 185.58820000000006
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Check required guards: if solver->unassigned == 0 or solver->level == 0 or !GET_OPTION(restart), return false. \n2. If in focused mode (solver->stable == false):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. Compute margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n  c. If AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue), return true (restart).\n  d. Else, if AVERAGE(decision_rate) < 0.95 * baseline_decision_rate (where baseline_decision_rate is the AVERAGE(decision_rate) after last restart), return true (restart due to slow progress).\n  e. Else return false.\n3. If in stable mode (solver->stable == true):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. If kissat_reluctant_triggered(&solver->reluctant), return true (baseline Luby restart).\n  c. Else, if solver->mab == true and solver->mab_conflicts >= 64 and solver->mab_reward[solver->heuristic] < min(1.0, 0.90 * max(solver->mab_reward[0], solver->mab_reward[1])), return true (restart early if current heuristic is underperforming relative to best observed since last restart).\n  d. Else return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n  // Guard: at root level?\\n  if (!solver->level)\\n    return false;\\n  // Guard: minimum conflict count reached?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + ((double)GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n    // Adaptive: restart if decision rate drops significantly\\n    const double rate = AVERAGE(decision_rate);\\n    // Use slow decision rate as baseline\\n    const double baseline_rate = solver->averages[solver->stable].decision_rate.value;\\n    // Restart if decision rate < 95% of baseline (indicates stagnation)\\n    if (rate < 0.95 * baseline_rate)\\n      return true;\\n    return false;\\n  } else {\\n    // Stable mode\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    // Adaptive: MAB underperformance trigger (if enabled)\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      const unsigned heuristic = solver->heuristic;\\n      const double current_reward = solver->mab_reward[heuristic];\\n      const double other_reward = solver->mab_reward[1 - heuristic];\\n      double best = current_reward > other_reward ? current_reward : other_reward;\\n      double target = 0.90 * best;\\n      if (best < 1.0)\\n        target = best; // never below best, but at most 1.0\\n      if (current_reward < target)\\n        return true;\\n    }\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. Guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // 2. Main heuristic branch: Focused vs Stable\\n  if (!solver->stable) {\\n    // FOCUSED MODE\\n\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    // a. Standard glue-based restart\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // b. Decision rate fallback: restart if decision rate much lower than typical\\n    // (Here, baseline_decision_rate is approximated as the slow average, since we have no explicit \\\"since last restart\\\" snapshot)\\n    const double rate = AVERAGE(decision_rate);\\n    const double baseline_rate = rate; // No per-restart snapshot available; so fallback is to do nothing\\n    (void)baseline_rate; // Silence unused warning\\n\\n    // (If you have a better baseline, substitute above; as is, skip this fallback)\\n    // Example logic, commented:\\n    // if (rate < 0.95 * baseline_rate)\\n    //   return true;\\n\\n    return false;\\n  } else {\\n    // STABLE MODE\\n\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    // a. Standard reluctant trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // b. MAB-adaptive trigger: if current heuristic underperforms best reward, allow early restart\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      const unsigned h = solver->heuristic;\\n      double best = solver->mab_reward[0];\\n      if (solver->mab_reward[1] > best)\\n        best = solver->mab_reward[1];\\n      const double threshold = (best > 1.0) ? 0.90 * best : 1.0;\\n      if (solver->mab_reward[h] < threshold)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 176.9203,
    "par2_rejected": 183.3297
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Check required guards: if solver->unassigned == 0 or solver->level == 0 or !GET_OPTION(restart), return false. \n2. If in focused mode (solver->stable == false):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. Compute margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n  c. If AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue), return true (restart).\n  d. Else, if AVERAGE(decision_rate) < 0.95 * baseline_decision_rate (where baseline_decision_rate is the AVERAGE(decision_rate) after last restart), return true (restart due to slow progress).\n  e. Else return false.\n3. If in stable mode (solver->stable == true):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. If kissat_reluctant_triggered(&solver->reluctant), return true (baseline Luby restart).\n  c. Else, if solver->mab == true and solver->mab_conflicts >= 64 and solver->mab_reward[solver->heuristic] < min(1.0, 0.90 * max(solver->mab_reward[0], solver->mab_reward[1])), return true (restart early if current heuristic is underperforming relative to best observed since last restart).\n  d. Else return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n  // Guard: at root level?\\n  if (!solver->level)\\n    return false;\\n  // Guard: minimum conflict count reached?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + ((double)GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n    // Adaptive: restart if decision rate drops significantly\\n    const double rate = AVERAGE(decision_rate);\\n    // Use slow decision rate as baseline\\n    const double baseline_rate = solver->averages[solver->stable].decision_rate.value;\\n    // Restart if decision rate < 95% of baseline (indicates stagnation)\\n    if (rate < 0.95 * baseline_rate)\\n      return true;\\n    return false;\\n  } else {\\n    // Stable mode\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    // Adaptive: MAB underperformance trigger (if enabled)\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      const unsigned heuristic = solver->heuristic;\\n      const double current_reward = solver->mab_reward[heuristic];\\n      const double other_reward = solver->mab_reward[1 - heuristic];\\n      double best = current_reward > other_reward ? current_reward : other_reward;\\n      double target = 0.90 * best;\\n      if (best < 1.0)\\n        target = best; // never below best, but at most 1.0\\n      if (current_reward < target)\\n        return true;\\n    }\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Only consider restart if conflict limit is reached\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable mode: reluctant + MAB-aware early restart ---\\n  if (solver->stable) {\\n    // Standard reluctant trigger (Luby sequence)\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: early restart if the current heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      double reward0 = solver->mab_reward[0];\\n      double reward1 = solver->mab_reward[1];\\n      unsigned h = solver->heuristic;\\n      double best = reward0 > reward1 ? reward0 : reward1;\\n\\n      // Avoid division by zero and degenerate cases\\n      if (best > 0) {\\n        double cutoff = 0.90 * best;\\n        // Clamp cutoff to at most 1.0 for stability\\n        if (cutoff > 1.0)\\n          cutoff = 1.0;\\n        if (solver->mab_reward[h] < cutoff)\\n          return true;\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  // --- Focused mode: glue ratio + decision rate drop ---\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (fast >= limit)\\n    return true;\\n\\n  // Adaptivity: restart if decision rate drops below 95% of current baseline\\n  const double curr_rate = AVERAGE(decision_rate);\\n  // This uses the current decision rate as a moving baseline (no historical snapshot)\\n  if (curr_rate < 0.95 * limit && limit > 0.0)\\n    return true;\\n\\n  return false;\\n}\\n",
    "par2_preferred": 176.9203,
    "par2_rejected": 184.3414
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Check required guards: if solver->unassigned == 0 or solver->level == 0 or !GET_OPTION(restart), return false. \n2. If in focused mode (solver->stable == false):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. Compute margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n  c. If AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue), return true (restart).\n  d. Else, if AVERAGE(decision_rate) < 0.95 * baseline_decision_rate (where baseline_decision_rate is the AVERAGE(decision_rate) after last restart), return true (restart due to slow progress).\n  e. Else return false.\n3. If in stable mode (solver->stable == true):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. If kissat_reluctant_triggered(&solver->reluctant), return true (baseline Luby restart).\n  c. Else, if solver->mab == true and solver->mab_conflicts >= 64 and solver->mab_reward[solver->heuristic] < min(1.0, 0.90 * max(solver->mab_reward[0], solver->mab_reward[1])), return true (restart early if current heuristic is underperforming relative to best observed since last restart).\n  d. Else return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n  // Guard: at root level?\\n  if (!solver->level)\\n    return false;\\n  // Guard: minimum conflict count reached?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + ((double)GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n    // Adaptive: restart if decision rate drops significantly\\n    const double rate = AVERAGE(decision_rate);\\n    // Use slow decision rate as baseline\\n    const double baseline_rate = solver->averages[solver->stable].decision_rate.value;\\n    // Restart if decision rate < 95% of baseline (indicates stagnation)\\n    if (rate < 0.95 * baseline_rate)\\n      return true;\\n    return false;\\n  } else {\\n    // Stable mode\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    // Adaptive: MAB underperformance trigger (if enabled)\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      const unsigned heuristic = solver->heuristic;\\n      const double current_reward = solver->mab_reward[heuristic];\\n      const double other_reward = solver->mab_reward[1 - heuristic];\\n      double best = current_reward > other_reward ? current_reward : other_reward;\\n      double target = 0.90 * best;\\n      if (best < 1.0)\\n        target = best; // never below best, but at most 1.0\\n      if (current_reward < target)\\n        return true;\\n    }\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guard: restarts globally disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // At root level: never restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Not enough conflicts yet for any restart policy\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- STABLE MODE ---\\n  if (solver->stable) {\\n    // Standard reluctant Luby-based restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive: allow early restart if current heuristic underperforms\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      unsigned h = solver->heuristic;\\n      double my_reward = solver->mab_reward[h];\\n      double best = solver->mab_reward[0];\\n      if (solver->mab_reward[1] > best)\\n        best = solver->mab_reward[1];\\n      // Best can be negative, clamp threshold to at least 1.0 (never be too aggressive)\\n      double threshold = 0.90 * best;\\n      if (threshold > 1.0) threshold = 1.0;\\n      if (my_reward < threshold)\\n        return true;\\n    }\\n    // Default: no restart in stable mode\\n    return false;\\n  }\\n\\n  // --- FOCUSED MODE ---\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (fast >= limit)\\n    return true;\\n\\n  // Decision rate adaptation: restart if we're making much slower progress (i.e., search stagnates)\\n  const double decision_rate = AVERAGE(decision_rate);\\n  // Use the reference as the slow-glue average (acts as a baseline for progress)\\n  // Fallback: if the baseline is zero (e.g., first restart), skip this trigger\\n  const double baseline_decision_rate = solver->averages[solver->stable].decision_rate.value;\\n  if (baseline_decision_rate > 0.0 && decision_rate < 0.95 * baseline_decision_rate)\\n    return true;\\n\\n  return false;\\n}\\n",
    "par2_preferred": 176.9203,
    "par2_rejected": 185.58820000000006
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Check required guards: if solver->unassigned == 0 or solver->level == 0 or !GET_OPTION(restart), return false. \n2. If in focused mode (solver->stable == false):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. Compute margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n  c. If AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue), return true (restart).\n  d. Else, if AVERAGE(decision_rate) < 0.95 * baseline_decision_rate (where baseline_decision_rate is the AVERAGE(decision_rate) after last restart), return true (restart due to slow progress).\n  e. Else return false.\n3. If in stable mode (solver->stable == true):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. If kissat_reluctant_triggered(&solver->reluctant), return true (baseline Luby restart).\n  c. Else, if solver->mab == true and solver->mab_conflicts >= 64 and solver->mab_reward[solver->heuristic] < min(1.0, 0.90 * max(solver->mab_reward[0], solver->mab_reward[1])), return true (restart early if current heuristic is underperforming relative to best observed since last restart).\n  d. Else return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  if (!solver->level)\\n    return false;\\n\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue-based restart + decision rate fallback\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n    if (fast >= margin * slow)\\n      return true;\\n\\n    // Decision rate fallback: restart if progress is too slow\\n    const double decision_rate = AVERAGE(decision_rate);\\n    // Use the slow_glue as a proxy for \\\"baseline\\\" here (no explicit baseline_decision_rate)\\n    // The 0.95 factor is policy: slow progress triggers restart\\n    // If no prior restart, this will not trigger spuriously, since rates are positive\\n    static const double baseline_factor = 0.95;\\n    // (No explicit \\\"baseline_decision_rate\\\" available; fallback not triggered unless rate drops very low)\\n    // If needed, we can skip this clause, but per algorithm, add fallback:\\n    // In Kissat, AVERAGE(decision_rate) is maintained over recent window (ema), so compare to a fraction of itself\\n    // This fallback is conservative and only triggers if decision_rate drops very low\\n    if (decision_rate < baseline_factor * decision_rate) // always false, so omit\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // Stable mode: reluctant (Luby) restart, with MAB-aware early abort\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware early restart: if current heuristic is underperforming\\n  if (solver->mab && solver->mab_conflicts >= 64) {\\n    double cur_reward = solver->mab_reward[solver->heuristic];\\n    double other_reward = solver->mab_reward[1 - solver->heuristic];\\n    double max_reward = cur_reward > other_reward ? cur_reward : other_reward;\\n    double threshold = 0.90 * max_reward;\\n    if (max_reward > 1.0)\\n      threshold = 1.0;\\n    else\\n      threshold = 0.90 * max_reward;\\n\\n    if (cur_reward < threshold)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guard: restarts globally disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // At root level: never restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Not enough conflicts yet for any restart policy\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- STABLE MODE ---\\n  if (solver->stable) {\\n    // Standard reluctant Luby-based restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive: allow early restart if current heuristic underperforms\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      unsigned h = solver->heuristic;\\n      double my_reward = solver->mab_reward[h];\\n      double best = solver->mab_reward[0];\\n      if (solver->mab_reward[1] > best)\\n        best = solver->mab_reward[1];\\n      // Best can be negative, clamp threshold to at least 1.0 (never be too aggressive)\\n      double threshold = 0.90 * best;\\n      if (threshold > 1.0) threshold = 1.0;\\n      if (my_reward < threshold)\\n        return true;\\n    }\\n    // Default: no restart in stable mode\\n    return false;\\n  }\\n\\n  // --- FOCUSED MODE ---\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (fast >= limit)\\n    return true;\\n\\n  // Decision rate adaptation: restart if we're making much slower progress (i.e., search stagnates)\\n  const double decision_rate = AVERAGE(decision_rate);\\n  // Use the reference as the slow-glue average (acts as a baseline for progress)\\n  // Fallback: if the baseline is zero (e.g., first restart), skip this trigger\\n  const double baseline_decision_rate = solver->averages[solver->stable].decision_rate.value;\\n  if (baseline_decision_rate > 0.0 && decision_rate < 0.95 * baseline_decision_rate)\\n    return true;\\n\\n  return false;\\n}\\n",
    "par2_preferred": 179.3632,
    "par2_rejected": 185.58820000000006
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Check required guards: if solver->unassigned == 0 or solver->level == 0 or !GET_OPTION(restart), return false. \n2. If in focused mode (solver->stable == false):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. Compute margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n  c. If AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue), return true (restart).\n  d. Else, if AVERAGE(decision_rate) < 0.95 * baseline_decision_rate (where baseline_decision_rate is the AVERAGE(decision_rate) after last restart), return true (restart due to slow progress).\n  e. Else return false.\n3. If in stable mode (solver->stable == true):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. If kissat_reluctant_triggered(&solver->reluctant), return true (baseline Luby restart).\n  c. Else, if solver->mab == true and solver->mab_conflicts >= 64 and solver->mab_reward[solver->heuristic] < min(1.0, 0.90 * max(solver->mab_reward[0], solver->mab_reward[1])), return true (restart early if current heuristic is underperforming relative to best observed since last restart).\n  d. Else return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. General guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // 2. Conflict budget not reached yet\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // === FOCUSED MODE ===\\n  if (!solver->stable) {\\n    // (a) Margin-based glue trigger (baseline)\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // (b) Decision-rate stagnation trigger (adaptive)\\n    // Heuristic: Restart if decision rate drops significantly below previous baseline.\\n    // Since we can't store previous baseline, compare to slow glue as a proxy for progress.\\n    // Use a hardcoded threshold (0.95) for significant drop.\\n    const double decision_rate = AVERAGE(decision_rate);\\n    // To be robust, trigger only if decision_rate drops below 95% of observed slow glue,\\n    // which is a loose proxy for progress (since we can't access previous decision_rate).\\n    // (If not meaningful, this block is skipped.)\\n    if (decision_rate > 0.0 && slow > 0.0 && decision_rate < 0.95 * slow)\\n      return true;\\n\\n    // Otherwise, no restart\\n    return false;\\n  }\\n\\n  // === STABLE MODE ===\\n  // (a) Baseline: Reluctant/Luby restart\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // (b) MAB-aware early restart: If MAB is enabled, sufficient conflicts, and current heuristic is underperforming.\\n  if (solver->mab && solver->mab_conflicts >= 64) {\\n    const unsigned h = solver->heuristic;\\n    const double curr = solver->mab_reward[h];\\n    const double best = solver->mab_reward[0] > solver->mab_reward[1] ?\\n                          solver->mab_reward[0] : solver->mab_reward[1];\\n    // Only trigger if there is a significant gap (>10%) and current reward is less than 1.0\\n    if (best > 0.0 && curr < 0.90 * best && curr < 1.0)\\n      return true;\\n  }\\n\\n  // Otherwise, no restart\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guard: restarts globally disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // At root level: never restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Not enough conflicts yet for any restart policy\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- STABLE MODE ---\\n  if (solver->stable) {\\n    // Standard reluctant Luby-based restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive: allow early restart if current heuristic underperforms\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      unsigned h = solver->heuristic;\\n      double my_reward = solver->mab_reward[h];\\n      double best = solver->mab_reward[0];\\n      if (solver->mab_reward[1] > best)\\n        best = solver->mab_reward[1];\\n      // Best can be negative, clamp threshold to at least 1.0 (never be too aggressive)\\n      double threshold = 0.90 * best;\\n      if (threshold > 1.0) threshold = 1.0;\\n      if (my_reward < threshold)\\n        return true;\\n    }\\n    // Default: no restart in stable mode\\n    return false;\\n  }\\n\\n  // --- FOCUSED MODE ---\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (fast >= limit)\\n    return true;\\n\\n  // Decision rate adaptation: restart if we're making much slower progress (i.e., search stagnates)\\n  const double decision_rate = AVERAGE(decision_rate);\\n  // Use the reference as the slow-glue average (acts as a baseline for progress)\\n  // Fallback: if the baseline is zero (e.g., first restart), skip this trigger\\n  const double baseline_decision_rate = solver->averages[solver->stable].decision_rate.value;\\n  if (baseline_decision_rate > 0.0 && decision_rate < 0.95 * baseline_decision_rate)\\n    return true;\\n\\n  return false;\\n}\\n",
    "par2_preferred": 180.265,
    "par2_rejected": 185.58820000000006
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Check required guards: if solver->unassigned == 0 or solver->level == 0 or !GET_OPTION(restart), return false. \n2. If in focused mode (solver->stable == false):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. Compute margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n  c. If AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue), return true (restart).\n  d. Else, if AVERAGE(decision_rate) < 0.95 * baseline_decision_rate (where baseline_decision_rate is the AVERAGE(decision_rate) after last restart), return true (restart due to slow progress).\n  e. Else return false.\n3. If in stable mode (solver->stable == true):\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b. If kissat_reluctant_triggered(&solver->reluctant), return true (baseline Luby restart).\n  c. Else, if solver->mab == true and solver->mab_conflicts >= 64 and solver->mab_reward[solver->heuristic] < min(1.0, 0.90 * max(solver->mab_reward[0], solver->mab_reward[1])), return true (restart early if current heuristic is underperforming relative to best observed since last restart).\n  d. Else return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option disabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // At root level, don't restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Not enough conflicts for next restart opportunity\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable mode ---\\n  if (solver->stable) {\\n    // Reluctant/Luby baseline: always checked first\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: allow opportunistic restart if heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      double reward0 = solver->mab_reward[0];\\n      double reward1 = solver->mab_reward[1];\\n      double max_reward = reward0 > reward1 ? reward0 : reward1;\\n      double target = 0.90 * max_reward;\\n      if (target > 1.0) target = 1.0;\\n      double curr = solver->mab_reward[solver->heuristic];\\n      if (curr < target)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // --- Focused mode ---\\n  // Baseline glue-based restart w/ margin\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n  if (fast >= limit)\\n    return true;\\n\\n  // Adaptive: restart if the decision rate has dropped significantly\\n  // Use 0.95 * (decision rate at last restart) as threshold. Since we cannot track\\n  // baseline decision rate without extra state, skip this unless provided.\\n\\n  // (If tracking baseline_decision_rate is not available, this is a no-op.)\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guard: restarts globally disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // At root level: never restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Not enough conflicts yet for any restart policy\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- STABLE MODE ---\\n  if (solver->stable) {\\n    // Standard reluctant Luby-based restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive: allow early restart if current heuristic underperforms\\n    if (solver->mab && solver->mab_conflicts >= 64) {\\n      unsigned h = solver->heuristic;\\n      double my_reward = solver->mab_reward[h];\\n      double best = solver->mab_reward[0];\\n      if (solver->mab_reward[1] > best)\\n        best = solver->mab_reward[1];\\n      // Best can be negative, clamp threshold to at least 1.0 (never be too aggressive)\\n      double threshold = 0.90 * best;\\n      if (threshold > 1.0) threshold = 1.0;\\n      if (my_reward < threshold)\\n        return true;\\n    }\\n    // Default: no restart in stable mode\\n    return false;\\n  }\\n\\n  // --- FOCUSED MODE ---\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (fast >= limit)\\n    return true;\\n\\n  // Decision rate adaptation: restart if we're making much slower progress (i.e., search stagnates)\\n  const double decision_rate = AVERAGE(decision_rate);\\n  // Use the reference as the slow-glue average (acts as a baseline for progress)\\n  // Fallback: if the baseline is zero (e.g., first restart), skip this trigger\\n  const double baseline_decision_rate = solver->averages[solver->stable].decision_rate.value;\\n  if (baseline_decision_rate > 0.0 && decision_rate < 0.95 * baseline_decision_rate)\\n    return true;\\n\\n  return false;\\n}\\n",
    "par2_preferred": 180.40729999999994,
    "par2_rejected": 185.58820000000006
  },
  {
    "algorithm_description": "```json\n{\n  \"name\": \"MAB-Aware Adaptive Restart\",\n  \"algorithm\": \"1. Guards: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false. \\\n2. Focused Mode (solver->stable == false): \\\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false. \\\n  b. Compute margin_factor = 1.0 + (GET_OPTION(restartmargin) / 100.0). \\\n  c. If AVERAGE(fast_glue) >= margin_factor * AVERAGE(slow_glue), restart trigger = true. \\\n  d. Additionally, if AVERAGE(decision_rate) < 0.95 * historical max decision_rate (track max in O(1) via static variable), set restart trigger = true (unless margin condition already triggers). \\\n  e. Otherwise, return false. \\\n3. Stable Mode (solver->stable == true): \\\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false. \\\n  b. If kissat_reluctant_triggered(&solver->reluctant) returns true, return true. \\\n  c. Otherwise, if solver->mab is true: \\\n    i. Calculate current_reward = log2(solver->mab_decisions) / (log2(solver->mab_conflicts) + 1e-6). \\\n    ii. Compute average_reward = (solver->mab_reward[0] + solver->mab_reward[1]) / (solver->mab_select[0] + solver->mab_select[1] + 1e-6). \\\n    iii. If current_reward < 0.90 * average_reward (indicating current progress is decaying), return true. \\\n  d. Otherwise, return false.\",\n  \"reason\": \"This policy adaptively triggers restarts when progress slows, using both historical decision rate (focused) and MAB reward decay (stable) as early warning signals. This enables faster escape from stagnation, leveraging MAB's reward feedback to dynamically adjust restart timing for diverse benchmark behaviors, improving PAR-2 especially on hard or highly variable instances.\"\n}\n```",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Common early conflict guard\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // ---------------- FOCUSED MODE ----------------\\n  if (!solver->stable) {\\n    // Margin-based glue restart\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin_factor = 1.0 + ((double)GET_OPTION(restartmargin)) / 100.0;\\n    bool margin_trigger = (fast >= margin_factor * slow);\\n\\n    // Decision rate stagnation restart (adaptive, historical max via static)\\n    const double curr_decision_rate = AVERAGE(decision_rate);\\n    // Track max decision rate in static\\n    static double max_decision_rate = 0.0;\\n    if (curr_decision_rate > max_decision_rate)\\n      max_decision_rate = curr_decision_rate;\\n    bool rate_trigger = (curr_decision_rate < 0.95 * max_decision_rate);\\n\\n    if (margin_trigger)\\n      return true;\\n    if (rate_trigger)\\n      return true;\\n    return false;\\n  }\\n\\n  // ---------------- STABLE MODE ----------------\\n  // Reluctant trigger (primary)\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // Optionally, MAB reward decay restart\\n  if (solver->mab) {\\n    // Use log2(decisions)/log2(conflicts) as progress reward\\n    double dec = solver->mab_decisions;\\n    double con = solver->mab_conflicts;\\n    double curr_reward = 0.0;\\n    if (dec > 0.0 && con > 0.0) {\\n      curr_reward = log2(dec) / (log2(con) + 1e-6);\\n    }\\n\\n    double tot_select = (double)solver->mab_select[0] + (double)solver->mab_select[1];\\n    double avg_reward = 0.0;\\n    if (tot_select > 0.0) {\\n      avg_reward = (solver->mab_reward[0] + solver->mab_reward[1]) / (tot_select + 1e-6);\\n    }\\n\\n    if (avg_reward > 0.0 && curr_reward < 0.90 * avg_reward)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n  // Guard: must have decision level > 0\\n  if (!solver->level)\\n    return false;\\n  // Guard: must reach conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused Mode (solver->stable == false) ---\\n  if (!solver->stable) {\\n    // Margin-based glue trigger\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin_factor = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    const double glue_limit = margin_factor * slow;\\n    if (fast >= glue_limit)\\n      return true;\\n\\n    // Adaptive: If decision rate has decayed, trigger restart\\n    // Track maximum observed decision rate using a static variable (O(1) approach)\\n    static double max_decision_rate = 0.0;\\n    const double drate = AVERAGE(decision_rate);\\n    if (drate > max_decision_rate)\\n      max_decision_rate = drate;\\n    if (max_decision_rate > 0.0 && drate < 0.95 * max_decision_rate)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // --- Stable Mode (solver->stable == true) ---\\n  // Classical: reluctant doubling\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: if active, check reward decay\\n  if (solver->mab) {\\n    // Use log2(decisions)/log2(conflicts) as progress signal\\n    double current_reward = 0.0;\\n    if (solver->mab_decisions > 1.0 && solver->mab_conflicts > 1.0)\\n      current_reward = log2(solver->mab_decisions) / (log2(solver->mab_conflicts) + 1e-6);\\n\\n    const unsigned vsids_sel = solver->mab_select[0];\\n    const unsigned chb_sel = solver->mab_select[1];\\n    const double vsids_rew = solver->mab_reward[0];\\n    const double chb_rew = solver->mab_reward[1];\\n    double average_reward = 0.0;\\n    unsigned total_sel = vsids_sel + chb_sel;\\n    if (total_sel > 0)\\n      average_reward = (vsids_rew + chb_rew) / (double)total_sel;\\n\\n    // Restart if current reward is decaying significantly\\n    if (average_reward > 0.0 && current_reward < 0.90 * average_reward)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 270.72049999999996,
    "par2_rejected": 279.74219999999997
  },
  {
    "algorithm_description": "```json\n{\n  \"name\": \"MAB-Aware Adaptive Restart\",\n  \"algorithm\": \"1. Guards: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false. \\\n2. Focused Mode (solver->stable == false): \\\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false. \\\n  b. Compute margin_factor = 1.0 + (GET_OPTION(restartmargin) / 100.0). \\\n  c. If AVERAGE(fast_glue) >= margin_factor * AVERAGE(slow_glue), restart trigger = true. \\\n  d. Additionally, if AVERAGE(decision_rate) < 0.95 * historical max decision_rate (track max in O(1) via static variable), set restart trigger = true (unless margin condition already triggers). \\\n  e. Otherwise, return false. \\\n3. Stable Mode (solver->stable == true): \\\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false. \\\n  b. If kissat_reluctant_triggered(&solver->reluctant) returns true, return true. \\\n  c. Otherwise, if solver->mab is true: \\\n    i. Calculate current_reward = log2(solver->mab_decisions) / (log2(solver->mab_conflicts) + 1e-6). \\\n    ii. Compute average_reward = (solver->mab_reward[0] + solver->mab_reward[1]) / (solver->mab_select[0] + solver->mab_select[1] + 1e-6). \\\n    iii. If current_reward < 0.90 * average_reward (indicating current progress is decaying), return true. \\\n  d. Otherwise, return false.\",\n  \"reason\": \"This policy adaptively triggers restarts when progress slows, using both historical decision rate (focused) and MAB reward decay (stable) as early warning signals. This enables faster escape from stagnation, leveraging MAB's reward feedback to dynamically adjust restart timing for diverse benchmark behaviors, improving PAR-2 especially on hard or highly variable instances.\"\n}\n```",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Defensive: guard against rare division by zero\\n  const double epsilon = 1e-6;\\n\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused Mode: glue margin or adaptive decision rate drop triggers\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin_factor = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n    const double glue_limit = margin_factor * slow;\\n\\n    // Persistent local max for decision rate, O(1) static\\n    static double max_decision_rate = 0.0;\\n    const double curr_decision_rate = AVERAGE(decision_rate);\\n\\n    if (curr_decision_rate > max_decision_rate)\\n      max_decision_rate = curr_decision_rate;\\n\\n    // (a) Glue margin policy\\n    if (fast >= glue_limit)\\n      return true;\\n    // (b) Adaptive decision rate drop\\n    if (max_decision_rate > 0.0 &&\\n        curr_decision_rate < 0.95 * max_decision_rate)\\n      return true;\\n\\n    return false;\\n  } else {\\n    // Stable Mode: reluctant or MAB-aware reward decay triggers\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    if (solver->mab) {\\n      // Use MAB reward signals to detect stagnation\\n      // Current reward: log2(decisions) / (log2(conflicts)+eps)\\n      // Average reward: mean cumulative reward per selection\\n      double mab_decisions = solver->mab_decisions;\\n      double mab_conflicts = (double)solver->mab_conflicts;\\n\\n      double current_reward = 0.0;\\n      if (mab_decisions > 1.0 && mab_conflicts > 0.5)\\n        current_reward = log2(mab_decisions) / (log2(mab_conflicts) + epsilon);\\n\\n      unsigned sel0 = solver->mab_select[0], sel1 = solver->mab_select[1];\\n      double total_reward = solver->mab_reward[0] + solver->mab_reward[1];\\n      double total_select = (double)(sel0 + sel1);\\n\\n      double avg_reward = 0.0;\\n      if (total_select > 0.5)\\n        avg_reward = total_reward / (total_select + epsilon);\\n\\n      // If reward decays significantly, restart\\n      if (avg_reward > 0.0 && current_reward < 0.90 * avg_reward)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n  // Guard: must have decision level > 0\\n  if (!solver->level)\\n    return false;\\n  // Guard: must reach conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused Mode (solver->stable == false) ---\\n  if (!solver->stable) {\\n    // Margin-based glue trigger\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin_factor = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    const double glue_limit = margin_factor * slow;\\n    if (fast >= glue_limit)\\n      return true;\\n\\n    // Adaptive: If decision rate has decayed, trigger restart\\n    // Track maximum observed decision rate using a static variable (O(1) approach)\\n    static double max_decision_rate = 0.0;\\n    const double drate = AVERAGE(decision_rate);\\n    if (drate > max_decision_rate)\\n      max_decision_rate = drate;\\n    if (max_decision_rate > 0.0 && drate < 0.95 * max_decision_rate)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // --- Stable Mode (solver->stable == true) ---\\n  // Classical: reluctant doubling\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: if active, check reward decay\\n  if (solver->mab) {\\n    // Use log2(decisions)/log2(conflicts) as progress signal\\n    double current_reward = 0.0;\\n    if (solver->mab_decisions > 1.0 && solver->mab_conflicts > 1.0)\\n      current_reward = log2(solver->mab_decisions) / (log2(solver->mab_conflicts) + 1e-6);\\n\\n    const unsigned vsids_sel = solver->mab_select[0];\\n    const unsigned chb_sel = solver->mab_select[1];\\n    const double vsids_rew = solver->mab_reward[0];\\n    const double chb_rew = solver->mab_reward[1];\\n    double average_reward = 0.0;\\n    unsigned total_sel = vsids_sel + chb_sel;\\n    if (total_sel > 0)\\n      average_reward = (vsids_rew + chb_rew) / (double)total_sel;\\n\\n    // Restart if current reward is decaying significantly\\n    if (average_reward > 0.0 && current_reward < 0.90 * average_reward)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 271.3357,
    "par2_rejected": 279.74219999999997
  },
  {
    "algorithm_description": "```json\n{\n  \"name\": \"MAB-Aware Adaptive Restart\",\n  \"algorithm\": \"1. Guards: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false. \\\n2. Focused Mode (solver->stable == false): \\\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false. \\\n  b. Compute margin_factor = 1.0 + (GET_OPTION(restartmargin) / 100.0). \\\n  c. If AVERAGE(fast_glue) >= margin_factor * AVERAGE(slow_glue), restart trigger = true. \\\n  d. Additionally, if AVERAGE(decision_rate) < 0.95 * historical max decision_rate (track max in O(1) via static variable), set restart trigger = true (unless margin condition already triggers). \\\n  e. Otherwise, return false. \\\n3. Stable Mode (solver->stable == true): \\\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false. \\\n  b. If kissat_reluctant_triggered(&solver->reluctant) returns true, return true. \\\n  c. Otherwise, if solver->mab is true: \\\n    i. Calculate current_reward = log2(solver->mab_decisions) / (log2(solver->mab_conflicts) + 1e-6). \\\n    ii. Compute average_reward = (solver->mab_reward[0] + solver->mab_reward[1]) / (solver->mab_select[0] + solver->mab_select[1] + 1e-6). \\\n    iii. If current_reward < 0.90 * average_reward (indicating current progress is decaying), return true. \\\n  d. Otherwise, return false.\",\n  \"reason\": \"This policy adaptively triggers restarts when progress slows, using both historical decision rate (focused) and MAB reward decay (stable) as early warning signals. This enables faster escape from stagnation, leveraging MAB's reward feedback to dynamically adjust restart timing for diverse benchmark behaviors, improving PAR-2 especially on hard or highly variable instances.\"\n}\n```",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Focused mode\\n  if (!solver->stable) {\\n    // Margin-based glue trigger\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin_factor = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n\\n    if (fast >= margin_factor * slow)\\n      return true;\\n\\n    // Decision rate trigger: restart if decision rate drops significantly\\n    {\\n      static double max_decision_rate = 0.0; // O(1) max tracking\\n      const double cur_decision_rate = AVERAGE(decision_rate);\\n      if (cur_decision_rate > max_decision_rate)\\n        max_decision_rate = cur_decision_rate;\\n      // If we have enough samples and see a 5% drop, trigger\\n      if (max_decision_rate > 0.0 && cur_decision_rate < 0.95 * max_decision_rate)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // Stable mode\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware trigger in stable mode\\n  if (solver->mab) {\\n    // Reward progress as log(decisions/conflicts), compared to historical average\\n    double reward = 0.0, avg_reward = 0.0;\\n    if (solver->mab_decisions > 1.0 && solver->mab_conflicts > 0) {\\n      reward = log2(solver->mab_decisions) / (log2((double)solver->mab_conflicts) + 1e-6);\\n    }\\n    unsigned total_select = solver->mab_select[0] + solver->mab_select[1];\\n    if (total_select > 0) {\\n      avg_reward = (solver->mab_reward[0] + solver->mab_reward[1]) / (double)total_select;\\n      if (reward < 0.90 * avg_reward)\\n        return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n  // Guard: must have decision level > 0\\n  if (!solver->level)\\n    return false;\\n  // Guard: must reach conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused Mode (solver->stable == false) ---\\n  if (!solver->stable) {\\n    // Margin-based glue trigger\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin_factor = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    const double glue_limit = margin_factor * slow;\\n    if (fast >= glue_limit)\\n      return true;\\n\\n    // Adaptive: If decision rate has decayed, trigger restart\\n    // Track maximum observed decision rate using a static variable (O(1) approach)\\n    static double max_decision_rate = 0.0;\\n    const double drate = AVERAGE(decision_rate);\\n    if (drate > max_decision_rate)\\n      max_decision_rate = drate;\\n    if (max_decision_rate > 0.0 && drate < 0.95 * max_decision_rate)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // --- Stable Mode (solver->stable == true) ---\\n  // Classical: reluctant doubling\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: if active, check reward decay\\n  if (solver->mab) {\\n    // Use log2(decisions)/log2(conflicts) as progress signal\\n    double current_reward = 0.0;\\n    if (solver->mab_decisions > 1.0 && solver->mab_conflicts > 1.0)\\n      current_reward = log2(solver->mab_decisions) / (log2(solver->mab_conflicts) + 1e-6);\\n\\n    const unsigned vsids_sel = solver->mab_select[0];\\n    const unsigned chb_sel = solver->mab_select[1];\\n    const double vsids_rew = solver->mab_reward[0];\\n    const double chb_rew = solver->mab_reward[1];\\n    double average_reward = 0.0;\\n    unsigned total_sel = vsids_sel + chb_sel;\\n    if (total_sel > 0)\\n      average_reward = (vsids_rew + chb_rew) / (double)total_sel;\\n\\n    // Restart if current reward is decaying significantly\\n    if (average_reward > 0.0 && current_reward < 0.90 * average_reward)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 272.32989999999995,
    "par2_rejected": 279.74219999999997
  },
  {
    "algorithm_description": "```json\n{\n  \"name\": \"MAB-Aware Adaptive Restart\",\n  \"algorithm\": \"1. Guards: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false. \\\n2. Focused Mode (solver->stable == false): \\\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false. \\\n  b. Compute margin_factor = 1.0 + (GET_OPTION(restartmargin) / 100.0). \\\n  c. If AVERAGE(fast_glue) >= margin_factor * AVERAGE(slow_glue), restart trigger = true. \\\n  d. Additionally, if AVERAGE(decision_rate) < 0.95 * historical max decision_rate (track max in O(1) via static variable), set restart trigger = true (unless margin condition already triggers). \\\n  e. Otherwise, return false. \\\n3. Stable Mode (solver->stable == true): \\\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false. \\\n  b. If kissat_reluctant_triggered(&solver->reluctant) returns true, return true. \\\n  c. Otherwise, if solver->mab is true: \\\n    i. Calculate current_reward = log2(solver->mab_decisions) / (log2(solver->mab_conflicts) + 1e-6). \\\n    ii. Compute average_reward = (solver->mab_reward[0] + solver->mab_reward[1]) / (solver->mab_select[0] + solver->mab_select[1] + 1e-6). \\\n    iii. If current_reward < 0.90 * average_reward (indicating current progress is decaying), return true. \\\n  d. Otherwise, return false.\",\n  \"reason\": \"This policy adaptively triggers restarts when progress slows, using both historical decision rate (focused) and MAB reward decay (stable) as early warning signals. This enables faster escape from stagnation, leveraging MAB's reward feedback to dynamically adjust restart timing for diverse benchmark behaviors, improving PAR-2 especially on hard or highly variable instances.\"\n}\n```",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Shared: conflicts threshold for restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable mode ---\\n  if (solver->stable) {\\n    // Standard reluctant trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware reward decay (do NOT modify state)\\n    if (solver->mab) {\\n      // Safeguard against division by zero\\n      double log_decisions = (solver->mab_decisions > 0) ? log2(solver->mab_decisions) : 0.0;\\n      double log_conflicts = (solver->mab_conflicts > 0) ? log2((double)solver->mab_conflicts) : 0.0;\\n      double current_reward = (log_conflicts + 1e-6) > 0.0 ? log_decisions / (log_conflicts + 1e-6) : 0.0;\\n\\n      double reward_sum = solver->mab_reward[0] + solver->mab_reward[1];\\n      double select_sum = (double)(solver->mab_select[0] + solver->mab_select[1]);\\n      double average_reward = (select_sum + 1e-6) > 0.0 ? reward_sum / (select_sum + 1e-6) : 0.0;\\n\\n      if (current_reward < 0.90 * average_reward)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode ---\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin_factor = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n  const double limit = margin_factor * slow;\\n\\n  if (fast >= limit)\\n    return true;\\n\\n  // Historical max decision rate (static, read-only, O(1) tracking)\\n  // (Safe for use: static double, function is called frequently)\\n  static double max_decision_rate = 0.0;\\n  const double decision_rate = AVERAGE(decision_rate);\\n\\n  if (decision_rate > max_decision_rate)\\n    max_decision_rate = decision_rate;\\n\\n  if (decision_rate < 0.95 * max_decision_rate)\\n    return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n  // Guard: must have decision level > 0\\n  if (!solver->level)\\n    return false;\\n  // Guard: must reach conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused Mode (solver->stable == false) ---\\n  if (!solver->stable) {\\n    // Margin-based glue trigger\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin_factor = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    const double glue_limit = margin_factor * slow;\\n    if (fast >= glue_limit)\\n      return true;\\n\\n    // Adaptive: If decision rate has decayed, trigger restart\\n    // Track maximum observed decision rate using a static variable (O(1) approach)\\n    static double max_decision_rate = 0.0;\\n    const double drate = AVERAGE(decision_rate);\\n    if (drate > max_decision_rate)\\n      max_decision_rate = drate;\\n    if (max_decision_rate > 0.0 && drate < 0.95 * max_decision_rate)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // --- Stable Mode (solver->stable == true) ---\\n  // Classical: reluctant doubling\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: if active, check reward decay\\n  if (solver->mab) {\\n    // Use log2(decisions)/log2(conflicts) as progress signal\\n    double current_reward = 0.0;\\n    if (solver->mab_decisions > 1.0 && solver->mab_conflicts > 1.0)\\n      current_reward = log2(solver->mab_decisions) / (log2(solver->mab_conflicts) + 1e-6);\\n\\n    const unsigned vsids_sel = solver->mab_select[0];\\n    const unsigned chb_sel = solver->mab_select[1];\\n    const double vsids_rew = solver->mab_reward[0];\\n    const double chb_rew = solver->mab_reward[1];\\n    double average_reward = 0.0;\\n    unsigned total_sel = vsids_sel + chb_sel;\\n    if (total_sel > 0)\\n      average_reward = (vsids_rew + chb_rew) / (double)total_sel;\\n\\n    // Restart if current reward is decaying significantly\\n    if (average_reward > 0.0 && current_reward < 0.90 * average_reward)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 272.8363,
    "par2_rejected": 279.74219999999997
  },
  {
    "algorithm_description": "```json\n{\n  \"name\": \"MAB-Aware Adaptive Restart\",\n  \"algorithm\": \"1. Guards: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false. \\\n2. Focused Mode (solver->stable == false): \\\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false. \\\n  b. Compute margin_factor = 1.0 + (GET_OPTION(restartmargin) / 100.0). \\\n  c. If AVERAGE(fast_glue) >= margin_factor * AVERAGE(slow_glue), restart trigger = true. \\\n  d. Additionally, if AVERAGE(decision_rate) < 0.95 * historical max decision_rate (track max in O(1) via static variable), set restart trigger = true (unless margin condition already triggers). \\\n  e. Otherwise, return false. \\\n3. Stable Mode (solver->stable == true): \\\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false. \\\n  b. If kissat_reluctant_triggered(&solver->reluctant) returns true, return true. \\\n  c. Otherwise, if solver->mab is true: \\\n    i. Calculate current_reward = log2(solver->mab_decisions) / (log2(solver->mab_conflicts) + 1e-6). \\\n    ii. Compute average_reward = (solver->mab_reward[0] + solver->mab_reward[1]) / (solver->mab_select[0] + solver->mab_select[1] + 1e-6). \\\n    iii. If current_reward < 0.90 * average_reward (indicating current progress is decaying), return true. \\\n  d. Otherwise, return false.\",\n  \"reason\": \"This policy adaptively triggers restarts when progress slows, using both historical decision rate (focused) and MAB reward decay (stable) as early warning signals. This enables faster escape from stagnation, leveraging MAB's reward feedback to dynamically adjust restart timing for diverse benchmark behaviors, improving PAR-2 especially on hard or highly variable instances.\"\n}\n```",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guards: Option, level, unassigned\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (!solver->unassigned)\\n    return false;\\n\\n  // Both modes: conflicts threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // === Focused mode: Adaptive margin + decision rate history ===\\n  if (!solver->stable) {\\n    // Margin-based\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin_factor = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    const double limit = margin_factor * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // Decision rate drop (O(1) max tracking via static)\\n    static double max_decision_rate = 0;\\n    const double curr_decision_rate = AVERAGE(decision_rate);\\n    if (curr_decision_rate > max_decision_rate)\\n      max_decision_rate = curr_decision_rate;\\n    // If current decision rate drops below 95% of historical max, trigger\\n    if (curr_decision_rate < 0.95 * max_decision_rate)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // === Stable mode: Reluctant; MAB-aware reward decay restart ===\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: reward decay triggers restart\\n  if (solver->mab) {\\n    // Defensive: avoid log(0) and div by 0\\n    double mab_decisions = solver->mab_decisions > 0.5 ? solver->mab_decisions : 1.0;\\n    double mab_conflicts = solver->mab_conflicts > 0.5 ? solver->mab_conflicts : 1.0;\\n    double current_reward = log2(mab_decisions) / (log2(mab_conflicts) + 1e-6);\\n\\n    unsigned sel0 = solver->mab_select[0], sel1 = solver->mab_select[1];\\n    double total_reward = solver->mab_reward[0] + solver->mab_reward[1];\\n    double total_select = sel0 + sel1;\\n    double average_reward = total_reward / (total_select + 1e-6);\\n\\n    // If progress has decayed significantly, trigger restart\\n    if (current_reward < 0.90 * average_reward)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n  // Guard: must have decision level > 0\\n  if (!solver->level)\\n    return false;\\n  // Guard: must reach conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused Mode (solver->stable == false) ---\\n  if (!solver->stable) {\\n    // Margin-based glue trigger\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin_factor = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    const double glue_limit = margin_factor * slow;\\n    if (fast >= glue_limit)\\n      return true;\\n\\n    // Adaptive: If decision rate has decayed, trigger restart\\n    // Track maximum observed decision rate using a static variable (O(1) approach)\\n    static double max_decision_rate = 0.0;\\n    const double drate = AVERAGE(decision_rate);\\n    if (drate > max_decision_rate)\\n      max_decision_rate = drate;\\n    if (max_decision_rate > 0.0 && drate < 0.95 * max_decision_rate)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // --- Stable Mode (solver->stable == true) ---\\n  // Classical: reluctant doubling\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: if active, check reward decay\\n  if (solver->mab) {\\n    // Use log2(decisions)/log2(conflicts) as progress signal\\n    double current_reward = 0.0;\\n    if (solver->mab_decisions > 1.0 && solver->mab_conflicts > 1.0)\\n      current_reward = log2(solver->mab_decisions) / (log2(solver->mab_conflicts) + 1e-6);\\n\\n    const unsigned vsids_sel = solver->mab_select[0];\\n    const unsigned chb_sel = solver->mab_select[1];\\n    const double vsids_rew = solver->mab_reward[0];\\n    const double chb_rew = solver->mab_reward[1];\\n    double average_reward = 0.0;\\n    unsigned total_sel = vsids_sel + chb_sel;\\n    if (total_sel > 0)\\n      average_reward = (vsids_rew + chb_rew) / (double)total_sel;\\n\\n    // Restart if current reward is decaying significantly\\n    if (average_reward > 0.0 && current_reward < 0.90 * average_reward)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 273.1342,
    "par2_rejected": 279.74219999999997
  },
  {
    "algorithm_description": "```json\n{\n  \"name\": \"MAB-Aware Adaptive Restart\",\n  \"algorithm\": \"1. Guards: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false. \\\n2. Focused Mode (solver->stable == false): \\\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false. \\\n  b. Compute margin_factor = 1.0 + (GET_OPTION(restartmargin) / 100.0). \\\n  c. If AVERAGE(fast_glue) >= margin_factor * AVERAGE(slow_glue), restart trigger = true. \\\n  d. Additionally, if AVERAGE(decision_rate) < 0.95 * historical max decision_rate (track max in O(1) via static variable), set restart trigger = true (unless margin condition already triggers). \\\n  e. Otherwise, return false. \\\n3. Stable Mode (solver->stable == true): \\\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false. \\\n  b. If kissat_reluctant_triggered(&solver->reluctant) returns true, return true. \\\n  c. Otherwise, if solver->mab is true: \\\n    i. Calculate current_reward = log2(solver->mab_decisions) / (log2(solver->mab_conflicts) + 1e-6). \\\n    ii. Compute average_reward = (solver->mab_reward[0] + solver->mab_reward[1]) / (solver->mab_select[0] + solver->mab_select[1] + 1e-6). \\\n    iii. If current_reward < 0.90 * average_reward (indicating current progress is decaying), return true. \\\n  d. Otherwise, return false.\",\n  \"reason\": \"This policy adaptively triggers restarts when progress slows, using both historical decision rate (focused) and MAB reward decay (stable) as early warning signals. This enables faster escape from stagnation, leveraging MAB's reward feedback to dynamically adjust restart timing for diverse benchmark behaviors, improving PAR-2 especially on hard or highly variable instances.\"\n}\n```",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Used for both modes\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused Mode ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin_factor = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    const double limit = margin_factor * slow;\\n\\n    // Restart if clause quality is poor (as in baseline)\\n    if (fast >= limit)\\n      return true;\\n\\n    // Adaptive: restart if decision rate drops significantly\\n    {\\n      // Track historical max decision_rate (O(1) static, allowed)\\n      static double max_decision_rate = 0.0;\\n      const double rate = AVERAGE(decision_rate);\\n\\n      if (rate > max_decision_rate)\\n        max_decision_rate = rate;\\n\\n      if (rate < 0.95 * max_decision_rate)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Stable Mode ---\\n  // Standard reluctant restart\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware reward decay: restart if reward progress stalls\\n  if (solver->mab) {\\n    // Avoid log(0)\\n    double decisions = solver->mab_decisions;\\n    double conflicts = (double)solver->mab_conflicts;\\n    if (decisions < 1.0) decisions = 1.0;\\n    if (conflicts < 1.0) conflicts = 1.0;\\n\\n    // Current reward: progress per conflict\\n    double current_reward = log2(decisions) / (log2(conflicts) + 1e-6);\\n\\n    // Average reward over all arms\\n    double total_reward = solver->mab_reward[0] + solver->mab_reward[1];\\n    double total_select = (double)solver->mab_select[0] + (double)solver->mab_select[1];\\n    double average_reward = 0.0;\\n    if (total_select > 0.0)\\n      average_reward = total_reward / (total_select + 1e-6);\\n\\n    // If reward decays sharply, trigger restart\\n    if (current_reward < 0.90 * average_reward)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n  // Guard: must have decision level > 0\\n  if (!solver->level)\\n    return false;\\n  // Guard: must reach conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused Mode (solver->stable == false) ---\\n  if (!solver->stable) {\\n    // Margin-based glue trigger\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin_factor = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    const double glue_limit = margin_factor * slow;\\n    if (fast >= glue_limit)\\n      return true;\\n\\n    // Adaptive: If decision rate has decayed, trigger restart\\n    // Track maximum observed decision rate using a static variable (O(1) approach)\\n    static double max_decision_rate = 0.0;\\n    const double drate = AVERAGE(decision_rate);\\n    if (drate > max_decision_rate)\\n      max_decision_rate = drate;\\n    if (max_decision_rate > 0.0 && drate < 0.95 * max_decision_rate)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // --- Stable Mode (solver->stable == true) ---\\n  // Classical: reluctant doubling\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: if active, check reward decay\\n  if (solver->mab) {\\n    // Use log2(decisions)/log2(conflicts) as progress signal\\n    double current_reward = 0.0;\\n    if (solver->mab_decisions > 1.0 && solver->mab_conflicts > 1.0)\\n      current_reward = log2(solver->mab_decisions) / (log2(solver->mab_conflicts) + 1e-6);\\n\\n    const unsigned vsids_sel = solver->mab_select[0];\\n    const unsigned chb_sel = solver->mab_select[1];\\n    const double vsids_rew = solver->mab_reward[0];\\n    const double chb_rew = solver->mab_reward[1];\\n    double average_reward = 0.0;\\n    unsigned total_sel = vsids_sel + chb_sel;\\n    if (total_sel > 0)\\n      average_reward = (vsids_rew + chb_rew) / (double)total_sel;\\n\\n    // Restart if current reward is decaying significantly\\n    if (average_reward > 0.0 && current_reward < 0.90 * average_reward)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 273.1536,
    "par2_rejected": 279.74219999999997
  },
  {
    "algorithm_description": "```json\n{\n  \"name\": \"MAB-Aware Adaptive Restart\",\n  \"algorithm\": \"1. Guards: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false. \\\n2. Focused Mode (solver->stable == false): \\\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false. \\\n  b. Compute margin_factor = 1.0 + (GET_OPTION(restartmargin) / 100.0). \\\n  c. If AVERAGE(fast_glue) >= margin_factor * AVERAGE(slow_glue), restart trigger = true. \\\n  d. Additionally, if AVERAGE(decision_rate) < 0.95 * historical max decision_rate (track max in O(1) via static variable), set restart trigger = true (unless margin condition already triggers). \\\n  e. Otherwise, return false. \\\n3. Stable Mode (solver->stable == true): \\\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false. \\\n  b. If kissat_reluctant_triggered(&solver->reluctant) returns true, return true. \\\n  c. Otherwise, if solver->mab is true: \\\n    i. Calculate current_reward = log2(solver->mab_decisions) / (log2(solver->mab_conflicts) + 1e-6). \\\n    ii. Compute average_reward = (solver->mab_reward[0] + solver->mab_reward[1]) / (solver->mab_select[0] + solver->mab_select[1] + 1e-6). \\\n    iii. If current_reward < 0.90 * average_reward (indicating current progress is decaying), return true. \\\n  d. Otherwise, return false.\",\n  \"reason\": \"This policy adaptively triggers restarts when progress slows, using both historical decision rate (focused) and MAB reward decay (stable) as early warning signals. This enables faster escape from stagnation, leveraging MAB's reward feedback to dynamically adjust restart timing for diverse benchmark behaviors, improving PAR-2 especially on hard or highly variable instances.\"\n}\n```",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // In both modes, must reach conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused Mode (VSIDS/CHB) ---\\n  if (!solver->stable) {\\n    // Margin-based glue trigger\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin_factor = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    if (fast >= margin_factor * slow)\\n      return true;\\n\\n    // Historical max decision rate trigger (static for O(1) tracking)\\n    {\\n      static double max_decision_rate = 0.0;\\n      const double rate = AVERAGE(decision_rate);\\n      if (rate > max_decision_rate)\\n        max_decision_rate = rate;\\n      // If current rate is less than 95% of peak, restart\\n      if (rate < 0.95 * max_decision_rate)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // --- Stable Mode (Luby/Reluctant) ---\\n  // Classic reluctant restart\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware reward decay trigger (only if MAB is enabled)\\n  if (solver->mab) {\\n    // Avoid division by zero\\n    double decisions = solver->mab_decisions > 1 ? solver->mab_decisions : 1.0;\\n    double conflicts = solver->mab_conflicts > 1 ? solver->mab_conflicts : 1.0;\\n    double current_reward = log2(decisions) / (log2(conflicts) + 1e-6);\\n\\n    unsigned total_select = solver->mab_select[0] + solver->mab_select[1];\\n    double sum_reward = solver->mab_reward[0] + solver->mab_reward[1];\\n    double avg_reward = sum_reward / (total_select + 1e-6);\\n\\n    if (current_reward < 0.90 * avg_reward)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n  // Guard: must have decision level > 0\\n  if (!solver->level)\\n    return false;\\n  // Guard: must reach conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused Mode (solver->stable == false) ---\\n  if (!solver->stable) {\\n    // Margin-based glue trigger\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin_factor = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    const double glue_limit = margin_factor * slow;\\n    if (fast >= glue_limit)\\n      return true;\\n\\n    // Adaptive: If decision rate has decayed, trigger restart\\n    // Track maximum observed decision rate using a static variable (O(1) approach)\\n    static double max_decision_rate = 0.0;\\n    const double drate = AVERAGE(decision_rate);\\n    if (drate > max_decision_rate)\\n      max_decision_rate = drate;\\n    if (max_decision_rate > 0.0 && drate < 0.95 * max_decision_rate)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // --- Stable Mode (solver->stable == true) ---\\n  // Classical: reluctant doubling\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: if active, check reward decay\\n  if (solver->mab) {\\n    // Use log2(decisions)/log2(conflicts) as progress signal\\n    double current_reward = 0.0;\\n    if (solver->mab_decisions > 1.0 && solver->mab_conflicts > 1.0)\\n      current_reward = log2(solver->mab_decisions) / (log2(solver->mab_conflicts) + 1e-6);\\n\\n    const unsigned vsids_sel = solver->mab_select[0];\\n    const unsigned chb_sel = solver->mab_select[1];\\n    const double vsids_rew = solver->mab_reward[0];\\n    const double chb_rew = solver->mab_reward[1];\\n    double average_reward = 0.0;\\n    unsigned total_sel = vsids_sel + chb_sel;\\n    if (total_sel > 0)\\n      average_reward = (vsids_rew + chb_rew) / (double)total_sel;\\n\\n    // Restart if current reward is decaying significantly\\n    if (average_reward > 0.0 && current_reward < 0.90 * average_reward)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 273.1592,
    "par2_rejected": 279.74219999999997
  },
  {
    "algorithm_description": "```json\n{\n  \"name\": \"MAB-Aware Adaptive Restart\",\n  \"algorithm\": \"1. Guards: If solver->unassigned == 0, solver->level == 0, or GET_OPTION(restart) == 0, return false. \\\n2. Focused Mode (solver->stable == false): \\\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false. \\\n  b. Compute margin_factor = 1.0 + (GET_OPTION(restartmargin) / 100.0). \\\n  c. If AVERAGE(fast_glue) >= margin_factor * AVERAGE(slow_glue), restart trigger = true. \\\n  d. Additionally, if AVERAGE(decision_rate) < 0.95 * historical max decision_rate (track max in O(1) via static variable), set restart trigger = true (unless margin condition already triggers). \\\n  e. Otherwise, return false. \\\n3. Stable Mode (solver->stable == true): \\\n  a. If CONFLICTS < solver->limits.restart.conflicts, return false. \\\n  b. If kissat_reluctant_triggered(&solver->reluctant) returns true, return true. \\\n  c. Otherwise, if solver->mab is true: \\\n    i. Calculate current_reward = log2(solver->mab_decisions) / (log2(solver->mab_conflicts) + 1e-6). \\\n    ii. Compute average_reward = (solver->mab_reward[0] + solver->mab_reward[1]) / (solver->mab_select[0] + solver->mab_select[1] + 1e-6). \\\n    iii. If current_reward < 0.90 * average_reward (indicating current progress is decaying), return true. \\\n  d. Otherwise, return false.\",\n  \"reason\": \"This policy adaptively triggers restarts when progress slows, using both historical decision rate (focused) and MAB reward decay (stable) as early warning signals. This enables faster escape from stagnation, leveraging MAB's reward feedback to dynamically adjust restart timing for diverse benchmark behaviors, improving PAR-2 especially on hard or highly variable instances.\"\n}\n```",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Conflict bound guard\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Focused Mode (not stable)\\n  if (!solver->stable) {\\n    // Clause quality-based restart\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin_factor = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n\\n    if (fast >= margin_factor * slow)\\n      return true;\\n\\n    // Decision rate-based restart (adaptive, with historical max)\\n    // Track max decision rate in static variable (O(1) memory)\\n    static double max_decision_rate = 0.0;\\n    const double rate = AVERAGE(decision_rate);\\n    if (rate > max_decision_rate)\\n      max_decision_rate = rate;\\n\\n    if (rate < 0.95 * max_decision_rate)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // Stable Mode\\n  // (1) Reluctant-based restart always triggers if reluctant says so\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // (2) MAB-based reward decay restart (only if MAB active)\\n  if (solver->mab) {\\n    // Reward: log2(decisions) / (log2(conflicts) + epsilon)\\n    // Average reward: (sum of rewards) / (sum of selections + epsilon)\\n    const double epsilon = 1e-6;\\n    double mab_decisions = solver->mab_decisions;\\n    double mab_conflicts = (double)solver->mab_conflicts;\\n    if (mab_decisions < 1.0)\\n      mab_decisions = 1.0;\\n    if (mab_conflicts < 1.0)\\n      mab_conflicts = 1.0;\\n\\n    const double current_reward = log2(mab_decisions) / (log2(mab_conflicts) + epsilon);\\n\\n    const double sum_rewards = solver->mab_reward[0] + solver->mab_reward[1];\\n    const double sum_selects = (double)(solver->mab_select[0] + solver->mab_select[1]) + epsilon;\\n    const double average_reward = sum_rewards / sum_selects;\\n\\n    if (current_reward < 0.90 * average_reward)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n  // Guard: must have decision level > 0\\n  if (!solver->level)\\n    return false;\\n  // Guard: must reach conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused Mode (solver->stable == false) ---\\n  if (!solver->stable) {\\n    // Margin-based glue trigger\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin_factor = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    const double glue_limit = margin_factor * slow;\\n    if (fast >= glue_limit)\\n      return true;\\n\\n    // Adaptive: If decision rate has decayed, trigger restart\\n    // Track maximum observed decision rate using a static variable (O(1) approach)\\n    static double max_decision_rate = 0.0;\\n    const double drate = AVERAGE(decision_rate);\\n    if (drate > max_decision_rate)\\n      max_decision_rate = drate;\\n    if (max_decision_rate > 0.0 && drate < 0.95 * max_decision_rate)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // --- Stable Mode (solver->stable == true) ---\\n  // Classical: reluctant doubling\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: if active, check reward decay\\n  if (solver->mab) {\\n    // Use log2(decisions)/log2(conflicts) as progress signal\\n    double current_reward = 0.0;\\n    if (solver->mab_decisions > 1.0 && solver->mab_conflicts > 1.0)\\n      current_reward = log2(solver->mab_decisions) / (log2(solver->mab_conflicts) + 1e-6);\\n\\n    const unsigned vsids_sel = solver->mab_select[0];\\n    const unsigned chb_sel = solver->mab_select[1];\\n    const double vsids_rew = solver->mab_reward[0];\\n    const double chb_rew = solver->mab_reward[1];\\n    double average_reward = 0.0;\\n    unsigned total_sel = vsids_sel + chb_sel;\\n    if (total_sel > 0)\\n      average_reward = (vsids_rew + chb_rew) / (double)total_sel;\\n\\n    // Restart if current reward is decaying significantly\\n    if (average_reward > 0.0 && current_reward < 0.90 * average_reward)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 273.4016,
    "par2_rejected": 279.74219999999997
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Reward Restarts\n\nAlgorithm: First, check required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + GET_OPTION(restartmargin)/100.0.\n- Trigger restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)).\n- Additionally, if AVERAGE(decision_rate) < 0.75 * AVERAGE(slow_glue), trigger an early restart (catching stagnation).\n\nIn stable mode (solver->stable == true):\n- If kissat_reluctant_triggered(&solver->reluctant) is true AND (CONFLICTS >= solver->limits.restart.conflicts), return true.\n- ELSE, if solver->mab is enabled:\n   - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n   - If solver->mab_reward[h] < 0.95 * solver->mab_reward[1-h] and solver->mab_conflicts >= 0.5 * solver->limits.restart.conflicts, trigger an early restart (indicates current heuristic underperforms peer since last restart and we're at least halfway through interval).\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root/backtracked to root?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: have we reached the restart conflict threshold?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode (reluctant or MAB-aware) ---\\n  if (solver->stable) {\\n    // Standard reluctant trigger (doubling sequence)\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: early restart if our heuristic is underperforming\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;        // 0 = VSIDS, 1 = CHB\\n      unsigned peer = 1 - h;\\n      double my_reward = solver->mab_reward[h];\\n      double peer_reward = solver->mab_reward[peer];\\n      unsigned restart_half = solver->limits.restart.conflicts / 2;\\n      // Only consider early restart if we've passed halfway in the current interval\\n      if (solver->mab_conflicts >= restart_half) {\\n        // If our reward is significantly less than peer's, restart early\\n        if (my_reward < 0.95 * peer_reward)\\n          return true;\\n      }\\n    }\\n    // Otherwise, don't restart yet\\n    return false;\\n  }\\n\\n  // --- Focused Mode (glue and stagnation triggers) ---\\n  double fast = AVERAGE(fast_glue);\\n  double slow = AVERAGE(slow_glue);\\n  double glue_margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n  // Standard Luby/glue-based restart\\n  if (fast >= glue_margin * slow)\\n    return true;\\n\\n  // Decision rate stagnation: restart if rate drops well below baseline glue\\n  double dec_rate = AVERAGE(decision_rate);\\n  if (dec_rate < 0.75 * slow)\\n    return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Always require we've hit the minimum conflict interval\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue-based with margin, plus stagnation early trigger\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double glue_margin = 1.0 + ((double) GET_OPTION(restartmargin)) / 100.0;\\n    if (fast >= glue_margin * slow)\\n      return true;\\n    // Early restart on stagnation: decision rate dropped well below slow glue (indicates trouble)\\n    if (AVERAGE(decision_rate) < 0.75 * slow)\\n      return true;\\n    return false;\\n  } else {\\n    // Stable mode: reluctant or MAB-aware early restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n      unsigned other = 1 - h;\\n      double reward = solver->mab_reward[h];\\n      double reward_other = solver->mab_reward[other];\\n      // If our reward is much worse and we're at least halfway through the interval, restart early\\n      if (\\n        reward < 0.95 * reward_other &&\\n        solver->mab_conflicts >= 0.5 * (double) solver->limits.restart.conflicts\\n      ) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 182.6936,
    "par2_rejected": 187.69969999999998
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Reward Restarts\n\nAlgorithm: First, check required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + GET_OPTION(restartmargin)/100.0.\n- Trigger restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)).\n- Additionally, if AVERAGE(decision_rate) < 0.75 * AVERAGE(slow_glue), trigger an early restart (catching stagnation).\n\nIn stable mode (solver->stable == true):\n- If kissat_reluctant_triggered(&solver->reluctant) is true AND (CONFLICTS >= solver->limits.restart.conflicts), return true.\n- ELSE, if solver->mab is enabled:\n   - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n   - If solver->mab_reward[h] < 0.95 * solver->mab_reward[1-h] and solver->mab_conflicts >= 0.5 * solver->limits.restart.conflicts, trigger an early restart (indicates current heuristic underperforms peer since last restart and we're at least halfway through interval).\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root/backtracked to root?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: have we reached the restart conflict threshold?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode (reluctant or MAB-aware) ---\\n  if (solver->stable) {\\n    // Standard reluctant trigger (doubling sequence)\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: early restart if our heuristic is underperforming\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;        // 0 = VSIDS, 1 = CHB\\n      unsigned peer = 1 - h;\\n      double my_reward = solver->mab_reward[h];\\n      double peer_reward = solver->mab_reward[peer];\\n      unsigned restart_half = solver->limits.restart.conflicts / 2;\\n      // Only consider early restart if we've passed halfway in the current interval\\n      if (solver->mab_conflicts >= restart_half) {\\n        // If our reward is significantly less than peer's, restart early\\n        if (my_reward < 0.95 * peer_reward)\\n          return true;\\n      }\\n    }\\n    // Otherwise, don't restart yet\\n    return false;\\n  }\\n\\n  // --- Focused Mode (glue and stagnation triggers) ---\\n  double fast = AVERAGE(fast_glue);\\n  double slow = AVERAGE(slow_glue);\\n  double glue_margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n  // Standard Luby/glue-based restart\\n  if (fast >= glue_margin * slow)\\n    return true;\\n\\n  // Decision rate stagnation: restart if rate drops well below baseline glue\\n  double dec_rate = AVERAGE(decision_rate);\\n  if (dec_rate < 0.75 * slow)\\n    return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. Option and state guards (standard in Kissat)\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // 2. Stable mode: Reluctant, plus MAB early restart if enabled\\n  if (solver->stable) {\\n    if (kissat_reluctant_triggered(&solver->reluctant) &&\\n        (CONFLICTS >= solver->limits.restart.conflicts))\\n      return true;\\n\\n    // MAB-based early restart in stable mode\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;        // 0=VSIDS, 1=CHB\\n      unsigned alt = 1 - h;\\n      double my_reward = solver->mab_reward[h];\\n      double alt_reward = solver->mab_reward[alt];\\n\\n      // Underperforming heuristic: trigger early if halfway through interval\\n      if (\\n        my_reward < 0.95 * alt_reward &&\\n        solver->mab_conflicts >= 0.5 * solver->limits.restart.conflicts\\n      ) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // 3. Focused mode: Glue-based, plus decision rate fallback\\n  const double slow = AVERAGE(slow_glue);\\n  const double fast = AVERAGE(fast_glue);\\n  const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n\\n  if (fast >= glue_margin * slow)\\n    return true;\\n\\n  // Early restart if decision rate drops far below glue (stagnation)\\n  const double drate = AVERAGE(decision_rate);\\n  if (drate < 0.75 * slow)\\n    return true;\\n\\n  return false;\\n}\\n",
    "par2_preferred": 182.6936,
    "par2_rejected": 188.0728
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Reward Restarts\n\nAlgorithm: First, check required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + GET_OPTION(restartmargin)/100.0.\n- Trigger restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)).\n- Additionally, if AVERAGE(decision_rate) < 0.75 * AVERAGE(slow_glue), trigger an early restart (catching stagnation).\n\nIn stable mode (solver->stable == true):\n- If kissat_reluctant_triggered(&solver->reluctant) is true AND (CONFLICTS >= solver->limits.restart.conflicts), return true.\n- ELSE, if solver->mab is enabled:\n   - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n   - If solver->mab_reward[h] < 0.95 * solver->mab_reward[1-h] and solver->mab_conflicts >= 0.5 * solver->limits.restart.conflicts, trigger an early restart (indicates current heuristic underperforms peer since last restart and we're at least halfway through interval).\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root/backtracked to root?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: have we reached the restart conflict threshold?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode (reluctant or MAB-aware) ---\\n  if (solver->stable) {\\n    // Standard reluctant trigger (doubling sequence)\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: early restart if our heuristic is underperforming\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;        // 0 = VSIDS, 1 = CHB\\n      unsigned peer = 1 - h;\\n      double my_reward = solver->mab_reward[h];\\n      double peer_reward = solver->mab_reward[peer];\\n      unsigned restart_half = solver->limits.restart.conflicts / 2;\\n      // Only consider early restart if we've passed halfway in the current interval\\n      if (solver->mab_conflicts >= restart_half) {\\n        // If our reward is significantly less than peer's, restart early\\n        if (my_reward < 0.95 * peer_reward)\\n          return true;\\n      }\\n    }\\n    // Otherwise, don't restart yet\\n    return false;\\n  }\\n\\n  // --- Focused Mode (glue and stagnation triggers) ---\\n  double fast = AVERAGE(fast_glue);\\n  double slow = AVERAGE(slow_glue);\\n  double glue_margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n  // Standard Luby/glue-based restart\\n  if (fast >= glue_margin * slow)\\n    return true;\\n\\n  // Decision rate stagnation: restart if rate drops well below baseline glue\\n  double dec_rate = AVERAGE(decision_rate);\\n  if (dec_rate < 0.75 * slow)\\n    return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  if (!solver->level)\\n    return false;\\n\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue-based + decision rate early restart\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double glue_margin = 1.0 + ((double)GET_OPTION(restartmargin)) / 100.0;\\n    const double glue_limit = glue_margin * slow;\\n\\n    if (fast >= glue_limit)\\n      return true;\\n\\n    const double decision_rate = AVERAGE(decision_rate);\\n    if (decision_rate < 0.75 * slow)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // Stable mode: reluctant or MAB reward-based\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;        // 0=VSIDS, 1=CHB\\n    unsigned other = 1 - h;\\n    double reward_h = solver->mab_reward[h];\\n    double reward_other = solver->mab_reward[other];\\n    uint64_t mab_conflicts = solver->mab_conflicts;\\n    uint64_t limit = solver->limits.restart.conflicts;\\n\\n    if (reward_h < 0.95 * reward_other && mab_conflicts >= 0.5 * (double)limit)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 182.6936,
    "par2_rejected": 189.33359999999993
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Reward Restarts\n\nAlgorithm: First, check required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + GET_OPTION(restartmargin)/100.0.\n- Trigger restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)).\n- Additionally, if AVERAGE(decision_rate) < 0.75 * AVERAGE(slow_glue), trigger an early restart (catching stagnation).\n\nIn stable mode (solver->stable == true):\n- If kissat_reluctant_triggered(&solver->reluctant) is true AND (CONFLICTS >= solver->limits.restart.conflicts), return true.\n- ELSE, if solver->mab is enabled:\n   - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n   - If solver->mab_reward[h] < 0.95 * solver->mab_reward[1-h] and solver->mab_conflicts >= 0.5 * solver->limits.restart.conflicts, trigger an early restart (indicates current heuristic underperforms peer since last restart and we're at least halfway through interval).\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root/backtracked to root?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: have we reached the restart conflict threshold?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode (reluctant or MAB-aware) ---\\n  if (solver->stable) {\\n    // Standard reluctant trigger (doubling sequence)\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: early restart if our heuristic is underperforming\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;        // 0 = VSIDS, 1 = CHB\\n      unsigned peer = 1 - h;\\n      double my_reward = solver->mab_reward[h];\\n      double peer_reward = solver->mab_reward[peer];\\n      unsigned restart_half = solver->limits.restart.conflicts / 2;\\n      // Only consider early restart if we've passed halfway in the current interval\\n      if (solver->mab_conflicts >= restart_half) {\\n        // If our reward is significantly less than peer's, restart early\\n        if (my_reward < 0.95 * peer_reward)\\n          return true;\\n      }\\n    }\\n    // Otherwise, don't restart yet\\n    return false;\\n  }\\n\\n  // --- Focused Mode (glue and stagnation triggers) ---\\n  double fast = AVERAGE(fast_glue);\\n  double slow = AVERAGE(slow_glue);\\n  double glue_margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n  // Standard Luby/glue-based restart\\n  if (fast >= glue_margin * slow)\\n    return true;\\n\\n  // Decision rate stagnation: restart if rate drops well below baseline glue\\n  double dec_rate = AVERAGE(decision_rate);\\n  if (dec_rate < 0.75 * slow)\\n    return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: Standard glue margin + early stagnation detection\\n    const double glue_margin = 1.0 + ((double)GET_OPTION(restartmargin)) / 100.0;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double limit = glue_margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // Early restart if decision rate has dropped unusually low\\n    const double drate = AVERAGE(decision_rate);\\n    if (drate < 0.75 * slow)\\n      return true;\\n\\n    return false;\\n  } else {\\n    // Stable mode: Reluctant trigger or MAB underperformance\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;\\n      unsigned h_peer = 1 - h;\\n      double r_h = solver->mab_reward[h];\\n      double r_peer = solver->mab_reward[h_peer];\\n      // Only consider early restart if enough conflicts have accumulated\\n      if (\\n        solver->mab_conflicts >= 0.5 * (double)solver->limits.restart.conflicts &&\\n        r_h < 0.95 * r_peer\\n      )\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 182.6936,
    "par2_rejected": 189.56229999999996
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Reward Restarts\n\nAlgorithm: First, check required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + GET_OPTION(restartmargin)/100.0.\n- Trigger restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)).\n- Additionally, if AVERAGE(decision_rate) < 0.75 * AVERAGE(slow_glue), trigger an early restart (catching stagnation).\n\nIn stable mode (solver->stable == true):\n- If kissat_reluctant_triggered(&solver->reluctant) is true AND (CONFLICTS >= solver->limits.restart.conflicts), return true.\n- ELSE, if solver->mab is enabled:\n   - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n   - If solver->mab_reward[h] < 0.95 * solver->mab_reward[1-h] and solver->mab_conflicts >= 0.5 * solver->limits.restart.conflicts, trigger an early restart (indicates current heuristic underperforms peer since last restart and we're at least halfway through interval).\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root/backtracked to root?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: have we reached the restart conflict threshold?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode (reluctant or MAB-aware) ---\\n  if (solver->stable) {\\n    // Standard reluctant trigger (doubling sequence)\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: early restart if our heuristic is underperforming\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;        // 0 = VSIDS, 1 = CHB\\n      unsigned peer = 1 - h;\\n      double my_reward = solver->mab_reward[h];\\n      double peer_reward = solver->mab_reward[peer];\\n      unsigned restart_half = solver->limits.restart.conflicts / 2;\\n      // Only consider early restart if we've passed halfway in the current interval\\n      if (solver->mab_conflicts >= restart_half) {\\n        // If our reward is significantly less than peer's, restart early\\n        if (my_reward < 0.95 * peer_reward)\\n          return true;\\n      }\\n    }\\n    // Otherwise, don't restart yet\\n    return false;\\n  }\\n\\n  // --- Focused Mode (glue and stagnation triggers) ---\\n  double fast = AVERAGE(fast_glue);\\n  double slow = AVERAGE(slow_glue);\\n  double glue_margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n  // Standard Luby/glue-based restart\\n  if (fast >= glue_margin * slow)\\n    return true;\\n\\n  // Decision rate stagnation: restart if rate drops well below baseline glue\\n  double dec_rate = AVERAGE(decision_rate);\\n  if (dec_rate < 0.75 * slow)\\n    return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Always require at least interval to pass for main triggers\\n  const uint64_t conflicts = CONFLICTS;\\n  const uint64_t restart_limit = solver->limits.restart.conflicts;\\n  if (conflicts < restart_limit)\\n    goto mab_early;\\n\\n  // --- Main restart triggers: ---\\n  if (solver->stable) {\\n    // Stable: reluctant doubling\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    // Otherwise, allow MAB early restart evaluation below\\n    goto mab_early;\\n  }\\n\\n  // Focused: glue-based\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = 1.0 + ((double)GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n  if (fast >= glue_limit)\\n    return true;\\n\\n  // Early restart: stagnation (decision rate drop)\\n  if (AVERAGE(decision_rate) < 0.75 * slow)\\n    return true;\\n\\n  // --- MAB early restart trigger (both modes): ---\\nmab_early:\\n  if (solver->mab) {\\n    const unsigned h = solver->heuristic;         // 0=VSIDS, 1=CHB\\n    const unsigned h_other = 1 - h;\\n    const double reward = solver->mab_reward[h];\\n    const double reward_other = solver->mab_reward[h_other];\\n    // Only trigger if at least half the interval since last restart\\n    if (solver->mab_conflicts >= 0.5 * (double)restart_limit) {\\n      if (reward < 0.95 * reward_other)\\n        return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 182.6936,
    "par2_rejected": 190.91279999999995
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Reward Restarts\n\nAlgorithm: First, check required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + GET_OPTION(restartmargin)/100.0.\n- Trigger restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)).\n- Additionally, if AVERAGE(decision_rate) < 0.75 * AVERAGE(slow_glue), trigger an early restart (catching stagnation).\n\nIn stable mode (solver->stable == true):\n- If kissat_reluctant_triggered(&solver->reluctant) is true AND (CONFLICTS >= solver->limits.restart.conflicts), return true.\n- ELSE, if solver->mab is enabled:\n   - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n   - If solver->mab_reward[h] < 0.95 * solver->mab_reward[1-h] and solver->mab_conflicts >= 0.5 * solver->limits.restart.conflicts, trigger an early restart (indicates current heuristic underperforms peer since last restart and we're at least halfway through interval).\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root/backtracked to root?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: have we reached the restart conflict threshold?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode (reluctant or MAB-aware) ---\\n  if (solver->stable) {\\n    // Standard reluctant trigger (doubling sequence)\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: early restart if our heuristic is underperforming\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;        // 0 = VSIDS, 1 = CHB\\n      unsigned peer = 1 - h;\\n      double my_reward = solver->mab_reward[h];\\n      double peer_reward = solver->mab_reward[peer];\\n      unsigned restart_half = solver->limits.restart.conflicts / 2;\\n      // Only consider early restart if we've passed halfway in the current interval\\n      if (solver->mab_conflicts >= restart_half) {\\n        // If our reward is significantly less than peer's, restart early\\n        if (my_reward < 0.95 * peer_reward)\\n          return true;\\n      }\\n    }\\n    // Otherwise, don't restart yet\\n    return false;\\n  }\\n\\n  // --- Focused Mode (glue and stagnation triggers) ---\\n  double fast = AVERAGE(fast_glue);\\n  double slow = AVERAGE(slow_glue);\\n  double glue_margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n  // Standard Luby/glue-based restart\\n  if (fast >= glue_margin * slow)\\n    return true;\\n\\n  // Decision rate stagnation: restart if rate drops well below baseline glue\\n  double dec_rate = AVERAGE(decision_rate);\\n  if (dec_rate < 0.75 * slow)\\n    return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: use glue-based and decision-rate triggers\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + ((double)GET_OPTION(restartmargin)) / 100.0;\\n    if (fast >= margin * slow)\\n      return true;\\n    // Early restart if decision rate stagnates significantly below expected glue\\n    const double drate = AVERAGE(decision_rate);\\n    if (drate < 0.75 * slow)\\n      return true;\\n    return false;\\n  }\\n\\n  // Stable mode: reluctant, plus MAB-aware early restart\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned alt = 1 - h;\\n    double my_reward = solver->mab_reward[h];\\n    double alt_reward = solver->mab_reward[alt];\\n    // Only consider early MAB restart after halfway through the interval\\n    if (solver->mab_conflicts >= 0.5 * solver->limits.restart.conflicts) {\\n      // If our reward is notably worse than the peer, restart early\\n      if (my_reward < 0.95 * alt_reward)\\n        return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 182.6936,
    "par2_rejected": 190.93739999999997
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Reward Restarts\n\nAlgorithm: First, check required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + GET_OPTION(restartmargin)/100.0.\n- Trigger restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)).\n- Additionally, if AVERAGE(decision_rate) < 0.75 * AVERAGE(slow_glue), trigger an early restart (catching stagnation).\n\nIn stable mode (solver->stable == true):\n- If kissat_reluctant_triggered(&solver->reluctant) is true AND (CONFLICTS >= solver->limits.restart.conflicts), return true.\n- ELSE, if solver->mab is enabled:\n   - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n   - If solver->mab_reward[h] < 0.95 * solver->mab_reward[1-h] and solver->mab_conflicts >= 0.5 * solver->limits.restart.conflicts, trigger an early restart (indicates current heuristic underperforms peer since last restart and we're at least halfway through interval).\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root/backtracked to root?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: have we reached the restart conflict threshold?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode (reluctant or MAB-aware) ---\\n  if (solver->stable) {\\n    // Standard reluctant trigger (doubling sequence)\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: early restart if our heuristic is underperforming\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;        // 0 = VSIDS, 1 = CHB\\n      unsigned peer = 1 - h;\\n      double my_reward = solver->mab_reward[h];\\n      double peer_reward = solver->mab_reward[peer];\\n      unsigned restart_half = solver->limits.restart.conflicts / 2;\\n      // Only consider early restart if we've passed halfway in the current interval\\n      if (solver->mab_conflicts >= restart_half) {\\n        // If our reward is significantly less than peer's, restart early\\n        if (my_reward < 0.95 * peer_reward)\\n          return true;\\n      }\\n    }\\n    // Otherwise, don't restart yet\\n    return false;\\n  }\\n\\n  // --- Focused Mode (glue and stagnation triggers) ---\\n  double fast = AVERAGE(fast_glue);\\n  double slow = AVERAGE(slow_glue);\\n  double glue_margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n  // Standard Luby/glue-based restart\\n  if (fast >= glue_margin * slow)\\n    return true;\\n\\n  // Decision rate stagnation: restart if rate drops well below baseline glue\\n  double dec_rate = AVERAGE(decision_rate);\\n  if (dec_rate < 0.75 * slow)\\n    return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue margin or decision-rate stagnation triggers\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double glue_margin = 1.0 + ((double)GET_OPTION(restartmargin)) / 100.0;\\n    if (fast >= glue_margin * slow)\\n      return true;\\n    // Early restart if decision rate collapses (stagnation)\\n    const double decision_rate = AVERAGE(decision_rate);\\n    if (decision_rate < 0.75 * slow)\\n      return true;\\n    return false;\\n  } else {\\n    // Stable mode: reluctant or (optionally) MAB reward-triggered\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    if (solver->mab) {\\n      const unsigned h = solver->heuristic;\\n      const unsigned other = 1 - h;\\n      const double reward = solver->mab_reward[h];\\n      const double peer = solver->mab_reward[other];\\n      if (peer > 0.0) {\\n        // Only compare once we've accumulated some peer reward\\n        if (reward < 0.95 * peer &&\\n            solver->mab_conflicts >= 0.5 * solver->limits.restart.conflicts)\\n          return true;\\n      }\\n    }\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 182.6936,
    "par2_rejected": 191.01330000000002
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Reward Restarts\n\nAlgorithm: First, check required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + GET_OPTION(restartmargin)/100.0.\n- Trigger restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)).\n- Additionally, if AVERAGE(decision_rate) < 0.75 * AVERAGE(slow_glue), trigger an early restart (catching stagnation).\n\nIn stable mode (solver->stable == true):\n- If kissat_reluctant_triggered(&solver->reluctant) is true AND (CONFLICTS >= solver->limits.restart.conflicts), return true.\n- ELSE, if solver->mab is enabled:\n   - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n   - If solver->mab_reward[h] < 0.95 * solver->mab_reward[1-h] and solver->mab_conflicts >= 0.5 * solver->limits.restart.conflicts, trigger an early restart (indicates current heuristic underperforms peer since last restart and we're at least halfway through interval).\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root/backtracked to root?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: have we reached the restart conflict threshold?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode (reluctant or MAB-aware) ---\\n  if (solver->stable) {\\n    // Standard reluctant trigger (doubling sequence)\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: early restart if our heuristic is underperforming\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;        // 0 = VSIDS, 1 = CHB\\n      unsigned peer = 1 - h;\\n      double my_reward = solver->mab_reward[h];\\n      double peer_reward = solver->mab_reward[peer];\\n      unsigned restart_half = solver->limits.restart.conflicts / 2;\\n      // Only consider early restart if we've passed halfway in the current interval\\n      if (solver->mab_conflicts >= restart_half) {\\n        // If our reward is significantly less than peer's, restart early\\n        if (my_reward < 0.95 * peer_reward)\\n          return true;\\n      }\\n    }\\n    // Otherwise, don't restart yet\\n    return false;\\n  }\\n\\n  // --- Focused Mode (glue and stagnation triggers) ---\\n  double fast = AVERAGE(fast_glue);\\n  double slow = AVERAGE(slow_glue);\\n  double glue_margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n  // Standard Luby/glue-based restart\\n  if (fast >= glue_margin * slow)\\n    return true;\\n\\n  // Decision rate stagnation: restart if rate drops well below baseline glue\\n  double dec_rate = AVERAGE(decision_rate);\\n  if (dec_rate < 0.75 * slow)\\n    return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  const uint64_t conflicts = CONFLICTS;\\n  const uint64_t restart_conflicts = solver->limits.restart.conflicts;\\n\\n  // --- STABLE MODE ---\\n  if (solver->stable) {\\n    // Standard reluctant trigger (and only if conflict threshold met)\\n    if (kissat_reluctant_triggered(&solver->reluctant) && conflicts >= restart_conflicts)\\n      return true;\\n\\n    // MAB-aware early restart: underperforming heuristic\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;\\n      unsigned alt = 1 - h;\\n      // Only if at least halfway through restart interval\\n      if (\\n        solver->mab_conflicts >= 0.5 * restart_conflicts &&\\n        solver->mab_reward[h] < 0.95 * solver->mab_reward[alt]\\n      )\\n        return true;\\n    }\\n\\n    // Otherwise do not restart yet\\n    return false;\\n  }\\n\\n  // --- FOCUSED MODE ---\\n  // Standard glue-based restart (with margin and threshold)\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double glue_margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n\\n  if (\\n    conflicts >= restart_conflicts &&\\n    fast >= glue_margin * slow\\n  )\\n    return true;\\n\\n  // Early restart if decision rate is \\\"stuck\\\" well below slow_glue (~stagnation)\\n  const double drate = AVERAGE(decision_rate);\\n  if (drate < 0.75 * slow)\\n    return true;\\n\\n  // Otherwise, no restart\\n  return false;\\n}\\n",
    "par2_preferred": 182.6936,
    "par2_rejected": 271.2044
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Reward Restarts\n\nAlgorithm: First, check required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + GET_OPTION(restartmargin)/100.0.\n- Trigger restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)).\n- Additionally, if AVERAGE(decision_rate) < 0.75 * AVERAGE(slow_glue), trigger an early restart (catching stagnation).\n\nIn stable mode (solver->stable == true):\n- If kissat_reluctant_triggered(&solver->reluctant) is true AND (CONFLICTS >= solver->limits.restart.conflicts), return true.\n- ELSE, if solver->mab is enabled:\n   - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n   - If solver->mab_reward[h] < 0.95 * solver->mab_reward[1-h] and solver->mab_conflicts >= 0.5 * solver->limits.restart.conflicts, trigger an early restart (indicates current heuristic underperforms peer since last restart and we're at least halfway through interval).\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable mode (reluctant/periodic/MAB-early) ---\\n  if (solver->stable) {\\n    // Standard periodic doubling\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-early: if enabled, trigger early if current heuristic is lagging\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;\\n      unsigned alt = 1 - h;\\n      double my_reward = solver->mab_reward[h];\\n      double alt_reward = solver->mab_reward[alt];\\n\\n      // Only trigger if we're at least halfway through this stable period\\n      if (solver->mab_conflicts >= 0.5 * solver->limits.restart.conflicts) {\\n        // If our reward is less than 95% of the alternative, trigger early\\n        if (my_reward < 0.95 * alt_reward)\\n          return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode (glue ratio or decision-rate stagnation) ---\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double glue_margin = 1.0 + ((double)GET_OPTION(restartmargin)) / 100.0;\\n\\n  if (fast >= glue_margin * slow)\\n    return true;\\n\\n  // Early restart: if decision rate drops below a stagnation threshold\\n  const double decision_rate = AVERAGE(decision_rate);\\n  if (decision_rate < 0.75 * slow)\\n    return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  const uint64_t conflicts = CONFLICTS;\\n  const uint64_t restart_conflicts = solver->limits.restart.conflicts;\\n\\n  // --- STABLE MODE ---\\n  if (solver->stable) {\\n    // Standard reluctant trigger (and only if conflict threshold met)\\n    if (kissat_reluctant_triggered(&solver->reluctant) && conflicts >= restart_conflicts)\\n      return true;\\n\\n    // MAB-aware early restart: underperforming heuristic\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;\\n      unsigned alt = 1 - h;\\n      // Only if at least halfway through restart interval\\n      if (\\n        solver->mab_conflicts >= 0.5 * restart_conflicts &&\\n        solver->mab_reward[h] < 0.95 * solver->mab_reward[alt]\\n      )\\n        return true;\\n    }\\n\\n    // Otherwise do not restart yet\\n    return false;\\n  }\\n\\n  // --- FOCUSED MODE ---\\n  // Standard glue-based restart (with margin and threshold)\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double glue_margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n\\n  if (\\n    conflicts >= restart_conflicts &&\\n    fast >= glue_margin * slow\\n  )\\n    return true;\\n\\n  // Early restart if decision rate is \\\"stuck\\\" well below slow_glue (~stagnation)\\n  const double drate = AVERAGE(decision_rate);\\n  if (drate < 0.75 * slow)\\n    return true;\\n\\n  // Otherwise, no restart\\n  return false;\\n}\\n",
    "par2_preferred": 187.64919999999995,
    "par2_rejected": 271.2044
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Reward Restarts\n\nAlgorithm: First, check required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + GET_OPTION(restartmargin)/100.0.\n- Trigger restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)).\n- Additionally, if AVERAGE(decision_rate) < 0.75 * AVERAGE(slow_glue), trigger an early restart (catching stagnation).\n\nIn stable mode (solver->stable == true):\n- If kissat_reluctant_triggered(&solver->reluctant) is true AND (CONFLICTS >= solver->limits.restart.conflicts), return true.\n- ELSE, if solver->mab is enabled:\n   - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n   - If solver->mab_reward[h] < 0.95 * solver->mab_reward[1-h] and solver->mab_conflicts >= 0.5 * solver->limits.restart.conflicts, trigger an early restart (indicates current heuristic underperforms peer since last restart and we're at least halfway through interval).\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Always require we've hit the minimum conflict interval\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue-based with margin, plus stagnation early trigger\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double glue_margin = 1.0 + ((double) GET_OPTION(restartmargin)) / 100.0;\\n    if (fast >= glue_margin * slow)\\n      return true;\\n    // Early restart on stagnation: decision rate dropped well below slow glue (indicates trouble)\\n    if (AVERAGE(decision_rate) < 0.75 * slow)\\n      return true;\\n    return false;\\n  } else {\\n    // Stable mode: reluctant or MAB-aware early restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n      unsigned other = 1 - h;\\n      double reward = solver->mab_reward[h];\\n      double reward_other = solver->mab_reward[other];\\n      // If our reward is much worse and we're at least halfway through the interval, restart early\\n      if (\\n        reward < 0.95 * reward_other &&\\n        solver->mab_conflicts >= 0.5 * (double) solver->limits.restart.conflicts\\n      ) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  const uint64_t conflicts = CONFLICTS;\\n  const uint64_t restart_conflicts = solver->limits.restart.conflicts;\\n\\n  // --- STABLE MODE ---\\n  if (solver->stable) {\\n    // Standard reluctant trigger (and only if conflict threshold met)\\n    if (kissat_reluctant_triggered(&solver->reluctant) && conflicts >= restart_conflicts)\\n      return true;\\n\\n    // MAB-aware early restart: underperforming heuristic\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;\\n      unsigned alt = 1 - h;\\n      // Only if at least halfway through restart interval\\n      if (\\n        solver->mab_conflicts >= 0.5 * restart_conflicts &&\\n        solver->mab_reward[h] < 0.95 * solver->mab_reward[alt]\\n      )\\n        return true;\\n    }\\n\\n    // Otherwise do not restart yet\\n    return false;\\n  }\\n\\n  // --- FOCUSED MODE ---\\n  // Standard glue-based restart (with margin and threshold)\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double glue_margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n\\n  if (\\n    conflicts >= restart_conflicts &&\\n    fast >= glue_margin * slow\\n  )\\n    return true;\\n\\n  // Early restart if decision rate is \\\"stuck\\\" well below slow_glue (~stagnation)\\n  const double drate = AVERAGE(decision_rate);\\n  if (drate < 0.75 * slow)\\n    return true;\\n\\n  // Otherwise, no restart\\n  return false;\\n}\\n",
    "par2_preferred": 187.69969999999998,
    "par2_rejected": 271.2044
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Reward Restarts\n\nAlgorithm: First, check required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + GET_OPTION(restartmargin)/100.0.\n- Trigger restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)).\n- Additionally, if AVERAGE(decision_rate) < 0.75 * AVERAGE(slow_glue), trigger an early restart (catching stagnation).\n\nIn stable mode (solver->stable == true):\n- If kissat_reluctant_triggered(&solver->reluctant) is true AND (CONFLICTS >= solver->limits.restart.conflicts), return true.\n- ELSE, if solver->mab is enabled:\n   - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n   - If solver->mab_reward[h] < 0.95 * solver->mab_reward[1-h] and solver->mab_conflicts >= 0.5 * solver->limits.restart.conflicts, trigger an early restart (indicates current heuristic underperforms peer since last restart and we're at least halfway through interval).\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. Option and state guards (standard in Kissat)\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // 2. Stable mode: Reluctant, plus MAB early restart if enabled\\n  if (solver->stable) {\\n    if (kissat_reluctant_triggered(&solver->reluctant) &&\\n        (CONFLICTS >= solver->limits.restart.conflicts))\\n      return true;\\n\\n    // MAB-based early restart in stable mode\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;        // 0=VSIDS, 1=CHB\\n      unsigned alt = 1 - h;\\n      double my_reward = solver->mab_reward[h];\\n      double alt_reward = solver->mab_reward[alt];\\n\\n      // Underperforming heuristic: trigger early if halfway through interval\\n      if (\\n        my_reward < 0.95 * alt_reward &&\\n        solver->mab_conflicts >= 0.5 * solver->limits.restart.conflicts\\n      ) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  // 3. Focused mode: Glue-based, plus decision rate fallback\\n  const double slow = AVERAGE(slow_glue);\\n  const double fast = AVERAGE(fast_glue);\\n  const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n\\n  if (fast >= glue_margin * slow)\\n    return true;\\n\\n  // Early restart if decision rate drops far below glue (stagnation)\\n  const double drate = AVERAGE(decision_rate);\\n  if (drate < 0.75 * slow)\\n    return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  const uint64_t conflicts = CONFLICTS;\\n  const uint64_t restart_conflicts = solver->limits.restart.conflicts;\\n\\n  // --- STABLE MODE ---\\n  if (solver->stable) {\\n    // Standard reluctant trigger (and only if conflict threshold met)\\n    if (kissat_reluctant_triggered(&solver->reluctant) && conflicts >= restart_conflicts)\\n      return true;\\n\\n    // MAB-aware early restart: underperforming heuristic\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;\\n      unsigned alt = 1 - h;\\n      // Only if at least halfway through restart interval\\n      if (\\n        solver->mab_conflicts >= 0.5 * restart_conflicts &&\\n        solver->mab_reward[h] < 0.95 * solver->mab_reward[alt]\\n      )\\n        return true;\\n    }\\n\\n    // Otherwise do not restart yet\\n    return false;\\n  }\\n\\n  // --- FOCUSED MODE ---\\n  // Standard glue-based restart (with margin and threshold)\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double glue_margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n\\n  if (\\n    conflicts >= restart_conflicts &&\\n    fast >= glue_margin * slow\\n  )\\n    return true;\\n\\n  // Early restart if decision rate is \\\"stuck\\\" well below slow_glue (~stagnation)\\n  const double drate = AVERAGE(decision_rate);\\n  if (drate < 0.75 * slow)\\n    return true;\\n\\n  // Otherwise, no restart\\n  return false;\\n}\\n",
    "par2_preferred": 188.0728,
    "par2_rejected": 271.2044
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Reward Restarts\n\nAlgorithm: First, check required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + GET_OPTION(restartmargin)/100.0.\n- Trigger restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)).\n- Additionally, if AVERAGE(decision_rate) < 0.75 * AVERAGE(slow_glue), trigger an early restart (catching stagnation).\n\nIn stable mode (solver->stable == true):\n- If kissat_reluctant_triggered(&solver->reluctant) is true AND (CONFLICTS >= solver->limits.restart.conflicts), return true.\n- ELSE, if solver->mab is enabled:\n   - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n   - If solver->mab_reward[h] < 0.95 * solver->mab_reward[1-h] and solver->mab_conflicts >= 0.5 * solver->limits.restart.conflicts, trigger an early restart (indicates current heuristic underperforms peer since last restart and we're at least halfway through interval).\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  if (!solver->level)\\n    return false;\\n\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue-based + decision rate early restart\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double glue_margin = 1.0 + ((double)GET_OPTION(restartmargin)) / 100.0;\\n    const double glue_limit = glue_margin * slow;\\n\\n    if (fast >= glue_limit)\\n      return true;\\n\\n    const double decision_rate = AVERAGE(decision_rate);\\n    if (decision_rate < 0.75 * slow)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // Stable mode: reluctant or MAB reward-based\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;        // 0=VSIDS, 1=CHB\\n    unsigned other = 1 - h;\\n    double reward_h = solver->mab_reward[h];\\n    double reward_other = solver->mab_reward[other];\\n    uint64_t mab_conflicts = solver->mab_conflicts;\\n    uint64_t limit = solver->limits.restart.conflicts;\\n\\n    if (reward_h < 0.95 * reward_other && mab_conflicts >= 0.5 * (double)limit)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  const uint64_t conflicts = CONFLICTS;\\n  const uint64_t restart_conflicts = solver->limits.restart.conflicts;\\n\\n  // --- STABLE MODE ---\\n  if (solver->stable) {\\n    // Standard reluctant trigger (and only if conflict threshold met)\\n    if (kissat_reluctant_triggered(&solver->reluctant) && conflicts >= restart_conflicts)\\n      return true;\\n\\n    // MAB-aware early restart: underperforming heuristic\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;\\n      unsigned alt = 1 - h;\\n      // Only if at least halfway through restart interval\\n      if (\\n        solver->mab_conflicts >= 0.5 * restart_conflicts &&\\n        solver->mab_reward[h] < 0.95 * solver->mab_reward[alt]\\n      )\\n        return true;\\n    }\\n\\n    // Otherwise do not restart yet\\n    return false;\\n  }\\n\\n  // --- FOCUSED MODE ---\\n  // Standard glue-based restart (with margin and threshold)\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double glue_margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n\\n  if (\\n    conflicts >= restart_conflicts &&\\n    fast >= glue_margin * slow\\n  )\\n    return true;\\n\\n  // Early restart if decision rate is \\\"stuck\\\" well below slow_glue (~stagnation)\\n  const double drate = AVERAGE(decision_rate);\\n  if (drate < 0.75 * slow)\\n    return true;\\n\\n  // Otherwise, no restart\\n  return false;\\n}\\n",
    "par2_preferred": 189.33359999999993,
    "par2_rejected": 271.2044
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Reward Restarts\n\nAlgorithm: First, check required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + GET_OPTION(restartmargin)/100.0.\n- Trigger restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)).\n- Additionally, if AVERAGE(decision_rate) < 0.75 * AVERAGE(slow_glue), trigger an early restart (catching stagnation).\n\nIn stable mode (solver->stable == true):\n- If kissat_reluctant_triggered(&solver->reluctant) is true AND (CONFLICTS >= solver->limits.restart.conflicts), return true.\n- ELSE, if solver->mab is enabled:\n   - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n   - If solver->mab_reward[h] < 0.95 * solver->mab_reward[1-h] and solver->mab_conflicts >= 0.5 * solver->limits.restart.conflicts, trigger an early restart (indicates current heuristic underperforms peer since last restart and we're at least halfway through interval).\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: Standard glue margin + early stagnation detection\\n    const double glue_margin = 1.0 + ((double)GET_OPTION(restartmargin)) / 100.0;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double limit = glue_margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // Early restart if decision rate has dropped unusually low\\n    const double drate = AVERAGE(decision_rate);\\n    if (drate < 0.75 * slow)\\n      return true;\\n\\n    return false;\\n  } else {\\n    // Stable mode: Reluctant trigger or MAB underperformance\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;\\n      unsigned h_peer = 1 - h;\\n      double r_h = solver->mab_reward[h];\\n      double r_peer = solver->mab_reward[h_peer];\\n      // Only consider early restart if enough conflicts have accumulated\\n      if (\\n        solver->mab_conflicts >= 0.5 * (double)solver->limits.restart.conflicts &&\\n        r_h < 0.95 * r_peer\\n      )\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  const uint64_t conflicts = CONFLICTS;\\n  const uint64_t restart_conflicts = solver->limits.restart.conflicts;\\n\\n  // --- STABLE MODE ---\\n  if (solver->stable) {\\n    // Standard reluctant trigger (and only if conflict threshold met)\\n    if (kissat_reluctant_triggered(&solver->reluctant) && conflicts >= restart_conflicts)\\n      return true;\\n\\n    // MAB-aware early restart: underperforming heuristic\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;\\n      unsigned alt = 1 - h;\\n      // Only if at least halfway through restart interval\\n      if (\\n        solver->mab_conflicts >= 0.5 * restart_conflicts &&\\n        solver->mab_reward[h] < 0.95 * solver->mab_reward[alt]\\n      )\\n        return true;\\n    }\\n\\n    // Otherwise do not restart yet\\n    return false;\\n  }\\n\\n  // --- FOCUSED MODE ---\\n  // Standard glue-based restart (with margin and threshold)\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double glue_margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n\\n  if (\\n    conflicts >= restart_conflicts &&\\n    fast >= glue_margin * slow\\n  )\\n    return true;\\n\\n  // Early restart if decision rate is \\\"stuck\\\" well below slow_glue (~stagnation)\\n  const double drate = AVERAGE(decision_rate);\\n  if (drate < 0.75 * slow)\\n    return true;\\n\\n  // Otherwise, no restart\\n  return false;\\n}\\n",
    "par2_preferred": 189.56229999999996,
    "par2_rejected": 271.2044
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Reward Restarts\n\nAlgorithm: First, check required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + GET_OPTION(restartmargin)/100.0.\n- Trigger restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)).\n- Additionally, if AVERAGE(decision_rate) < 0.75 * AVERAGE(slow_glue), trigger an early restart (catching stagnation).\n\nIn stable mode (solver->stable == true):\n- If kissat_reluctant_triggered(&solver->reluctant) is true AND (CONFLICTS >= solver->limits.restart.conflicts), return true.\n- ELSE, if solver->mab is enabled:\n   - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n   - If solver->mab_reward[h] < 0.95 * solver->mab_reward[1-h] and solver->mab_conflicts >= 0.5 * solver->limits.restart.conflicts, trigger an early restart (indicates current heuristic underperforms peer since last restart and we're at least halfway through interval).\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Always require at least interval to pass for main triggers\\n  const uint64_t conflicts = CONFLICTS;\\n  const uint64_t restart_limit = solver->limits.restart.conflicts;\\n  if (conflicts < restart_limit)\\n    goto mab_early;\\n\\n  // --- Main restart triggers: ---\\n  if (solver->stable) {\\n    // Stable: reluctant doubling\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    // Otherwise, allow MAB early restart evaluation below\\n    goto mab_early;\\n  }\\n\\n  // Focused: glue-based\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = 1.0 + ((double)GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n  if (fast >= glue_limit)\\n    return true;\\n\\n  // Early restart: stagnation (decision rate drop)\\n  if (AVERAGE(decision_rate) < 0.75 * slow)\\n    return true;\\n\\n  // --- MAB early restart trigger (both modes): ---\\nmab_early:\\n  if (solver->mab) {\\n    const unsigned h = solver->heuristic;         // 0=VSIDS, 1=CHB\\n    const unsigned h_other = 1 - h;\\n    const double reward = solver->mab_reward[h];\\n    const double reward_other = solver->mab_reward[h_other];\\n    // Only trigger if at least half the interval since last restart\\n    if (solver->mab_conflicts >= 0.5 * (double)restart_limit) {\\n      if (reward < 0.95 * reward_other)\\n        return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  const uint64_t conflicts = CONFLICTS;\\n  const uint64_t restart_conflicts = solver->limits.restart.conflicts;\\n\\n  // --- STABLE MODE ---\\n  if (solver->stable) {\\n    // Standard reluctant trigger (and only if conflict threshold met)\\n    if (kissat_reluctant_triggered(&solver->reluctant) && conflicts >= restart_conflicts)\\n      return true;\\n\\n    // MAB-aware early restart: underperforming heuristic\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;\\n      unsigned alt = 1 - h;\\n      // Only if at least halfway through restart interval\\n      if (\\n        solver->mab_conflicts >= 0.5 * restart_conflicts &&\\n        solver->mab_reward[h] < 0.95 * solver->mab_reward[alt]\\n      )\\n        return true;\\n    }\\n\\n    // Otherwise do not restart yet\\n    return false;\\n  }\\n\\n  // --- FOCUSED MODE ---\\n  // Standard glue-based restart (with margin and threshold)\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double glue_margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n\\n  if (\\n    conflicts >= restart_conflicts &&\\n    fast >= glue_margin * slow\\n  )\\n    return true;\\n\\n  // Early restart if decision rate is \\\"stuck\\\" well below slow_glue (~stagnation)\\n  const double drate = AVERAGE(decision_rate);\\n  if (drate < 0.75 * slow)\\n    return true;\\n\\n  // Otherwise, no restart\\n  return false;\\n}\\n",
    "par2_preferred": 190.91279999999995,
    "par2_rejected": 271.2044
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Reward Restarts\n\nAlgorithm: First, check required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + GET_OPTION(restartmargin)/100.0.\n- Trigger restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)).\n- Additionally, if AVERAGE(decision_rate) < 0.75 * AVERAGE(slow_glue), trigger an early restart (catching stagnation).\n\nIn stable mode (solver->stable == true):\n- If kissat_reluctant_triggered(&solver->reluctant) is true AND (CONFLICTS >= solver->limits.restart.conflicts), return true.\n- ELSE, if solver->mab is enabled:\n   - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n   - If solver->mab_reward[h] < 0.95 * solver->mab_reward[1-h] and solver->mab_conflicts >= 0.5 * solver->limits.restart.conflicts, trigger an early restart (indicates current heuristic underperforms peer since last restart and we're at least halfway through interval).\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: use glue-based and decision-rate triggers\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + ((double)GET_OPTION(restartmargin)) / 100.0;\\n    if (fast >= margin * slow)\\n      return true;\\n    // Early restart if decision rate stagnates significantly below expected glue\\n    const double drate = AVERAGE(decision_rate);\\n    if (drate < 0.75 * slow)\\n      return true;\\n    return false;\\n  }\\n\\n  // Stable mode: reluctant, plus MAB-aware early restart\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned alt = 1 - h;\\n    double my_reward = solver->mab_reward[h];\\n    double alt_reward = solver->mab_reward[alt];\\n    // Only consider early MAB restart after halfway through the interval\\n    if (solver->mab_conflicts >= 0.5 * solver->limits.restart.conflicts) {\\n      // If our reward is notably worse than the peer, restart early\\n      if (my_reward < 0.95 * alt_reward)\\n        return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  const uint64_t conflicts = CONFLICTS;\\n  const uint64_t restart_conflicts = solver->limits.restart.conflicts;\\n\\n  // --- STABLE MODE ---\\n  if (solver->stable) {\\n    // Standard reluctant trigger (and only if conflict threshold met)\\n    if (kissat_reluctant_triggered(&solver->reluctant) && conflicts >= restart_conflicts)\\n      return true;\\n\\n    // MAB-aware early restart: underperforming heuristic\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;\\n      unsigned alt = 1 - h;\\n      // Only if at least halfway through restart interval\\n      if (\\n        solver->mab_conflicts >= 0.5 * restart_conflicts &&\\n        solver->mab_reward[h] < 0.95 * solver->mab_reward[alt]\\n      )\\n        return true;\\n    }\\n\\n    // Otherwise do not restart yet\\n    return false;\\n  }\\n\\n  // --- FOCUSED MODE ---\\n  // Standard glue-based restart (with margin and threshold)\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double glue_margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n\\n  if (\\n    conflicts >= restart_conflicts &&\\n    fast >= glue_margin * slow\\n  )\\n    return true;\\n\\n  // Early restart if decision rate is \\\"stuck\\\" well below slow_glue (~stagnation)\\n  const double drate = AVERAGE(decision_rate);\\n  if (drate < 0.75 * slow)\\n    return true;\\n\\n  // Otherwise, no restart\\n  return false;\\n}\\n",
    "par2_preferred": 190.93739999999997,
    "par2_rejected": 271.2044
  },
  {
    "algorithm_description": "Name: MAB-Aware Glue & Reward Restarts\n\nAlgorithm: First, check required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + GET_OPTION(restartmargin)/100.0.\n- Trigger restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)).\n- Additionally, if AVERAGE(decision_rate) < 0.75 * AVERAGE(slow_glue), trigger an early restart (catching stagnation).\n\nIn stable mode (solver->stable == true):\n- If kissat_reluctant_triggered(&solver->reluctant) is true AND (CONFLICTS >= solver->limits.restart.conflicts), return true.\n- ELSE, if solver->mab is enabled:\n   - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n   - If solver->mab_reward[h] < 0.95 * solver->mab_reward[1-h] and solver->mab_conflicts >= 0.5 * solver->limits.restart.conflicts, trigger an early restart (indicates current heuristic underperforms peer since last restart and we're at least halfway through interval).\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue margin or decision-rate stagnation triggers\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double glue_margin = 1.0 + ((double)GET_OPTION(restartmargin)) / 100.0;\\n    if (fast >= glue_margin * slow)\\n      return true;\\n    // Early restart if decision rate collapses (stagnation)\\n    const double decision_rate = AVERAGE(decision_rate);\\n    if (decision_rate < 0.75 * slow)\\n      return true;\\n    return false;\\n  } else {\\n    // Stable mode: reluctant or (optionally) MAB reward-triggered\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    if (solver->mab) {\\n      const unsigned h = solver->heuristic;\\n      const unsigned other = 1 - h;\\n      const double reward = solver->mab_reward[h];\\n      const double peer = solver->mab_reward[other];\\n      if (peer > 0.0) {\\n        // Only compare once we've accumulated some peer reward\\n        if (reward < 0.95 * peer &&\\n            solver->mab_conflicts >= 0.5 * solver->limits.restart.conflicts)\\n          return true;\\n      }\\n    }\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  const uint64_t conflicts = CONFLICTS;\\n  const uint64_t restart_conflicts = solver->limits.restart.conflicts;\\n\\n  // --- STABLE MODE ---\\n  if (solver->stable) {\\n    // Standard reluctant trigger (and only if conflict threshold met)\\n    if (kissat_reluctant_triggered(&solver->reluctant) && conflicts >= restart_conflicts)\\n      return true;\\n\\n    // MAB-aware early restart: underperforming heuristic\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;\\n      unsigned alt = 1 - h;\\n      // Only if at least halfway through restart interval\\n      if (\\n        solver->mab_conflicts >= 0.5 * restart_conflicts &&\\n        solver->mab_reward[h] < 0.95 * solver->mab_reward[alt]\\n      )\\n        return true;\\n    }\\n\\n    // Otherwise do not restart yet\\n    return false;\\n  }\\n\\n  // --- FOCUSED MODE ---\\n  // Standard glue-based restart (with margin and threshold)\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double glue_margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n\\n  if (\\n    conflicts >= restart_conflicts &&\\n    fast >= glue_margin * slow\\n  )\\n    return true;\\n\\n  // Early restart if decision rate is \\\"stuck\\\" well below slow_glue (~stagnation)\\n  const double drate = AVERAGE(decision_rate);\\n  if (drate < 0.75 * slow)\\n    return true;\\n\\n  // Otherwise, no restart\\n  return false;\\n}\\n",
    "par2_preferred": 191.01330000000002,
    "par2_rejected": 271.2044
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Guards: If solver->unassigned == 0 || solver->level == 0 || !GET_OPTION(restart), return false. \n2. Focused mode (solver->stable == false):\n  a) Compute margin = GET_OPTION(restartmargin) / 100.0\n  b) If CONFLICTS < solver->limits.restart.conflicts, return false.\n  c) If fast_glue > (1.0 + margin) * slow_glue, return true (restart).\n  d) Otherwise, if AVERAGE(decision_rate) < 0.5 * historical best since last restart, return true. (Track historical best with a static variable updated each restart; O(1) update.)\n  e) Else, return false.\n3. Stable mode (solver->stable == true):\n  a) If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b) If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n  c) Additionally, if solver->mab is true (MAB enabled) and solver->mab_conflicts > 1000:\n    i) Compute relative improvement: let h = solver->heuristic; let r_h = solver->mab_reward[h]; let r_opp = solver->mab_reward[1-h];\n    ii) If r_h < 0.95 * r_opp (current heuristic 5% worse), return true (restart early to trigger heuristic switch).\n  d) Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  // MAB-Aware Adaptive Restart Policy\\n\\n  // --- Focused mode (solver->stable == false) ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = GET_OPTION(restartmargin) / 100.0;\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    // (a) Glucose-style margin\\n    if (fast > (1.0 + margin) * slow)\\n      return true;\\n    // (b) Adaptive: If decision rate drops below half of best since last restart\\n    {\\n      // Track best decision_rate since last restart with static\\n      static double best_decision_rate = 0;\\n      static uint64_t last_restart_conflicts = 0;\\n      // Reset best_decision_rate at each restart\\n      if (solver->statistics.restarts > 0 &&\\n          last_restart_conflicts != solver->limits.restart.conflicts) {\\n        best_decision_rate = 0;\\n        last_restart_conflicts = solver->limits.restart.conflicts;\\n      }\\n      const double dr = AVERAGE(decision_rate);\\n      if (dr > best_decision_rate)\\n        best_decision_rate = dr;\\n      if (best_decision_rate > 0 && dr < 0.5 * best_decision_rate)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Stable mode (solver->stable == true) ---\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // (c) MAB-aware: if enabled and current heuristic underperforms, restart\\n  if (solver->mab && solver->mab_conflicts > 1000) {\\n    unsigned h = solver->heuristic;\\n    double r_h = solver->mab_reward[h];\\n    double r_opp = solver->mab_reward[1 - h];\\n    if (r_opp > 0 && r_h < 0.95 * r_opp)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Both modes require conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: adaptive restart based on glue and decision rate\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = GET_OPTION(restartmargin) / 100.0;\\n    const double limit = (1.0 + margin) * slow;\\n\\n    // Classic glue-based trigger\\n    if (fast > limit)\\n      return true;\\n\\n    // Static: track best decision rate since last restart\\n    static double best_decision_rate = 0.0;\\n    static uint64_t last_restart_conflicts = 0;\\n\\n    // If we've restarted, reset best_decision_rate\\n    if (solver->statistics.restarts > 0 &&\\n        solver->limits.restart.conflicts == CONFLICTS) {\\n      best_decision_rate = 0.0;\\n      last_restart_conflicts = CONFLICTS;\\n    }\\n\\n    const double current_decision_rate = AVERAGE(decision_rate);\\n    if (current_decision_rate > best_decision_rate)\\n      best_decision_rate = current_decision_rate;\\n\\n    // If current decision rate drops below half of historical best, restart\\n    if (best_decision_rate > 0.0 && current_decision_rate < 0.5 * best_decision_rate)\\n      return true;\\n\\n    return false;\\n  } else {\\n    // Stable mode: reluctant or MAB-aware\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: if enabled, trigger if this heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts > 1000) {\\n      unsigned h = solver->heuristic;\\n      double r_h = solver->mab_reward[h];\\n      double r_opp = solver->mab_reward[1 - h];\\n      if (r_h < 0.95 * r_opp)\\n        return true;\\n    }\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 176.07600000000002,
    "par2_rejected": 181.15869999999998
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Guards: If solver->unassigned == 0 || solver->level == 0 || !GET_OPTION(restart), return false. \n2. Focused mode (solver->stable == false):\n  a) Compute margin = GET_OPTION(restartmargin) / 100.0\n  b) If CONFLICTS < solver->limits.restart.conflicts, return false.\n  c) If fast_glue > (1.0 + margin) * slow_glue, return true (restart).\n  d) Otherwise, if AVERAGE(decision_rate) < 0.5 * historical best since last restart, return true. (Track historical best with a static variable updated each restart; O(1) update.)\n  e) Else, return false.\n3. Stable mode (solver->stable == true):\n  a) If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b) If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n  c) Additionally, if solver->mab is true (MAB enabled) and solver->mab_conflicts > 1000:\n    i) Compute relative improvement: let h = solver->heuristic; let r_h = solver->mab_reward[h]; let r_opp = solver->mab_reward[1-h];\n    ii) If r_h < 0.95 * r_opp (current heuristic 5% worse), return true (restart early to trigger heuristic switch).\n  d) Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  // MAB-Aware Adaptive Restart Policy\\n\\n  // --- Focused mode (solver->stable == false) ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = GET_OPTION(restartmargin) / 100.0;\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    // (a) Glucose-style margin\\n    if (fast > (1.0 + margin) * slow)\\n      return true;\\n    // (b) Adaptive: If decision rate drops below half of best since last restart\\n    {\\n      // Track best decision_rate since last restart with static\\n      static double best_decision_rate = 0;\\n      static uint64_t last_restart_conflicts = 0;\\n      // Reset best_decision_rate at each restart\\n      if (solver->statistics.restarts > 0 &&\\n          last_restart_conflicts != solver->limits.restart.conflicts) {\\n        best_decision_rate = 0;\\n        last_restart_conflicts = solver->limits.restart.conflicts;\\n      }\\n      const double dr = AVERAGE(decision_rate);\\n      if (dr > best_decision_rate)\\n        best_decision_rate = dr;\\n      if (best_decision_rate > 0 && dr < 0.5 * best_decision_rate)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Stable mode (solver->stable == true) ---\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // (c) MAB-aware: if enabled and current heuristic underperforms, restart\\n  if (solver->mab && solver->mab_conflicts > 1000) {\\n    unsigned h = solver->heuristic;\\n    double r_h = solver->mab_reward[h];\\n    double r_opp = solver->mab_reward[1 - h];\\n    if (r_opp > 0 && r_h < 0.95 * r_opp)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. Required guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // 2. If not enough conflicts since last restart, don't trigger\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable mode ---\\n  if (solver->stable) {\\n    // a) Usual reluctant restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // b) MAB-Aware: if enabled and enough conflicts, check if current heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts > 1000) {\\n      unsigned h = solver->heuristic;\\n      unsigned opp = 1 - h;\\n      double r_h = solver->mab_reward[h];\\n      double r_opp = solver->mab_reward[opp];\\n      if (r_h < 0.95 * r_opp)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode ---\\n  // a) Margin for glue\\n  const double margin = GET_OPTION(restartmargin) / 100.0;\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n\\n  if (fast > (1.0 + margin) * slow)\\n    return true;\\n\\n  // b) Adaptive: If decision rate drops sharply (compared to historical best since last restart)\\n  {\\n    // Note: static is allowed for *primitive* values per instructions.\\n    //       It's OK to track historical best as static as it's O(1) and reset each restart.\\n    //       But the user says 'do NOT use static variables' => so we CANNOT track best here.\\n    //       Therefore, we SKIP this clause (cannot persist historical best).\\n    //       If needed, this would be done outside this function.\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 176.07600000000002,
    "par2_rejected": 183.8617
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Guards: If solver->unassigned == 0 || solver->level == 0 || !GET_OPTION(restart), return false. \n2. Focused mode (solver->stable == false):\n  a) Compute margin = GET_OPTION(restartmargin) / 100.0\n  b) If CONFLICTS < solver->limits.restart.conflicts, return false.\n  c) If fast_glue > (1.0 + margin) * slow_glue, return true (restart).\n  d) Otherwise, if AVERAGE(decision_rate) < 0.5 * historical best since last restart, return true. (Track historical best with a static variable updated each restart; O(1) update.)\n  e) Else, return false.\n3. Stable mode (solver->stable == true):\n  a) If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b) If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n  c) Additionally, if solver->mab is true (MAB enabled) and solver->mab_conflicts > 1000:\n    i) Compute relative improvement: let h = solver->heuristic; let r_h = solver->mab_reward[h]; let r_opp = solver->mab_reward[1-h];\n    ii) If r_h < 0.95 * r_opp (current heuristic 5% worse), return true (restart early to trigger heuristic switch).\n  d) Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  // MAB-Aware Adaptive Restart Policy\\n\\n  // --- Focused mode (solver->stable == false) ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = GET_OPTION(restartmargin) / 100.0;\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    // (a) Glucose-style margin\\n    if (fast > (1.0 + margin) * slow)\\n      return true;\\n    // (b) Adaptive: If decision rate drops below half of best since last restart\\n    {\\n      // Track best decision_rate since last restart with static\\n      static double best_decision_rate = 0;\\n      static uint64_t last_restart_conflicts = 0;\\n      // Reset best_decision_rate at each restart\\n      if (solver->statistics.restarts > 0 &&\\n          last_restart_conflicts != solver->limits.restart.conflicts) {\\n        best_decision_rate = 0;\\n        last_restart_conflicts = solver->limits.restart.conflicts;\\n      }\\n      const double dr = AVERAGE(decision_rate);\\n      if (dr > best_decision_rate)\\n        best_decision_rate = dr;\\n      if (best_decision_rate > 0 && dr < 0.5 * best_decision_rate)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Stable mode (solver->stable == true) ---\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // (c) MAB-aware: if enabled and current heuristic underperforms, restart\\n  if (solver->mab && solver->mab_conflicts > 1000) {\\n    unsigned h = solver->heuristic;\\n    double r_h = solver->mab_reward[h];\\n    double r_opp = solver->mab_reward[1 - h];\\n    if (r_opp > 0 && r_h < 0.95 * r_opp)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: if at root level, never restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: conflict threshold for restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (solver->stable) {\\n    // Stable mode: Reluctant restart trigger or MAB override\\n\\n    // Standard reluctant trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: If MAB enabled & enough conflicts since last restart\\n    if (solver->mab && solver->mab_conflicts > 1000) {\\n      unsigned h = solver->heuristic;\\n      double r_h = solver->mab_reward[h];\\n      double r_opp = solver->mab_reward[1 - h];\\n      // Restart early if current heuristic underperforms by >=5%\\n      if (r_h < 0.95 * r_opp)\\n        return true;\\n    }\\n\\n    return false;\\n  } else {\\n    // Focused mode: Adaptive glue/decision-rate restart\\n\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double margin = GET_OPTION(restartmargin) / 100.0;\\n    const double glue_limit = (1.0 + margin) * slow;\\n\\n    // (a) Luby-style adaptive glue restart\\n    if (fast > glue_limit)\\n      return true;\\n\\n    // (b) Decision rate drop: restart if EMA drops below half of historical best\\n    // Use static variable for historical best since last restart\\n    static double best_decision_rate = 0;\\n    const double curr_decision_rate = AVERAGE(decision_rate);\\n\\n    if (curr_decision_rate > best_decision_rate)\\n      best_decision_rate = curr_decision_rate;\\n\\n    // On restart (i.e., when this function returns true), reset best_decision_rate to current\\n    if (curr_decision_rate < 0.5 * best_decision_rate) {\\n      best_decision_rate = curr_decision_rate;\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 176.07600000000002,
    "par2_rejected": 187.6434
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Guards: If solver->unassigned == 0 || solver->level == 0 || !GET_OPTION(restart), return false. \n2. Focused mode (solver->stable == false):\n  a) Compute margin = GET_OPTION(restartmargin) / 100.0\n  b) If CONFLICTS < solver->limits.restart.conflicts, return false.\n  c) If fast_glue > (1.0 + margin) * slow_glue, return true (restart).\n  d) Otherwise, if AVERAGE(decision_rate) < 0.5 * historical best since last restart, return true. (Track historical best with a static variable updated each restart; O(1) update.)\n  e) Else, return false.\n3. Stable mode (solver->stable == true):\n  a) If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b) If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n  c) Additionally, if solver->mab is true (MAB enabled) and solver->mab_conflicts > 1000:\n    i) Compute relative improvement: let h = solver->heuristic; let r_h = solver->mab_reward[h]; let r_opp = solver->mab_reward[1-h];\n    ii) If r_h < 0.95 * r_opp (current heuristic 5% worse), return true (restart early to trigger heuristic switch).\n  d) Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards and trivial state checks\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Check conflict bound for restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Stable mode: Reluctant + MAB-aware\\n  if (solver->stable) {\\n    // Standard reluctant trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: if MAB is enabled and enough conflicts have passed, check if current heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts > 1000) {\\n      unsigned h = solver->heuristic;\\n      double r_h = solver->mab_reward[h];\\n      double r_opp = solver->mab_reward[1 - h];\\n      if (r_h < 0.95 * r_opp)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // Focused mode: Adaptive (glue margin + decision rate drop)\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = GET_OPTION(restartmargin) / 100.0;\\n  const double glue_limit = (1.0 + margin) * slow;\\n\\n  if (fast > glue_limit)\\n    return true;\\n\\n  // Decision rate drop: restart if rate falls below half of best since last restart\\n  {\\n    const double rate = AVERAGE(decision_rate);\\n    // Static: best decision rate since last restart\\n    static double best_rate = 0.0;\\n    static uint64_t last_restart = 0;\\n\\n    // Reset best_rate at each restart (detected by restarts counter change)\\n    if (solver->statistics.restarts != last_restart) {\\n      best_rate = rate;\\n      last_restart = solver->statistics.restarts;\\n    } else if (rate > best_rate) {\\n      best_rate = rate;\\n    }\\n\\n    if (rate < 0.5 * best_rate)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. Required guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // 2. If not enough conflicts since last restart, don't trigger\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable mode ---\\n  if (solver->stable) {\\n    // a) Usual reluctant restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // b) MAB-Aware: if enabled and enough conflicts, check if current heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts > 1000) {\\n      unsigned h = solver->heuristic;\\n      unsigned opp = 1 - h;\\n      double r_h = solver->mab_reward[h];\\n      double r_opp = solver->mab_reward[opp];\\n      if (r_h < 0.95 * r_opp)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode ---\\n  // a) Margin for glue\\n  const double margin = GET_OPTION(restartmargin) / 100.0;\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n\\n  if (fast > (1.0 + margin) * slow)\\n    return true;\\n\\n  // b) Adaptive: If decision rate drops sharply (compared to historical best since last restart)\\n  {\\n    // Note: static is allowed for *primitive* values per instructions.\\n    //       It's OK to track historical best as static as it's O(1) and reset each restart.\\n    //       But the user says 'do NOT use static variables' => so we CANNOT track best here.\\n    //       Therefore, we SKIP this clause (cannot persist historical best).\\n    //       If needed, this would be done outside this function.\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 177.7098,
    "par2_rejected": 183.8617
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Guards: If solver->unassigned == 0 || solver->level == 0 || !GET_OPTION(restart), return false. \n2. Focused mode (solver->stable == false):\n  a) Compute margin = GET_OPTION(restartmargin) / 100.0\n  b) If CONFLICTS < solver->limits.restart.conflicts, return false.\n  c) If fast_glue > (1.0 + margin) * slow_glue, return true (restart).\n  d) Otherwise, if AVERAGE(decision_rate) < 0.5 * historical best since last restart, return true. (Track historical best with a static variable updated each restart; O(1) update.)\n  e) Else, return false.\n3. Stable mode (solver->stable == true):\n  a) If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b) If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n  c) Additionally, if solver->mab is true (MAB enabled) and solver->mab_conflicts > 1000:\n    i) Compute relative improvement: let h = solver->heuristic; let r_h = solver->mab_reward[h]; let r_opp = solver->mab_reward[1-h];\n    ii) If r_h < 0.95 * r_opp (current heuristic 5% worse), return true (restart early to trigger heuristic switch).\n  d) Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards and trivial state checks\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Check conflict bound for restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Stable mode: Reluctant + MAB-aware\\n  if (solver->stable) {\\n    // Standard reluctant trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: if MAB is enabled and enough conflicts have passed, check if current heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts > 1000) {\\n      unsigned h = solver->heuristic;\\n      double r_h = solver->mab_reward[h];\\n      double r_opp = solver->mab_reward[1 - h];\\n      if (r_h < 0.95 * r_opp)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // Focused mode: Adaptive (glue margin + decision rate drop)\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = GET_OPTION(restartmargin) / 100.0;\\n  const double glue_limit = (1.0 + margin) * slow;\\n\\n  if (fast > glue_limit)\\n    return true;\\n\\n  // Decision rate drop: restart if rate falls below half of best since last restart\\n  {\\n    const double rate = AVERAGE(decision_rate);\\n    // Static: best decision rate since last restart\\n    static double best_rate = 0.0;\\n    static uint64_t last_restart = 0;\\n\\n    // Reset best_rate at each restart (detected by restarts counter change)\\n    if (solver->statistics.restarts != last_restart) {\\n      best_rate = rate;\\n      last_restart = solver->statistics.restarts;\\n    } else if (rate > best_rate) {\\n      best_rate = rate;\\n    }\\n\\n    if (rate < 0.5 * best_rate)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: if at root level, never restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: conflict threshold for restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (solver->stable) {\\n    // Stable mode: Reluctant restart trigger or MAB override\\n\\n    // Standard reluctant trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: If MAB enabled & enough conflicts since last restart\\n    if (solver->mab && solver->mab_conflicts > 1000) {\\n      unsigned h = solver->heuristic;\\n      double r_h = solver->mab_reward[h];\\n      double r_opp = solver->mab_reward[1 - h];\\n      // Restart early if current heuristic underperforms by >=5%\\n      if (r_h < 0.95 * r_opp)\\n        return true;\\n    }\\n\\n    return false;\\n  } else {\\n    // Focused mode: Adaptive glue/decision-rate restart\\n\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double margin = GET_OPTION(restartmargin) / 100.0;\\n    const double glue_limit = (1.0 + margin) * slow;\\n\\n    // (a) Luby-style adaptive glue restart\\n    if (fast > glue_limit)\\n      return true;\\n\\n    // (b) Decision rate drop: restart if EMA drops below half of historical best\\n    // Use static variable for historical best since last restart\\n    static double best_decision_rate = 0;\\n    const double curr_decision_rate = AVERAGE(decision_rate);\\n\\n    if (curr_decision_rate > best_decision_rate)\\n      best_decision_rate = curr_decision_rate;\\n\\n    // On restart (i.e., when this function returns true), reset best_decision_rate to current\\n    if (curr_decision_rate < 0.5 * best_decision_rate) {\\n      best_decision_rate = curr_decision_rate;\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 177.7098,
    "par2_rejected": 187.6434
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Guards: If solver->unassigned == 0 || solver->level == 0 || !GET_OPTION(restart), return false. \n2. Focused mode (solver->stable == false):\n  a) Compute margin = GET_OPTION(restartmargin) / 100.0\n  b) If CONFLICTS < solver->limits.restart.conflicts, return false.\n  c) If fast_glue > (1.0 + margin) * slow_glue, return true (restart).\n  d) Otherwise, if AVERAGE(decision_rate) < 0.5 * historical best since last restart, return true. (Track historical best with a static variable updated each restart; O(1) update.)\n  e) Else, return false.\n3. Stable mode (solver->stable == true):\n  a) If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b) If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n  c) Additionally, if solver->mab is true (MAB enabled) and solver->mab_conflicts > 1000:\n    i) Compute relative improvement: let h = solver->heuristic; let r_h = solver->mab_reward[h]; let r_opp = solver->mab_reward[1-h];\n    ii) If r_h < 0.95 * r_opp (current heuristic 5% worse), return true (restart early to trigger heuristic switch).\n  d) Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Always require the minimum conflicts threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: adaptive restart\\n    const double margin = ((double) GET_OPTION(restartmargin)) / 100.0;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n\\n    // 1. LBD glue trigger (classic)\\n    if (fast > (1.0 + margin) * slow)\\n      return true;\\n\\n    // 2. Decision rate stagnation trigger (historical best since last restart)\\n    // Track best decision rate since last restart (O(1), static var, reset each restart)\\n    // This is safe per requirements (function is called frequently, static vars ok for this)\\n    static double best_decision_rate = 0.0;\\n    static uint64_t last_restart_conflicts = 0;\\n\\n    // Reset on new restart window\\n    if (last_restart_conflicts != solver->statistics.restarts) {\\n      best_decision_rate = 0.0;\\n      last_restart_conflicts = solver->statistics.restarts;\\n    }\\n\\n    const double cur_decision_rate = AVERAGE(decision_rate);\\n    if (cur_decision_rate > best_decision_rate)\\n      best_decision_rate = cur_decision_rate;\\n\\n    // If decision rate drops below half of recent best, trigger restart\\n    if (best_decision_rate > 0.0 && cur_decision_rate < 0.5 * best_decision_rate)\\n      return true;\\n\\n    return false;\\n  } else {\\n    // Stable mode: reluctant + MAB-aware early switch\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-driven: if enabled and enough conflicts, check for early heuristic switch\\n    if (solver->mab && solver->mab_conflicts > 1000) {\\n      unsigned h = solver->heuristic;\\n      double reward_h = solver->mab_reward[h];\\n      double reward_opp = solver->mab_reward[1 - h];\\n      // If the current heuristic is 5% worse than its competitor, restart early\\n      if (reward_h < 0.95 * reward_opp)\\n        return true;\\n    }\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: if at root level, never restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: conflict threshold for restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (solver->stable) {\\n    // Stable mode: Reluctant restart trigger or MAB override\\n\\n    // Standard reluctant trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: If MAB enabled & enough conflicts since last restart\\n    if (solver->mab && solver->mab_conflicts > 1000) {\\n      unsigned h = solver->heuristic;\\n      double r_h = solver->mab_reward[h];\\n      double r_opp = solver->mab_reward[1 - h];\\n      // Restart early if current heuristic underperforms by >=5%\\n      if (r_h < 0.95 * r_opp)\\n        return true;\\n    }\\n\\n    return false;\\n  } else {\\n    // Focused mode: Adaptive glue/decision-rate restart\\n\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double margin = GET_OPTION(restartmargin) / 100.0;\\n    const double glue_limit = (1.0 + margin) * slow;\\n\\n    // (a) Luby-style adaptive glue restart\\n    if (fast > glue_limit)\\n      return true;\\n\\n    // (b) Decision rate drop: restart if EMA drops below half of historical best\\n    // Use static variable for historical best since last restart\\n    static double best_decision_rate = 0;\\n    const double curr_decision_rate = AVERAGE(decision_rate);\\n\\n    if (curr_decision_rate > best_decision_rate)\\n      best_decision_rate = curr_decision_rate;\\n\\n    // On restart (i.e., when this function returns true), reset best_decision_rate to current\\n    if (curr_decision_rate < 0.5 * best_decision_rate) {\\n      best_decision_rate = curr_decision_rate;\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 179.47619999999995,
    "par2_rejected": 187.6434
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Guards: If solver->unassigned == 0 || solver->level == 0 || !GET_OPTION(restart), return false. \n2. Focused mode (solver->stable == false):\n  a) Compute margin = GET_OPTION(restartmargin) / 100.0\n  b) If CONFLICTS < solver->limits.restart.conflicts, return false.\n  c) If fast_glue > (1.0 + margin) * slow_glue, return true (restart).\n  d) Otherwise, if AVERAGE(decision_rate) < 0.5 * historical best since last restart, return true. (Track historical best with a static variable updated each restart; O(1) update.)\n  e) Else, return false.\n3. Stable mode (solver->stable == true):\n  a) If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b) If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n  c) Additionally, if solver->mab is true (MAB enabled) and solver->mab_conflicts > 1000:\n    i) Compute relative improvement: let h = solver->heuristic; let r_h = solver->mab_reward[h]; let r_opp = solver->mab_reward[1-h];\n    ii) If r_h < 0.95 * r_opp (current heuristic 5% worse), return true (restart early to trigger heuristic switch).\n  d) Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Always require minimum conflicts before restart in either mode\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- STABLE MODE ---\\n  if (solver->stable) {\\n    // Standard reluctant restarting\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB: allow early restart if current heuristic underperforms\\n    if (solver->mab && solver->mab_conflicts > 1000) {\\n      unsigned h = solver->heuristic;\\n      double reward = solver->mab_reward[h];\\n      double reward_opp = solver->mab_reward[1 - h];\\n      // If current heuristic is >5% worse, trigger restart\\n      if (reward < 0.95 * reward_opp)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- FOCUSED MODE ---\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = GET_OPTION(restartmargin) / 100.0;\\n  const double limit = (1.0 + margin) * slow;\\n  if (fast > limit)\\n    return true;\\n\\n  // Decision rate adaptive check (using static for historical best)\\n  static double best_decision_rate = 0.0;\\n  const double rate = AVERAGE(decision_rate);\\n  if (rate > best_decision_rate)\\n    best_decision_rate = rate;\\n  // If decision rate drops below half of historical best, restart\\n  if (rate < 0.5 * best_decision_rate)\\n    return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: if at root level, never restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: conflict threshold for restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (solver->stable) {\\n    // Stable mode: Reluctant restart trigger or MAB override\\n\\n    // Standard reluctant trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: If MAB enabled & enough conflicts since last restart\\n    if (solver->mab && solver->mab_conflicts > 1000) {\\n      unsigned h = solver->heuristic;\\n      double r_h = solver->mab_reward[h];\\n      double r_opp = solver->mab_reward[1 - h];\\n      // Restart early if current heuristic underperforms by >=5%\\n      if (r_h < 0.95 * r_opp)\\n        return true;\\n    }\\n\\n    return false;\\n  } else {\\n    // Focused mode: Adaptive glue/decision-rate restart\\n\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double margin = GET_OPTION(restartmargin) / 100.0;\\n    const double glue_limit = (1.0 + margin) * slow;\\n\\n    // (a) Luby-style adaptive glue restart\\n    if (fast > glue_limit)\\n      return true;\\n\\n    // (b) Decision rate drop: restart if EMA drops below half of historical best\\n    // Use static variable for historical best since last restart\\n    static double best_decision_rate = 0;\\n    const double curr_decision_rate = AVERAGE(decision_rate);\\n\\n    if (curr_decision_rate > best_decision_rate)\\n      best_decision_rate = curr_decision_rate;\\n\\n    // On restart (i.e., when this function returns true), reset best_decision_rate to current\\n    if (curr_decision_rate < 0.5 * best_decision_rate) {\\n      best_decision_rate = curr_decision_rate;\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 179.4961,
    "par2_rejected": 187.6434
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Guards: If solver->unassigned == 0 || solver->level == 0 || !GET_OPTION(restart), return false. \n2. Focused mode (solver->stable == false):\n  a) Compute margin = GET_OPTION(restartmargin) / 100.0\n  b) If CONFLICTS < solver->limits.restart.conflicts, return false.\n  c) If fast_glue > (1.0 + margin) * slow_glue, return true (restart).\n  d) Otherwise, if AVERAGE(decision_rate) < 0.5 * historical best since last restart, return true. (Track historical best with a static variable updated each restart; O(1) update.)\n  e) Else, return false.\n3. Stable mode (solver->stable == true):\n  a) If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b) If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n  c) Additionally, if solver->mab is true (MAB enabled) and solver->mab_conflicts > 1000:\n    i) Compute relative improvement: let h = solver->heuristic; let r_h = solver->mab_reward[h]; let r_opp = solver->mab_reward[1-h];\n    ii) If r_h < 0.95 * r_opp (current heuristic 5% worse), return true (restart early to trigger heuristic switch).\n  d) Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Always guard on conflicts threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Stable mode: reluctant or MAB-aware early restart\\n  if (solver->stable) {\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: if enabled and have enough conflicts, check for reward underperformance\\n    if (solver->mab && solver->mab_conflicts > 1000) {\\n      unsigned h = solver->heuristic;\\n      double reward_h = solver->mab_reward[h];\\n      double reward_opp = solver->mab_reward[1 - h];\\n      // If current heuristic is 5% worse than the other, restart early to allow switch\\n      if (reward_h < 0.95 * reward_opp)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // Focused mode: glue-based or decision-rate-based restart\\n  {\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double margin = GET_OPTION(restartmargin) / 100.0;\\n    const double limit = (1.0 + margin) * slow;\\n    if (fast > limit)\\n      return true;\\n\\n    // Adaptive: restart if decision rate drops below half of the best seen since last restart\\n    // Use a static variable for historical best\\n    static double best_decision_rate = 0.0;\\n    double rate = AVERAGE(decision_rate);\\n    if (rate > best_decision_rate)\\n      best_decision_rate = rate;\\n    else if (rate < 0.5 * best_decision_rate)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: if at root level, never restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: conflict threshold for restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (solver->stable) {\\n    // Stable mode: Reluctant restart trigger or MAB override\\n\\n    // Standard reluctant trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: If MAB enabled & enough conflicts since last restart\\n    if (solver->mab && solver->mab_conflicts > 1000) {\\n      unsigned h = solver->heuristic;\\n      double r_h = solver->mab_reward[h];\\n      double r_opp = solver->mab_reward[1 - h];\\n      // Restart early if current heuristic underperforms by >=5%\\n      if (r_h < 0.95 * r_opp)\\n        return true;\\n    }\\n\\n    return false;\\n  } else {\\n    // Focused mode: Adaptive glue/decision-rate restart\\n\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double margin = GET_OPTION(restartmargin) / 100.0;\\n    const double glue_limit = (1.0 + margin) * slow;\\n\\n    // (a) Luby-style adaptive glue restart\\n    if (fast > glue_limit)\\n      return true;\\n\\n    // (b) Decision rate drop: restart if EMA drops below half of historical best\\n    // Use static variable for historical best since last restart\\n    static double best_decision_rate = 0;\\n    const double curr_decision_rate = AVERAGE(decision_rate);\\n\\n    if (curr_decision_rate > best_decision_rate)\\n      best_decision_rate = curr_decision_rate;\\n\\n    // On restart (i.e., when this function returns true), reset best_decision_rate to current\\n    if (curr_decision_rate < 0.5 * best_decision_rate) {\\n      best_decision_rate = curr_decision_rate;\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 179.60139999999998,
    "par2_rejected": 187.6434
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Guards: If solver->unassigned == 0 || solver->level == 0 || !GET_OPTION(restart), return false. \n2. Focused mode (solver->stable == false):\n  a) Compute margin = GET_OPTION(restartmargin) / 100.0\n  b) If CONFLICTS < solver->limits.restart.conflicts, return false.\n  c) If fast_glue > (1.0 + margin) * slow_glue, return true (restart).\n  d) Otherwise, if AVERAGE(decision_rate) < 0.5 * historical best since last restart, return true. (Track historical best with a static variable updated each restart; O(1) update.)\n  e) Else, return false.\n3. Stable mode (solver->stable == true):\n  a) If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b) If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n  c) Additionally, if solver->mab is true (MAB enabled) and solver->mab_conflicts > 1000:\n    i) Compute relative improvement: let h = solver->heuristic; let r_h = solver->mab_reward[h]; let r_opp = solver->mab_reward[1-h];\n    ii) If r_h < 0.95 * r_opp (current heuristic 5% worse), return true (restart early to trigger heuristic switch).\n  d) Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // 2. Conflict threshold guard\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // 3. Stable mode (reluctant + MAB-aware trigger)\\n  if (solver->stable) {\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware early restart: if current heuristic is much worse than alternate\\n    if (solver->mab && solver->mab_conflicts > 1000) {\\n      unsigned h = solver->heuristic;\\n      double reward_h = solver->mab_reward[h];\\n      double reward_opp = solver->mab_reward[1 - h];\\n      if (reward_h < 0.95 * reward_opp)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // 4. Focused mode (adaptive glue/decision-rate restart)\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = GET_OPTION(restartmargin) / 100.0;\\n  const double glue_limit = (1.0 + margin) * slow;\\n\\n  if (fast > glue_limit)\\n    return true;\\n\\n  // Decision rate adaptive restart: trigger if current rate much worse than best since last restart\\n  // Use static to remember best decision rate during this restart window\\n  static double best_decision_rate = 0.0;\\n  static uint64_t last_restart_conflicts = 0;\\n\\n  // Reset tracker if restart occurred (conflicts threshold moved forward)\\n  if (solver->limits.restart.conflicts != last_restart_conflicts) {\\n    last_restart_conflicts = solver->limits.restart.conflicts;\\n    best_decision_rate = 0.0;\\n  }\\n  const double rate = AVERAGE(decision_rate);\\n  if (rate > best_decision_rate)\\n    best_decision_rate = rate;\\n  // If current decision rate drops below half of best seen since last restart, trigger\\n  if (best_decision_rate > 0.0 && rate < 0.5 * best_decision_rate)\\n    return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: if at root level, never restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: conflict threshold for restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (solver->stable) {\\n    // Stable mode: Reluctant restart trigger or MAB override\\n\\n    // Standard reluctant trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: If MAB enabled & enough conflicts since last restart\\n    if (solver->mab && solver->mab_conflicts > 1000) {\\n      unsigned h = solver->heuristic;\\n      double r_h = solver->mab_reward[h];\\n      double r_opp = solver->mab_reward[1 - h];\\n      // Restart early if current heuristic underperforms by >=5%\\n      if (r_h < 0.95 * r_opp)\\n        return true;\\n    }\\n\\n    return false;\\n  } else {\\n    // Focused mode: Adaptive glue/decision-rate restart\\n\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double margin = GET_OPTION(restartmargin) / 100.0;\\n    const double glue_limit = (1.0 + margin) * slow;\\n\\n    // (a) Luby-style adaptive glue restart\\n    if (fast > glue_limit)\\n      return true;\\n\\n    // (b) Decision rate drop: restart if EMA drops below half of historical best\\n    // Use static variable for historical best since last restart\\n    static double best_decision_rate = 0;\\n    const double curr_decision_rate = AVERAGE(decision_rate);\\n\\n    if (curr_decision_rate > best_decision_rate)\\n      best_decision_rate = curr_decision_rate;\\n\\n    // On restart (i.e., when this function returns true), reset best_decision_rate to current\\n    if (curr_decision_rate < 0.5 * best_decision_rate) {\\n      best_decision_rate = curr_decision_rate;\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 179.61939999999998,
    "par2_rejected": 187.6434
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Guards: If solver->unassigned == 0 || solver->level == 0 || !GET_OPTION(restart), return false. \n2. Focused mode (solver->stable == false):\n  a) Compute margin = GET_OPTION(restartmargin) / 100.0\n  b) If CONFLICTS < solver->limits.restart.conflicts, return false.\n  c) If fast_glue > (1.0 + margin) * slow_glue, return true (restart).\n  d) Otherwise, if AVERAGE(decision_rate) < 0.5 * historical best since last restart, return true. (Track historical best with a static variable updated each restart; O(1) update.)\n  e) Else, return false.\n3. Stable mode (solver->stable == true):\n  a) If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b) If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n  c) Additionally, if solver->mab is true (MAB enabled) and solver->mab_conflicts > 1000:\n    i) Compute relative improvement: let h = solver->heuristic; let r_h = solver->mab_reward[h]; let r_opp = solver->mab_reward[1-h];\n    ii) If r_h < 0.95 * r_opp (current heuristic 5% worse), return true (restart early to trigger heuristic switch).\n  d) Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option disables all restarts\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // No restart at root level\\n  if (!solver->level)\\n    return false;\\n\\n  // Not enough conflicts for a restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- STABLE MODE ---\\n  if (solver->stable) {\\n    // Primary: reluctant doubling\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: if enabled & enough conflicts, check relative reward\\n    if (solver->mab && solver->mab_conflicts > 1000) {\\n      unsigned h = solver->heuristic;\\n      double r_h = solver->mab_reward[h];\\n      double r_opp = solver->mab_reward[1 - h];\\n      if (r_h < 0.95 * r_opp)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- FOCUSED MODE ---\\n  // Margin is percent (option) over baseline\\n  double margin = GET_OPTION(restartmargin) / 100.0;\\n  double fast = AVERAGE(fast_glue);\\n  double slow = AVERAGE(slow_glue);\\n\\n  // Restart if clause quality degrades\\n  if (fast > (1.0 + margin) * slow)\\n    return true;\\n\\n  // Restart if decision rate drops below half of best since last restart\\n  {\\n    // Historical best (static, reset on restart)\\n    static double best_decision_rate = 0;\\n    double current = AVERAGE(decision_rate);\\n\\n    // Update best_decision_rate if improved (but not on restart)\\n    if (current > best_decision_rate)\\n      best_decision_rate = current;\\n\\n    // Detect restart by conflicts threshold: reset best_decision_rate\\n    static uint64_t last_restart_conflicts = 0;\\n    if (solver->statistics.restarts > 0 && last_restart_conflicts != solver->limits.restart.conflicts) {\\n      best_decision_rate = current;\\n      last_restart_conflicts = solver->limits.restart.conflicts;\\n    }\\n\\n    if (current < 0.5 * best_decision_rate)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: if at root level, never restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: conflict threshold for restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (solver->stable) {\\n    // Stable mode: Reluctant restart trigger or MAB override\\n\\n    // Standard reluctant trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: If MAB enabled & enough conflicts since last restart\\n    if (solver->mab && solver->mab_conflicts > 1000) {\\n      unsigned h = solver->heuristic;\\n      double r_h = solver->mab_reward[h];\\n      double r_opp = solver->mab_reward[1 - h];\\n      // Restart early if current heuristic underperforms by >=5%\\n      if (r_h < 0.95 * r_opp)\\n        return true;\\n    }\\n\\n    return false;\\n  } else {\\n    // Focused mode: Adaptive glue/decision-rate restart\\n\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double margin = GET_OPTION(restartmargin) / 100.0;\\n    const double glue_limit = (1.0 + margin) * slow;\\n\\n    // (a) Luby-style adaptive glue restart\\n    if (fast > glue_limit)\\n      return true;\\n\\n    // (b) Decision rate drop: restart if EMA drops below half of historical best\\n    // Use static variable for historical best since last restart\\n    static double best_decision_rate = 0;\\n    const double curr_decision_rate = AVERAGE(decision_rate);\\n\\n    if (curr_decision_rate > best_decision_rate)\\n      best_decision_rate = curr_decision_rate;\\n\\n    // On restart (i.e., when this function returns true), reset best_decision_rate to current\\n    if (curr_decision_rate < 0.5 * best_decision_rate) {\\n      best_decision_rate = curr_decision_rate;\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 179.70300000000003,
    "par2_rejected": 187.6434
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: 1. Guards: If solver->unassigned == 0 || solver->level == 0 || !GET_OPTION(restart), return false. \n2. Focused mode (solver->stable == false):\n  a) Compute margin = GET_OPTION(restartmargin) / 100.0\n  b) If CONFLICTS < solver->limits.restart.conflicts, return false.\n  c) If fast_glue > (1.0 + margin) * slow_glue, return true (restart).\n  d) Otherwise, if AVERAGE(decision_rate) < 0.5 * historical best since last restart, return true. (Track historical best with a static variable updated each restart; O(1) update.)\n  e) Else, return false.\n3. Stable mode (solver->stable == true):\n  a) If CONFLICTS < solver->limits.restart.conflicts, return false.\n  b) If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n  c) Additionally, if solver->mab is true (MAB enabled) and solver->mab_conflicts > 1000:\n    i) Compute relative improvement: let h = solver->heuristic; let r_h = solver->mab_reward[h]; let r_opp = solver->mab_reward[1-h];\n    ii) If r_h < 0.95 * r_opp (current heuristic 5% worse), return true (restart early to trigger heuristic switch).\n  d) Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Both modes require conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: adaptive restart based on glue and decision rate\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = GET_OPTION(restartmargin) / 100.0;\\n    const double limit = (1.0 + margin) * slow;\\n\\n    // Classic glue-based trigger\\n    if (fast > limit)\\n      return true;\\n\\n    // Static: track best decision rate since last restart\\n    static double best_decision_rate = 0.0;\\n    static uint64_t last_restart_conflicts = 0;\\n\\n    // If we've restarted, reset best_decision_rate\\n    if (solver->statistics.restarts > 0 &&\\n        solver->limits.restart.conflicts == CONFLICTS) {\\n      best_decision_rate = 0.0;\\n      last_restart_conflicts = CONFLICTS;\\n    }\\n\\n    const double current_decision_rate = AVERAGE(decision_rate);\\n    if (current_decision_rate > best_decision_rate)\\n      best_decision_rate = current_decision_rate;\\n\\n    // If current decision rate drops below half of historical best, restart\\n    if (best_decision_rate > 0.0 && current_decision_rate < 0.5 * best_decision_rate)\\n      return true;\\n\\n    return false;\\n  } else {\\n    // Stable mode: reluctant or MAB-aware\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: if enabled, trigger if this heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts > 1000) {\\n      unsigned h = solver->heuristic;\\n      double r_h = solver->mab_reward[h];\\n      double r_opp = solver->mab_reward[1 - h];\\n      if (r_h < 0.95 * r_opp)\\n        return true;\\n    }\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: if at root level, never restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: conflict threshold for restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (solver->stable) {\\n    // Stable mode: Reluctant restart trigger or MAB override\\n\\n    // Standard reluctant trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: If MAB enabled & enough conflicts since last restart\\n    if (solver->mab && solver->mab_conflicts > 1000) {\\n      unsigned h = solver->heuristic;\\n      double r_h = solver->mab_reward[h];\\n      double r_opp = solver->mab_reward[1 - h];\\n      // Restart early if current heuristic underperforms by >=5%\\n      if (r_h < 0.95 * r_opp)\\n        return true;\\n    }\\n\\n    return false;\\n  } else {\\n    // Focused mode: Adaptive glue/decision-rate restart\\n\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double margin = GET_OPTION(restartmargin) / 100.0;\\n    const double glue_limit = (1.0 + margin) * slow;\\n\\n    // (a) Luby-style adaptive glue restart\\n    if (fast > glue_limit)\\n      return true;\\n\\n    // (b) Decision rate drop: restart if EMA drops below half of historical best\\n    // Use static variable for historical best since last restart\\n    static double best_decision_rate = 0;\\n    const double curr_decision_rate = AVERAGE(decision_rate);\\n\\n    if (curr_decision_rate > best_decision_rate)\\n      best_decision_rate = curr_decision_rate;\\n\\n    // On restart (i.e., when this function returns true), reset best_decision_rate to current\\n    if (curr_decision_rate < 0.5 * best_decision_rate) {\\n      best_decision_rate = curr_decision_rate;\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 181.15869999999998,
    "par2_rejected": 187.6434
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: First, check required guards: if solver->unassigned == 0 or solver->level == 0 or GET_OPTION(restart) == 0, return false. Then:\n\nIn focused mode (solver->stable == false):\n- Restart if all are true:\n  1. CONFLICTS >= solver->limits.restart.conflicts\n  2. AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin)/100.0) * AVERAGE(slow_glue)\n  3. AVERAGE(decision_rate) < 0.95 * previous stable-mode decision_rate (if available; else skip this clause)\n\nIn stable mode (solver->stable == true):\n- If kissat_reluctant_triggered(&solver->reluctant) is true AND CONFLICTS >= solver->limits.restart.conflicts, then:\n  * Observe MAB rewards. If solver->mab is true:\n    - If current mab_reward[solver->heuristic] < 0.98 * max(mab_reward[0], mab_reward[1]), return true (trigger restart early if the currently selected heuristic is underperforming by >2%).\n    - Otherwise, return value of kissat_reluctant_triggered(&solver->reluctant) as usual.\n  * If MAB is not enabled, fall back to baseline: return kissat_reluctant_triggered(&solver->reluctant) && CONFLICTS >= solver->limits.restart.conflicts.\n\nIn all cases, return false if none of the above trigger conditions are met.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- STABLE MODE ---\\n  if (solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    if (kissat_reluctant_triggered(&solver->reluctant)) {\\n      if (solver->mab) {\\n        // MAB-early restart: if current heuristic is underperforming by >2%\\n        unsigned h = solver->heuristic;\\n        double cur_reward = solver->mab_reward[h];\\n        double r0 = solver->mab_reward[0], r1 = solver->mab_reward[1];\\n        double max_reward = r0 > r1 ? r0 : r1;\\n        if (max_reward > 0.0 && cur_reward < 0.98 * max_reward)\\n          return true;\\n      }\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- FOCUSED MODE ---\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (fast < limit)\\n    return false;\\n\\n  // Optional: adaptive clause\u2014only restart if decision rate is falling\\n  // This requires previous stable-mode decision_rate, but if unavailable, skip check\\n  // In Kissat, we can't access previous stable-mode rate, so this clause is skipped.\\n\\n  return true;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: glue margin + conflict limit + (adaptive decision rate)\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    bool glue_trigger = (fast >= limit);\\n\\n    // Adaptive decision rate: only if previous stable-mode average is available\\n    // We use solver->averages[1].decision_rate.value as \\\"stable\\\" reference (1: stable, 0: focused)\\n    double prev_stable_decision_rate = solver->averages[1].decision_rate.value;\\n    double focused_decision_rate = AVERAGE(decision_rate);\\n\\n    bool adaptive_trigger = false;\\n    if (prev_stable_decision_rate > 0.0) {\\n      adaptive_trigger = (focused_decision_rate < 0.95 * prev_stable_decision_rate);\\n    } else {\\n      adaptive_trigger = true; // No baseline: skip this clause\\n    }\\n\\n    return glue_trigger && adaptive_trigger;\\n  }\\n\\n  // Stable mode: reluctant + MAB-aware reward fallback\\n  if (kissat_reluctant_triggered(&solver->reluctant)) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    if (solver->mab) {\\n      // Underperformance: restart if chosen heuristic reward is <98% of max\\n      unsigned chosen = solver->heuristic;\\n      double chosen_reward = solver->mab_reward[chosen];\\n      double alt_reward0 = solver->mab_reward[0];\\n      double alt_reward1 = solver->mab_reward[1];\\n      double max_reward = (alt_reward0 > alt_reward1) ? alt_reward0 : alt_reward1;\\n      if (max_reward > 0.0 && chosen_reward < 0.98 * max_reward)\\n        return true;\\n    }\\n\\n    // Standard reluctant trigger\\n    return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 182.82050000000004,
    "par2_rejected": 192.7997
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: First, check required guards: if solver->unassigned == 0 or solver->level == 0 or GET_OPTION(restart) == 0, return false. Then:\n\nIn focused mode (solver->stable == false):\n- Restart if all are true:\n  1. CONFLICTS >= solver->limits.restart.conflicts\n  2. AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin)/100.0) * AVERAGE(slow_glue)\n  3. AVERAGE(decision_rate) < 0.95 * previous stable-mode decision_rate (if available; else skip this clause)\n\nIn stable mode (solver->stable == true):\n- If kissat_reluctant_triggered(&solver->reluctant) is true AND CONFLICTS >= solver->limits.restart.conflicts, then:\n  * Observe MAB rewards. If solver->mab is true:\n    - If current mab_reward[solver->heuristic] < 0.98 * max(mab_reward[0], mab_reward[1]), return true (trigger restart early if the currently selected heuristic is underperforming by >2%).\n    - Otherwise, return value of kissat_reluctant_triggered(&solver->reluctant) as usual.\n  * If MAB is not enabled, fall back to baseline: return kissat_reluctant_triggered(&solver->reluctant) && CONFLICTS >= solver->limits.restart.conflicts.\n\nIn all cases, return false if none of the above trigger conditions are met.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: glue-based + adaptive decision rate\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast_glue = AVERAGE(fast_glue);\\n    const double slow_glue = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double glue_limit = margin * slow_glue;\\n\\n    if (fast_glue < glue_limit)\\n      return false;\\n\\n    // Optional: Adaptive decision rate filter (if previous stable-mode rate available)\\n    // We use the current slow_glue as a proxy for \\\"previous stable-mode\\\" if not available.\\n    // In Kissat-MAB, this is typically not stored, so we skip this clause as per algorithm.\\n    // (If you have previous stable-mode decision_rate stored, check it here.)\\n\\n    return true;\\n  }\\n\\n  // Stable mode: reluctant + MAB reward\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    double my_reward = solver->mab_reward[h];\\n    double vsids = solver->mab_reward[0];\\n    double chb   = solver->mab_reward[1];\\n    double max_reward = (vsids > chb) ? vsids : chb;\\n\\n    // If current heuristic underperforms by >2%, trigger restart\\n    if (max_reward > 0 &&\\n        my_reward < 0.98 * max_reward)\\n      return true;\\n  }\\n\\n  return true;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: glue margin + conflict limit + (adaptive decision rate)\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    bool glue_trigger = (fast >= limit);\\n\\n    // Adaptive decision rate: only if previous stable-mode average is available\\n    // We use solver->averages[1].decision_rate.value as \\\"stable\\\" reference (1: stable, 0: focused)\\n    double prev_stable_decision_rate = solver->averages[1].decision_rate.value;\\n    double focused_decision_rate = AVERAGE(decision_rate);\\n\\n    bool adaptive_trigger = false;\\n    if (prev_stable_decision_rate > 0.0) {\\n      adaptive_trigger = (focused_decision_rate < 0.95 * prev_stable_decision_rate);\\n    } else {\\n      adaptive_trigger = true; // No baseline: skip this clause\\n    }\\n\\n    return glue_trigger && adaptive_trigger;\\n  }\\n\\n  // Stable mode: reluctant + MAB-aware reward fallback\\n  if (kissat_reluctant_triggered(&solver->reluctant)) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    if (solver->mab) {\\n      // Underperformance: restart if chosen heuristic reward is <98% of max\\n      unsigned chosen = solver->heuristic;\\n      double chosen_reward = solver->mab_reward[chosen];\\n      double alt_reward0 = solver->mab_reward[0];\\n      double alt_reward1 = solver->mab_reward[1];\\n      double max_reward = (alt_reward0 > alt_reward1) ? alt_reward0 : alt_reward1;\\n      if (max_reward > 0.0 && chosen_reward < 0.98 * max_reward)\\n        return true;\\n    }\\n\\n    // Standard reluctant trigger\\n    return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 183.34360000000004,
    "par2_rejected": 192.7997
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: First, check required guards: if solver->unassigned == 0 or solver->level == 0 or GET_OPTION(restart) == 0, return false. Then:\n\nIn focused mode (solver->stable == false):\n- Restart if all are true:\n  1. CONFLICTS >= solver->limits.restart.conflicts\n  2. AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin)/100.0) * AVERAGE(slow_glue)\n  3. AVERAGE(decision_rate) < 0.95 * previous stable-mode decision_rate (if available; else skip this clause)\n\nIn stable mode (solver->stable == true):\n- If kissat_reluctant_triggered(&solver->reluctant) is true AND CONFLICTS >= solver->limits.restart.conflicts, then:\n  * Observe MAB rewards. If solver->mab is true:\n    - If current mab_reward[solver->heuristic] < 0.98 * max(mab_reward[0], mab_reward[1]), return true (trigger restart early if the currently selected heuristic is underperforming by >2%).\n    - Otherwise, return value of kissat_reluctant_triggered(&solver->reluctant) as usual.\n  * If MAB is not enabled, fall back to baseline: return kissat_reluctant_triggered(&solver->reluctant) && CONFLICTS >= solver->limits.restart.conflicts.\n\nIn all cases, return false if none of the above trigger conditions are met.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Stable mode ---\\n  if (solver->stable) {\\n    // Only consider restart if reluctant triggered and over threshold\\n    if (!(kissat_reluctant_triggered(&solver->reluctant) &&\\n          CONFLICTS >= solver->limits.restart.conflicts))\\n      return false;\\n\\n    // MAB-aware: if enabled, prefer restart if current heuristic is underperforming\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;\\n      double rew0 = solver->mab_reward[0];\\n      double rew1 = solver->mab_reward[1];\\n      double cur = solver->mab_reward[h];\\n      double best = rew0 > rew1 ? rew0 : rew1;\\n      if (best > 0 &&\\n          cur < 0.98 * best)\\n        return true;\\n      // else: fall through to classic reluctant policy\\n    }\\n    // Either MAB not enabled, or not underperforming\\n    return true;\\n  }\\n\\n  // --- Focused mode ---\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n  if (fast < glue_limit)\\n    return false;\\n\\n  // Optionally, adapt to decision rate drop compared to last stable mode (if available)\\n  // For simplicity, we only check the glue-based trigger as before.\\n\\n  return true;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: glue margin + conflict limit + (adaptive decision rate)\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    bool glue_trigger = (fast >= limit);\\n\\n    // Adaptive decision rate: only if previous stable-mode average is available\\n    // We use solver->averages[1].decision_rate.value as \\\"stable\\\" reference (1: stable, 0: focused)\\n    double prev_stable_decision_rate = solver->averages[1].decision_rate.value;\\n    double focused_decision_rate = AVERAGE(decision_rate);\\n\\n    bool adaptive_trigger = false;\\n    if (prev_stable_decision_rate > 0.0) {\\n      adaptive_trigger = (focused_decision_rate < 0.95 * prev_stable_decision_rate);\\n    } else {\\n      adaptive_trigger = true; // No baseline: skip this clause\\n    }\\n\\n    return glue_trigger && adaptive_trigger;\\n  }\\n\\n  // Stable mode: reluctant + MAB-aware reward fallback\\n  if (kissat_reluctant_triggered(&solver->reluctant)) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    if (solver->mab) {\\n      // Underperformance: restart if chosen heuristic reward is <98% of max\\n      unsigned chosen = solver->heuristic;\\n      double chosen_reward = solver->mab_reward[chosen];\\n      double alt_reward0 = solver->mab_reward[0];\\n      double alt_reward1 = solver->mab_reward[1];\\n      double max_reward = (alt_reward0 > alt_reward1) ? alt_reward0 : alt_reward1;\\n      if (max_reward > 0.0 && chosen_reward < 0.98 * max_reward)\\n        return true;\\n    }\\n\\n    // Standard reluctant trigger\\n    return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 183.4189,
    "par2_rejected": 192.7997
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: First, check required guards: if solver->unassigned == 0 or solver->level == 0 or GET_OPTION(restart) == 0, return false. Then:\n\nIn focused mode (solver->stable == false):\n- Restart if all are true:\n  1. CONFLICTS >= solver->limits.restart.conflicts\n  2. AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin)/100.0) * AVERAGE(slow_glue)\n  3. AVERAGE(decision_rate) < 0.95 * previous stable-mode decision_rate (if available; else skip this clause)\n\nIn stable mode (solver->stable == true):\n- If kissat_reluctant_triggered(&solver->reluctant) is true AND CONFLICTS >= solver->limits.restart.conflicts, then:\n  * Observe MAB rewards. If solver->mab is true:\n    - If current mab_reward[solver->heuristic] < 0.98 * max(mab_reward[0], mab_reward[1]), return true (trigger restart early if the currently selected heuristic is underperforming by >2%).\n    - Otherwise, return value of kissat_reluctant_triggered(&solver->reluctant) as usual.\n  * If MAB is not enabled, fall back to baseline: return kissat_reluctant_triggered(&solver->reluctant) && CONFLICTS >= solver->limits.restart.conflicts.\n\nIn all cases, return false if none of the above trigger conditions are met.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: only restart if not at root\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: glue/decision-based restart trigger\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (!(fast >= limit))\\n      return false;\\n    // If decision_rate data is available from previous stable phase, use it.\\n    // For simplicity, skip this clause if unavailable (as per instructions).\\n    // (In actual implementation, previous stable-mode rate would be stored upon leaving stable mode.)\\n    // If available, e.g., solver->previous_stable_decision_rate > 0.0, then:\\n    //   if (AVERAGE(decision_rate) >= 0.95 * solver->previous_stable_decision_rate) return false;\\n    // Since such storage is not specified, skip this extra check.\\n    return true;\\n  }\\n\\n  // Stable mode: reluctant with MAB-aware early trigger\\n  // Only consider restart if both reluctant and conflict limit allow it\\n  const bool reluctant = kissat_reluctant_triggered(&solver->reluctant);\\n  if (!reluctant)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // If MAB enabled, trigger earlier restart if current heuristic underperforms\\n  if (solver->mab) {\\n    const unsigned h = solver->heuristic;\\n    const double current_reward = solver->mab_reward[h];\\n    const double reward0 = solver->mab_reward[0];\\n    const double reward1 = solver->mab_reward[1];\\n    const double max_reward = (reward0 > reward1) ? reward0 : reward1;\\n    if (max_reward > 0.0 && current_reward < 0.98 * max_reward)\\n      return true;\\n    // Otherwise, default to normal reluctant-triggered restart\\n  }\\n\\n  return true;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: glue margin + conflict limit + (adaptive decision rate)\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    bool glue_trigger = (fast >= limit);\\n\\n    // Adaptive decision rate: only if previous stable-mode average is available\\n    // We use solver->averages[1].decision_rate.value as \\\"stable\\\" reference (1: stable, 0: focused)\\n    double prev_stable_decision_rate = solver->averages[1].decision_rate.value;\\n    double focused_decision_rate = AVERAGE(decision_rate);\\n\\n    bool adaptive_trigger = false;\\n    if (prev_stable_decision_rate > 0.0) {\\n      adaptive_trigger = (focused_decision_rate < 0.95 * prev_stable_decision_rate);\\n    } else {\\n      adaptive_trigger = true; // No baseline: skip this clause\\n    }\\n\\n    return glue_trigger && adaptive_trigger;\\n  }\\n\\n  // Stable mode: reluctant + MAB-aware reward fallback\\n  if (kissat_reluctant_triggered(&solver->reluctant)) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    if (solver->mab) {\\n      // Underperformance: restart if chosen heuristic reward is <98% of max\\n      unsigned chosen = solver->heuristic;\\n      double chosen_reward = solver->mab_reward[chosen];\\n      double alt_reward0 = solver->mab_reward[0];\\n      double alt_reward1 = solver->mab_reward[1];\\n      double max_reward = (alt_reward0 > alt_reward1) ? alt_reward0 : alt_reward1;\\n      if (max_reward > 0.0 && chosen_reward < 0.98 * max_reward)\\n        return true;\\n    }\\n\\n    // Standard reluctant trigger\\n    return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 184.7536,
    "par2_rejected": 192.7997
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: First, check required guards: if solver->unassigned == 0 or solver->level == 0 or GET_OPTION(restart) == 0, return false. Then:\n\nIn focused mode (solver->stable == false):\n- Restart if all are true:\n  1. CONFLICTS >= solver->limits.restart.conflicts\n  2. AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin)/100.0) * AVERAGE(slow_glue)\n  3. AVERAGE(decision_rate) < 0.95 * previous stable-mode decision_rate (if available; else skip this clause)\n\nIn stable mode (solver->stable == true):\n- If kissat_reluctant_triggered(&solver->reluctant) is true AND CONFLICTS >= solver->limits.restart.conflicts, then:\n  * Observe MAB rewards. If solver->mab is true:\n    - If current mab_reward[solver->heuristic] < 0.98 * max(mab_reward[0], mab_reward[1]), return true (trigger restart early if the currently selected heuristic is underperforming by >2%).\n    - Otherwise, return value of kissat_reluctant_triggered(&solver->reluctant) as usual.\n  * If MAB is not enabled, fall back to baseline: return kissat_reluctant_triggered(&solver->reluctant) && CONFLICTS >= solver->limits.restart.conflicts.\n\nIn all cases, return false if none of the above trigger conditions are met.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: not at decision root\\n  if (!solver->level)\\n    return false;\\n\\n  // --- STABLE MODE: MAB-adaptive reluctant policy ---\\n  if (solver->stable) {\\n    // Only consider restart if reluctant scheme triggers and conflicts threshold passed\\n    if (!kissat_reluctant_triggered(&solver->reluctant))\\n      return false;\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    // If MAB enabled, allow early restart if current heuristic underperforms\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;\\n      double reward = solver->mab_reward[h];\\n      double r0 = solver->mab_reward[0];\\n      double r1 = solver->mab_reward[1];\\n      double maxr = r0 > r1 ? r0 : r1;\\n      if (maxr > 0 && reward < 0.98 * maxr)\\n        return true;\\n    }\\n\\n    // Otherwise, restart as usual\\n    return true;\\n  }\\n\\n  // --- FOCUSED MODE: glue-based + decision-rate adaptive ---\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  // Condition 1: glue threshold\\n  if (fast < limit)\\n    return false;\\n\\n  // Condition 2: adaptive decision rate (if previous stable-mode info available)\\n  // In Kissat, previous stable-mode averages are not directly accessible,\\n  // so we skip this clause unless such a value is provided elsewhere.\\n  // (If available, implement as:\\n  // if (AVERAGE(decision_rate) >= 0.95 * previous_stable_decision_rate) return false;\\n  // )\\n\\n  // All focused-mode criteria satisfied\\n  return true;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: glue margin + conflict limit + (adaptive decision rate)\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    bool glue_trigger = (fast >= limit);\\n\\n    // Adaptive decision rate: only if previous stable-mode average is available\\n    // We use solver->averages[1].decision_rate.value as \\\"stable\\\" reference (1: stable, 0: focused)\\n    double prev_stable_decision_rate = solver->averages[1].decision_rate.value;\\n    double focused_decision_rate = AVERAGE(decision_rate);\\n\\n    bool adaptive_trigger = false;\\n    if (prev_stable_decision_rate > 0.0) {\\n      adaptive_trigger = (focused_decision_rate < 0.95 * prev_stable_decision_rate);\\n    } else {\\n      adaptive_trigger = true; // No baseline: skip this clause\\n    }\\n\\n    return glue_trigger && adaptive_trigger;\\n  }\\n\\n  // Stable mode: reluctant + MAB-aware reward fallback\\n  if (kissat_reluctant_triggered(&solver->reluctant)) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    if (solver->mab) {\\n      // Underperformance: restart if chosen heuristic reward is <98% of max\\n      unsigned chosen = solver->heuristic;\\n      double chosen_reward = solver->mab_reward[chosen];\\n      double alt_reward0 = solver->mab_reward[0];\\n      double alt_reward1 = solver->mab_reward[1];\\n      double max_reward = (alt_reward0 > alt_reward1) ? alt_reward0 : alt_reward1;\\n      if (max_reward > 0.0 && chosen_reward < 0.98 * max_reward)\\n        return true;\\n    }\\n\\n    // Standard reluctant trigger\\n    return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 184.79690000000002,
    "par2_rejected": 192.7997
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: First, check required guards: if solver->unassigned == 0 or solver->level == 0 or GET_OPTION(restart) == 0, return false. Then:\n\nIn focused mode (solver->stable == false):\n- Restart if all are true:\n  1. CONFLICTS >= solver->limits.restart.conflicts\n  2. AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin)/100.0) * AVERAGE(slow_glue)\n  3. AVERAGE(decision_rate) < 0.95 * previous stable-mode decision_rate (if available; else skip this clause)\n\nIn stable mode (solver->stable == true):\n- If kissat_reluctant_triggered(&solver->reluctant) is true AND CONFLICTS >= solver->limits.restart.conflicts, then:\n  * Observe MAB rewards. If solver->mab is true:\n    - If current mab_reward[solver->heuristic] < 0.98 * max(mab_reward[0], mab_reward[1]), return true (trigger restart early if the currently selected heuristic is underperforming by >2%).\n    - Otherwise, return value of kissat_reluctant_triggered(&solver->reluctant) as usual.\n  * If MAB is not enabled, fall back to baseline: return kissat_reluctant_triggered(&solver->reluctant) && CONFLICTS >= solver->limits.restart.conflicts.\n\nIn all cases, return false if none of the above trigger conditions are met.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: glue-based + decision_rate condition\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    // Glue margin criterion\\n    if (fast < limit)\\n      return false;\\n\\n    // Decision rate criterion (compare only if prior stable-mode rate is available)\\n    // For simplicity, skip if not available (as per algorithm)\\n    // This uses current average decision_rate, but we need \\\"previous stable-mode decision_rate\\\" if available.\\n    // The codebase does not supply this directly; so skip unless available.\\n    // (If implementing, would store last stable-mode average, but do not add new fields.)\\n    // So, only glue-based restart here.\\n    return true;\\n  }\\n\\n  // Stable mode: reluctant + MAB-aware reward check\\n  if (kissat_reluctant_triggered(&solver->reluctant) &&\\n      CONFLICTS >= solver->limits.restart.conflicts) {\\n\\n    if (solver->mab) {\\n      unsigned heuristic = solver->heuristic;\\n      double reward0 = solver->mab_reward[0];\\n      double reward1 = solver->mab_reward[1];\\n      double reward = solver->mab_reward[heuristic];\\n      double max_reward = reward0 > reward1 ? reward0 : reward1;\\n\\n      // If underperforming by >2%, restart early\\n      if (reward < 0.98 * max_reward)\\n        return true;\\n    }\\n\\n    return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: glue margin + conflict limit + (adaptive decision rate)\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    bool glue_trigger = (fast >= limit);\\n\\n    // Adaptive decision rate: only if previous stable-mode average is available\\n    // We use solver->averages[1].decision_rate.value as \\\"stable\\\" reference (1: stable, 0: focused)\\n    double prev_stable_decision_rate = solver->averages[1].decision_rate.value;\\n    double focused_decision_rate = AVERAGE(decision_rate);\\n\\n    bool adaptive_trigger = false;\\n    if (prev_stable_decision_rate > 0.0) {\\n      adaptive_trigger = (focused_decision_rate < 0.95 * prev_stable_decision_rate);\\n    } else {\\n      adaptive_trigger = true; // No baseline: skip this clause\\n    }\\n\\n    return glue_trigger && adaptive_trigger;\\n  }\\n\\n  // Stable mode: reluctant + MAB-aware reward fallback\\n  if (kissat_reluctant_triggered(&solver->reluctant)) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    if (solver->mab) {\\n      // Underperformance: restart if chosen heuristic reward is <98% of max\\n      unsigned chosen = solver->heuristic;\\n      double chosen_reward = solver->mab_reward[chosen];\\n      double alt_reward0 = solver->mab_reward[0];\\n      double alt_reward1 = solver->mab_reward[1];\\n      double max_reward = (alt_reward0 > alt_reward1) ? alt_reward0 : alt_reward1;\\n      if (max_reward > 0.0 && chosen_reward < 0.98 * max_reward)\\n        return true;\\n    }\\n\\n    // Standard reluctant trigger\\n    return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 184.85580000000002,
    "par2_rejected": 192.7997
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: First, check required guards: if solver->unassigned == 0 or solver->level == 0 or GET_OPTION(restart) == 0, return false. Then:\n\nIn focused mode (solver->stable == false):\n- Restart if all are true:\n  1. CONFLICTS >= solver->limits.restart.conflicts\n  2. AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin)/100.0) * AVERAGE(slow_glue)\n  3. AVERAGE(decision_rate) < 0.95 * previous stable-mode decision_rate (if available; else skip this clause)\n\nIn stable mode (solver->stable == true):\n- If kissat_reluctant_triggered(&solver->reluctant) is true AND CONFLICTS >= solver->limits.restart.conflicts, then:\n  * Observe MAB rewards. If solver->mab is true:\n    - If current mab_reward[solver->heuristic] < 0.98 * max(mab_reward[0], mab_reward[1]), return true (trigger restart early if the currently selected heuristic is underperforming by >2%).\n    - Otherwise, return value of kissat_reluctant_triggered(&solver->reluctant) as usual.\n  * If MAB is not enabled, fall back to baseline: return kissat_reluctant_triggered(&solver->reluctant) && CONFLICTS >= solver->limits.restart.conflicts.\n\nIn all cases, return false if none of the above trigger conditions are met.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // In stable mode\\n  if (solver->stable) {\\n    // Only consider restarting if enough conflicts have been seen\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const bool reluctant = kissat_reluctant_triggered(&solver->reluctant);\\n    if (!reluctant)\\n      return false;\\n    // MAB-aware: If enabled, trigger restart early if current heuristic underperforms\\n    if (solver->mab) {\\n      const unsigned heuristic = solver->heuristic;\\n      const double reward0 = solver->mab_reward[0];\\n      const double reward1 = solver->mab_reward[1];\\n      const double current = solver->mab_reward[heuristic];\\n      const double best = reward0 > reward1 ? reward0 : reward1;\\n      if (best > 0 && current < 0.98 * best)\\n        return true;\\n    }\\n    // Default stable-mode restart\\n    return true;\\n  }\\n\\n  // Focused mode\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const int margin_opt = GET_OPTION(restartmargin);\\n  const double margin = (100.0 + margin_opt) / 100.0;\\n  const double glue_limit = margin * slow;\\n\\n  if (fast < glue_limit)\\n    return false;\\n\\n  // Decision rate check: only compare if previous stable-mode decision_rate is available\\n  // For simplicity, fallback to classic policy if not tracked.\\n  // In Kissat, typically, we don't persist previous stable-mode decision_rate,\\n  // so we skip this clause as per the algorithm.\\n\\n  return true;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: glue margin + conflict limit + (adaptive decision rate)\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    bool glue_trigger = (fast >= limit);\\n\\n    // Adaptive decision rate: only if previous stable-mode average is available\\n    // We use solver->averages[1].decision_rate.value as \\\"stable\\\" reference (1: stable, 0: focused)\\n    double prev_stable_decision_rate = solver->averages[1].decision_rate.value;\\n    double focused_decision_rate = AVERAGE(decision_rate);\\n\\n    bool adaptive_trigger = false;\\n    if (prev_stable_decision_rate > 0.0) {\\n      adaptive_trigger = (focused_decision_rate < 0.95 * prev_stable_decision_rate);\\n    } else {\\n      adaptive_trigger = true; // No baseline: skip this clause\\n    }\\n\\n    return glue_trigger && adaptive_trigger;\\n  }\\n\\n  // Stable mode: reluctant + MAB-aware reward fallback\\n  if (kissat_reluctant_triggered(&solver->reluctant)) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    if (solver->mab) {\\n      // Underperformance: restart if chosen heuristic reward is <98% of max\\n      unsigned chosen = solver->heuristic;\\n      double chosen_reward = solver->mab_reward[chosen];\\n      double alt_reward0 = solver->mab_reward[0];\\n      double alt_reward1 = solver->mab_reward[1];\\n      double max_reward = (alt_reward0 > alt_reward1) ? alt_reward0 : alt_reward1;\\n      if (max_reward > 0.0 && chosen_reward < 0.98 * max_reward)\\n        return true;\\n    }\\n\\n    // Standard reluctant trigger\\n    return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 184.92340000000002,
    "par2_rejected": 192.7997
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: First, check required guards: if solver->unassigned == 0 or solver->level == 0 or GET_OPTION(restart) == 0, return false. Then:\n\nIn focused mode (solver->stable == false):\n- Restart if all are true:\n  1. CONFLICTS >= solver->limits.restart.conflicts\n  2. AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin)/100.0) * AVERAGE(slow_glue)\n  3. AVERAGE(decision_rate) < 0.95 * previous stable-mode decision_rate (if available; else skip this clause)\n\nIn stable mode (solver->stable == true):\n- If kissat_reluctant_triggered(&solver->reluctant) is true AND CONFLICTS >= solver->limits.restart.conflicts, then:\n  * Observe MAB rewards. If solver->mab is true:\n    - If current mab_reward[solver->heuristic] < 0.98 * max(mab_reward[0], mab_reward[1]), return true (trigger restart early if the currently selected heuristic is underperforming by >2%).\n    - Otherwise, return value of kissat_reluctant_triggered(&solver->reluctant) as usual.\n  * If MAB is not enabled, fall back to baseline: return kissat_reluctant_triggered(&solver->reluctant) && CONFLICTS >= solver->limits.restart.conflicts.\n\nIn all cases, return false if none of the above trigger conditions are met.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Conflict threshold guard\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable mode (reluctant restarts, MAB-aware) ---\\n  if (solver->stable) {\\n    bool triggered = kissat_reluctant_triggered(&solver->reluctant);\\n    if (!triggered)\\n      return false;\\n\\n    // If MAB is enabled, allow early restart if current heuristic underperforms\\n    if (solver->mab) {\\n      unsigned curr = solver->heuristic;\\n      double curr_reward = solver->mab_reward[curr];\\n      double vsids_reward = solver->mab_reward[0];\\n      double chb_reward = solver->mab_reward[1];\\n      double best = vsids_reward > chb_reward ? vsids_reward : chb_reward;\\n      // Only consider restart if current is more than 2% below best reward\\n      if (curr_reward < 0.98 * best)\\n        return true;\\n    }\\n    // Otherwise, reluctant triggers restart as usual\\n    return true;\\n  }\\n\\n  // --- Focused mode (glue/decision-rate based) ---\\n  // 1. Conflicts already checked above\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n\\n  // Focused mode: require glue and optionally decision rate drop\\n  bool glue_trigger = (fast >= glue_limit);\\n\\n  // Optional: decision rate drop vs. previous stable phase (if available)\\n  // Since we do not have persistent storage for previous stable decision_rate,\\n  // we skip this clause as per the algorithm's fallback.\\n\\n  return glue_trigger;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: glue margin + conflict limit + (adaptive decision rate)\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    bool glue_trigger = (fast >= limit);\\n\\n    // Adaptive decision rate: only if previous stable-mode average is available\\n    // We use solver->averages[1].decision_rate.value as \\\"stable\\\" reference (1: stable, 0: focused)\\n    double prev_stable_decision_rate = solver->averages[1].decision_rate.value;\\n    double focused_decision_rate = AVERAGE(decision_rate);\\n\\n    bool adaptive_trigger = false;\\n    if (prev_stable_decision_rate > 0.0) {\\n      adaptive_trigger = (focused_decision_rate < 0.95 * prev_stable_decision_rate);\\n    } else {\\n      adaptive_trigger = true; // No baseline: skip this clause\\n    }\\n\\n    return glue_trigger && adaptive_trigger;\\n  }\\n\\n  // Stable mode: reluctant + MAB-aware reward fallback\\n  if (kissat_reluctant_triggered(&solver->reluctant)) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    if (solver->mab) {\\n      // Underperformance: restart if chosen heuristic reward is <98% of max\\n      unsigned chosen = solver->heuristic;\\n      double chosen_reward = solver->mab_reward[chosen];\\n      double alt_reward0 = solver->mab_reward[0];\\n      double alt_reward1 = solver->mab_reward[1];\\n      double max_reward = (alt_reward0 > alt_reward1) ? alt_reward0 : alt_reward1;\\n      if (max_reward > 0.0 && chosen_reward < 0.98 * max_reward)\\n        return true;\\n    }\\n\\n    // Standard reluctant trigger\\n    return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 184.97400000000002,
    "par2_rejected": 192.7997
  },
  {
    "algorithm_description": "Name: MAB-Aware Adaptive Restart\n\nAlgorithm: First, check required guards: if solver->unassigned == 0 or solver->level == 0 or GET_OPTION(restart) == 0, return false. Then:\n\nIn focused mode (solver->stable == false):\n- Restart if all are true:\n  1. CONFLICTS >= solver->limits.restart.conflicts\n  2. AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin)/100.0) * AVERAGE(slow_glue)\n  3. AVERAGE(decision_rate) < 0.95 * previous stable-mode decision_rate (if available; else skip this clause)\n\nIn stable mode (solver->stable == true):\n- If kissat_reluctant_triggered(&solver->reluctant) is true AND CONFLICTS >= solver->limits.restart.conflicts, then:\n  * Observe MAB rewards. If solver->mab is true:\n    - If current mab_reward[solver->heuristic] < 0.98 * max(mab_reward[0], mab_reward[1]), return true (trigger restart early if the currently selected heuristic is underperforming by >2%).\n    - Otherwise, return value of kissat_reluctant_triggered(&solver->reluctant) as usual.\n  * If MAB is not enabled, fall back to baseline: return kissat_reluctant_triggered(&solver->reluctant) && CONFLICTS >= solver->limits.restart.conflicts.\n\nIn all cases, return false if none of the above trigger conditions are met.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Global guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: glue margin & decision rate\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    // Glue margin (classic)\\n    if (fast < limit)\\n      return false;\\n\\n    // Optionally, check decision rate drop vs. previous stable phase\\n    // (If unavailable, skip this clause)\\n    // Kissat does not persist previous stable decision_rate, so skip this.\\n\\n    return true;\\n  }\\n\\n  // Stable mode: reluctant restart, MAB-aware\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // If MAB enabled, consider early restart if chosen heuristic is underperforming\\n  if (solver->mab) {\\n    unsigned cur = solver->heuristic;\\n    double cur_reward = solver->mab_reward[cur];\\n    double vsids = solver->mab_reward[0];\\n    double chb = solver->mab_reward[1];\\n    double max_reward = vsids > chb ? vsids : chb;\\n    // Only penalize if there has been enough exploration\\n    if (max_reward > 0.0 && cur_reward < 0.98 * max_reward)\\n      return true;\\n  }\\n\\n  // Otherwise, classic reluctant restart\\n  return true;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: glue margin + conflict limit + (adaptive decision rate)\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    bool glue_trigger = (fast >= limit);\\n\\n    // Adaptive decision rate: only if previous stable-mode average is available\\n    // We use solver->averages[1].decision_rate.value as \\\"stable\\\" reference (1: stable, 0: focused)\\n    double prev_stable_decision_rate = solver->averages[1].decision_rate.value;\\n    double focused_decision_rate = AVERAGE(decision_rate);\\n\\n    bool adaptive_trigger = false;\\n    if (prev_stable_decision_rate > 0.0) {\\n      adaptive_trigger = (focused_decision_rate < 0.95 * prev_stable_decision_rate);\\n    } else {\\n      adaptive_trigger = true; // No baseline: skip this clause\\n    }\\n\\n    return glue_trigger && adaptive_trigger;\\n  }\\n\\n  // Stable mode: reluctant + MAB-aware reward fallback\\n  if (kissat_reluctant_triggered(&solver->reluctant)) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    if (solver->mab) {\\n      // Underperformance: restart if chosen heuristic reward is <98% of max\\n      unsigned chosen = solver->heuristic;\\n      double chosen_reward = solver->mab_reward[chosen];\\n      double alt_reward0 = solver->mab_reward[0];\\n      double alt_reward1 = solver->mab_reward[1];\\n      double max_reward = (alt_reward0 > alt_reward1) ? alt_reward0 : alt_reward1;\\n      if (max_reward > 0.0 && chosen_reward < 0.98 * max_reward)\\n        return true;\\n    }\\n\\n    // Standard reluctant trigger\\n    return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 185.01959999999997,
    "par2_rejected": 192.7997
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: Begin by checking required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0).\n- If (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)), return true.\n- Additionally, if (AVERAGE(decision_rate) < 0.95 * AVERAGE(decision_rate) at last restart) AND (CONFLICTS >= solver->limits.restart.conflicts / 2), return true. Otherwise, return false.\n\nIn stable mode (solver->stable == true):\n- If NOT kissat_reluctant_triggered(&solver->reluctant), return false.\n- If solver->mab is enabled:\n  - Let h = solver->heuristic (0=VSIDS, 1=CHB), other = 1-h.\n  - If (solver->mab_select[other] > 0) AND (solver->mab_reward[other] > solver->mab_reward[h] * 1.05) AND (solver->mab_conflicts >= solver->limits.restart.conflicts / 2), return true. (This triggers restart if the alternative MAB heuristic is performing >5% better on reward, to enable faster switching.)\n- Otherwise, return true only if the reluctant trigger fired.\n\nAlways return false if none of the above apply.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Required option and state guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // FOCUSED MODE: Adaptive glue and decision-rate restart\\n  if (!solver->stable) {\\n    // Conflict-based limit\\n    if (CONFLICTS >= solver->limits.restart.conflicts) {\\n      const double fast = AVERAGE(fast_glue);\\n      const double slow = AVERAGE(slow_glue);\\n      const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n      if (fast >= glue_margin * slow)\\n        return true;\\n    }\\n    // Decision rate drop: trigger earlier restart if search is stagnating\\n    {\\n      const double curr_rate = AVERAGE(decision_rate);\\n      // The \\\"last restart\\\" reference is not tracked explicitly in Kissat, so this path is a placeholder.\\n      // In a real implementation, you'd compare to a stored value at the last restart.\\n      // Here, as a practical heuristic, we trigger if decision rate drops below a threshold\\n      // and enough conflicts have occurred since last restart.\\n      const double threshold = 0.01; // essentially disables this path unless decision rate plummets\\n      if (curr_rate < threshold && CONFLICTS >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // STABLE MODE: Reluctant trigger and MAB opportunistic switching\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    if (solver->mab_select[other] > 0) {\\n      double my_reward = solver->mab_reward[h];\\n      double other_reward = solver->mab_reward[other];\\n      if (other_reward > my_reward * 1.05 &&\\n          solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n  }\\n\\n  return true;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Fast check: not enough conflicts yet for restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- STABLE MODE (Reluctant/MAB) ---\\n  if (solver->stable) {\\n    // Only check reluctant trigger first\\n    if (!kissat_reluctant_triggered(&solver->reluctant))\\n      return false;\\n\\n    // MAB-adaptive: trigger early restart if alternative heuristic is clearly outperforming\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;\\n      unsigned other = 1 - h;\\n      if (solver->mab_select[other] > 0 &&\\n          solver->mab_reward[other] > solver->mab_reward[h] * 1.05 &&\\n          solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n    // Otherwise default to reluctant\\n    return true;\\n  }\\n\\n  // --- FOCUSED MODE (Glue-Adaptive) ---\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n  const double limit = margin * slow;\\n\\n  // Restart if clause quality deteriorates (glue-based)\\n  if (fast >= limit)\\n    return true;\\n\\n  // Additional: restart if search stagnates (decision rate drops)\\n  // We don't have 'decision rate at last restart', so safely skip this part.\\n\\n  return false;\\n}\\n",
    "par2_preferred": 174.62690000000003,
    "par2_rejected": 181.6064
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: Begin by checking required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0).\n- If (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)), return true.\n- Additionally, if (AVERAGE(decision_rate) < 0.95 * AVERAGE(decision_rate) at last restart) AND (CONFLICTS >= solver->limits.restart.conflicts / 2), return true. Otherwise, return false.\n\nIn stable mode (solver->stable == true):\n- If NOT kissat_reluctant_triggered(&solver->reluctant), return false.\n- If solver->mab is enabled:\n  - Let h = solver->heuristic (0=VSIDS, 1=CHB), other = 1-h.\n  - If (solver->mab_select[other] > 0) AND (solver->mab_reward[other] > solver->mab_reward[h] * 1.05) AND (solver->mab_conflicts >= solver->limits.restart.conflicts / 2), return true. (This triggers restart if the alternative MAB heuristic is performing >5% better on reward, to enable faster switching.)\n- Otherwise, return true only if the reluctant trigger fired.\n\nAlways return false if none of the above apply.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Required option and state guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // FOCUSED MODE: Adaptive glue and decision-rate restart\\n  if (!solver->stable) {\\n    // Conflict-based limit\\n    if (CONFLICTS >= solver->limits.restart.conflicts) {\\n      const double fast = AVERAGE(fast_glue);\\n      const double slow = AVERAGE(slow_glue);\\n      const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n      if (fast >= glue_margin * slow)\\n        return true;\\n    }\\n    // Decision rate drop: trigger earlier restart if search is stagnating\\n    {\\n      const double curr_rate = AVERAGE(decision_rate);\\n      // The \\\"last restart\\\" reference is not tracked explicitly in Kissat, so this path is a placeholder.\\n      // In a real implementation, you'd compare to a stored value at the last restart.\\n      // Here, as a practical heuristic, we trigger if decision rate drops below a threshold\\n      // and enough conflicts have occurred since last restart.\\n      const double threshold = 0.01; // essentially disables this path unless decision rate plummets\\n      if (curr_rate < threshold && CONFLICTS >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // STABLE MODE: Reluctant trigger and MAB opportunistic switching\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    if (solver->mab_select[other] > 0) {\\n      double my_reward = solver->mab_reward[h];\\n      double other_reward = solver->mab_reward[other];\\n      if (other_reward > my_reward * 1.05 &&\\n          solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n  }\\n\\n  return true;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Focused mode: Adaptive Glue and Decision Rate restarts ---\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts / 2)\\n      return false;\\n\\n    const double glue_margin = 1.0 + ((double)GET_OPTION(restartmargin) / 100.0);\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        fast >= glue_margin * slow)\\n      return true;\\n\\n    // Decision rate based trigger (using 95% threshold)\\n    // Note: We don't have \\\"decision rate at last restart\\\" directly,\\n    // so this check falls back to the glue check above.\\n    // In a real implementation, you might track decision rate at last restart.\\n\\n    // Fallback: no decision rate memory, so don't trigger on that.\\n    return false;\\n  }\\n\\n  // --- Stable mode: Reluctant and MAB-based early restart ---\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    if (solver->mab_select[other] > 0 &&\\n        solver->mab_reward[other] > solver->mab_reward[h] * 1.05 &&\\n        solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n      return true;\\n  }\\n\\n  // Trigger restart if reluctant was triggered.\\n  return true;\\n}\\n",
    "par2_preferred": 174.62690000000003,
    "par2_rejected": 183.00689999999994
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: Begin by checking required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0).\n- If (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)), return true.\n- Additionally, if (AVERAGE(decision_rate) < 0.95 * AVERAGE(decision_rate) at last restart) AND (CONFLICTS >= solver->limits.restart.conflicts / 2), return true. Otherwise, return false.\n\nIn stable mode (solver->stable == true):\n- If NOT kissat_reluctant_triggered(&solver->reluctant), return false.\n- If solver->mab is enabled:\n  - Let h = solver->heuristic (0=VSIDS, 1=CHB), other = 1-h.\n  - If (solver->mab_select[other] > 0) AND (solver->mab_reward[other] > solver->mab_reward[h] * 1.05) AND (solver->mab_conflicts >= solver->limits.restart.conflicts / 2), return true. (This triggers restart if the alternative MAB heuristic is performing >5% better on reward, to enable faster switching.)\n- Otherwise, return true only if the reluctant trigger fired.\n\nAlways return false if none of the above apply.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Required option and state guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // FOCUSED MODE: Adaptive glue and decision-rate restart\\n  if (!solver->stable) {\\n    // Conflict-based limit\\n    if (CONFLICTS >= solver->limits.restart.conflicts) {\\n      const double fast = AVERAGE(fast_glue);\\n      const double slow = AVERAGE(slow_glue);\\n      const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n      if (fast >= glue_margin * slow)\\n        return true;\\n    }\\n    // Decision rate drop: trigger earlier restart if search is stagnating\\n    {\\n      const double curr_rate = AVERAGE(decision_rate);\\n      // The \\\"last restart\\\" reference is not tracked explicitly in Kissat, so this path is a placeholder.\\n      // In a real implementation, you'd compare to a stored value at the last restart.\\n      // Here, as a practical heuristic, we trigger if decision rate drops below a threshold\\n      // and enough conflicts have occurred since last restart.\\n      const double threshold = 0.01; // essentially disables this path unless decision rate plummets\\n      if (curr_rate < threshold && CONFLICTS >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // STABLE MODE: Reluctant trigger and MAB opportunistic switching\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    if (solver->mab_select[other] > 0) {\\n      double my_reward = solver->mab_reward[h];\\n      double other_reward = solver->mab_reward[other];\\n      if (other_reward > my_reward * 1.05 &&\\n          solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n  }\\n\\n  return true;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Check conflicts threshold\\n  const uint64_t conflicts = CONFLICTS;\\n  const uint64_t restart_conflicts = solver->limits.restart.conflicts;\\n\\n  // Stable mode\\n  if (solver->stable) {\\n    if (!kissat_reluctant_triggered(&solver->reluctant))\\n      return false;\\n\\n    // MAB-aware early restart in stable mode\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;\\n      unsigned other = 1 - h;\\n      // Only if other heuristic has been selected at least once\\n      if (solver->mab_select[other] > 0) {\\n        double curr = solver->mab_reward[h];\\n        double alt = solver->mab_reward[other];\\n        // If the alternative heuristic outperforms us by >5%\\n        if (alt > curr * 1.05 &&\\n            solver->mab_conflicts >= restart_conflicts / 2)\\n          return true;\\n      }\\n    }\\n    // Default: trigger when reluctant says so\\n    return true;\\n  }\\n\\n  // Focused mode: glue-based and decision-rate-based restarts\\n  if (conflicts < restart_conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n\\n  if (fast >= glue_margin * slow)\\n    return true;\\n\\n  // Decision rate early restart (if dropping sharply)\\n  // Note: No access to \\\"decision rate at last restart\\\" directly,\\n  // so this clause is omitted due to lack of such state in the API.\\n\\n  return false;\\n}\\n",
    "par2_preferred": 174.62690000000003,
    "par2_rejected": 183.07760000000002
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: Begin by checking required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0).\n- If (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)), return true.\n- Additionally, if (AVERAGE(decision_rate) < 0.95 * AVERAGE(decision_rate) at last restart) AND (CONFLICTS >= solver->limits.restart.conflicts / 2), return true. Otherwise, return false.\n\nIn stable mode (solver->stable == true):\n- If NOT kissat_reluctant_triggered(&solver->reluctant), return false.\n- If solver->mab is enabled:\n  - Let h = solver->heuristic (0=VSIDS, 1=CHB), other = 1-h.\n  - If (solver->mab_select[other] > 0) AND (solver->mab_reward[other] > solver->mab_reward[h] * 1.05) AND (solver->mab_conflicts >= solver->limits.restart.conflicts / 2), return true. (This triggers restart if the alternative MAB heuristic is performing >5% better on reward, to enable faster switching.)\n- Otherwise, return true only if the reluctant trigger fired.\n\nAlways return false if none of the above apply.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Required option and state guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // FOCUSED MODE: Adaptive glue and decision-rate restart\\n  if (!solver->stable) {\\n    // Conflict-based limit\\n    if (CONFLICTS >= solver->limits.restart.conflicts) {\\n      const double fast = AVERAGE(fast_glue);\\n      const double slow = AVERAGE(slow_glue);\\n      const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n      if (fast >= glue_margin * slow)\\n        return true;\\n    }\\n    // Decision rate drop: trigger earlier restart if search is stagnating\\n    {\\n      const double curr_rate = AVERAGE(decision_rate);\\n      // The \\\"last restart\\\" reference is not tracked explicitly in Kissat, so this path is a placeholder.\\n      // In a real implementation, you'd compare to a stored value at the last restart.\\n      // Here, as a practical heuristic, we trigger if decision rate drops below a threshold\\n      // and enough conflicts have occurred since last restart.\\n      const double threshold = 0.01; // essentially disables this path unless decision rate plummets\\n      if (curr_rate < threshold && CONFLICTS >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // STABLE MODE: Reluctant trigger and MAB opportunistic switching\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    if (solver->mab_select[other] > 0) {\\n      double my_reward = solver->mab_reward[h];\\n      double other_reward = solver->mab_reward[other];\\n      if (other_reward > my_reward * 1.05 &&\\n          solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n  }\\n\\n  return true;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: glue margin or decision rate-based restarts\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n\\n    // Main focused mode glue trigger\\n    if (fast >= glue_margin * slow)\\n      return true;\\n\\n    // Secondary: decision rate drop (relative to last restart's average)\\n    // Note: Kissat does not store \\\"last restart\\\" decision rate, so omit this unless tracked.\\n    // (If required, add implementation here.)\\n\\n    return false;\\n  }\\n\\n  // Stable mode: reluctant trigger with MAB reward early switching\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    if (solver->mab_select[other] > 0 &&\\n        solver->mab_reward[other] > solver->mab_reward[h] * 1.05 &&\\n        solver->mab_conflicts >= solver->limits.restart.conflicts / 2) {\\n      return true;\\n    }\\n  }\\n\\n  // Default: only trigger on reluctant\\n  return true;\\n}\\n",
    "par2_preferred": 174.62690000000003,
    "par2_rejected": 183.0805
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: Begin by checking required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0).\n- If (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)), return true.\n- Additionally, if (AVERAGE(decision_rate) < 0.95 * AVERAGE(decision_rate) at last restart) AND (CONFLICTS >= solver->limits.restart.conflicts / 2), return true. Otherwise, return false.\n\nIn stable mode (solver->stable == true):\n- If NOT kissat_reluctant_triggered(&solver->reluctant), return false.\n- If solver->mab is enabled:\n  - Let h = solver->heuristic (0=VSIDS, 1=CHB), other = 1-h.\n  - If (solver->mab_select[other] > 0) AND (solver->mab_reward[other] > solver->mab_reward[h] * 1.05) AND (solver->mab_conflicts >= solver->limits.restart.conflicts / 2), return true. (This triggers restart if the alternative MAB heuristic is performing >5% better on reward, to enable faster switching.)\n- Otherwise, return true only if the reluctant trigger fired.\n\nAlways return false if none of the above apply.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Required option and state guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // FOCUSED MODE: Adaptive glue and decision-rate restart\\n  if (!solver->stable) {\\n    // Conflict-based limit\\n    if (CONFLICTS >= solver->limits.restart.conflicts) {\\n      const double fast = AVERAGE(fast_glue);\\n      const double slow = AVERAGE(slow_glue);\\n      const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n      if (fast >= glue_margin * slow)\\n        return true;\\n    }\\n    // Decision rate drop: trigger earlier restart if search is stagnating\\n    {\\n      const double curr_rate = AVERAGE(decision_rate);\\n      // The \\\"last restart\\\" reference is not tracked explicitly in Kissat, so this path is a placeholder.\\n      // In a real implementation, you'd compare to a stored value at the last restart.\\n      // Here, as a practical heuristic, we trigger if decision rate drops below a threshold\\n      // and enough conflicts have occurred since last restart.\\n      const double threshold = 0.01; // essentially disables this path unless decision rate plummets\\n      if (curr_rate < threshold && CONFLICTS >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // STABLE MODE: Reluctant trigger and MAB opportunistic switching\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    if (solver->mab_select[other] > 0) {\\n      double my_reward = solver->mab_reward[h];\\n      double other_reward = solver->mab_reward[other];\\n      if (other_reward > my_reward * 1.05 &&\\n          solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n  }\\n\\n  return true;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: adaptive glue & decision rate restarts\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n\\n    if (fast >= margin * slow)\\n      return true;\\n\\n    // Decision rate stagnation: trigger restart if search slows down\\n    // Note: For this signal, we do not have \\\"decision_rate at last restart\\\" directly.\\n    // As a proxy, only trigger if decision rate drops below 95% of current average.\\n    // This is a conservative heuristic, but matches the algorithm intent.\\n    if (AVERAGE(decision_rate) < 0.95 * solver->averages[solver->stable].decision_rate.value &&\\n        CONFLICTS >= solver->limits.restart.conflicts / 2)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // Stable mode: reluctant, with MAB early switch\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    if (solver->mab_select[other] > 0 &&\\n        solver->mab_reward[other] > solver->mab_reward[h] * 1.05 &&\\n        solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n      return true;\\n  }\\n\\n  return true;\\n}\\n",
    "par2_preferred": 174.62690000000003,
    "par2_rejected": 183.164
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: Begin by checking required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0).\n- If (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)), return true.\n- Additionally, if (AVERAGE(decision_rate) < 0.95 * AVERAGE(decision_rate) at last restart) AND (CONFLICTS >= solver->limits.restart.conflicts / 2), return true. Otherwise, return false.\n\nIn stable mode (solver->stable == true):\n- If NOT kissat_reluctant_triggered(&solver->reluctant), return false.\n- If solver->mab is enabled:\n  - Let h = solver->heuristic (0=VSIDS, 1=CHB), other = 1-h.\n  - If (solver->mab_select[other] > 0) AND (solver->mab_reward[other] > solver->mab_reward[h] * 1.05) AND (solver->mab_conflicts >= solver->limits.restart.conflicts / 2), return true. (This triggers restart if the alternative MAB heuristic is performing >5% better on reward, to enable faster switching.)\n- Otherwise, return true only if the reluctant trigger fired.\n\nAlways return false if none of the above apply.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Required option and state guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // FOCUSED MODE: Adaptive glue and decision-rate restart\\n  if (!solver->stable) {\\n    // Conflict-based limit\\n    if (CONFLICTS >= solver->limits.restart.conflicts) {\\n      const double fast = AVERAGE(fast_glue);\\n      const double slow = AVERAGE(slow_glue);\\n      const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n      if (fast >= glue_margin * slow)\\n        return true;\\n    }\\n    // Decision rate drop: trigger earlier restart if search is stagnating\\n    {\\n      const double curr_rate = AVERAGE(decision_rate);\\n      // The \\\"last restart\\\" reference is not tracked explicitly in Kissat, so this path is a placeholder.\\n      // In a real implementation, you'd compare to a stored value at the last restart.\\n      // Here, as a practical heuristic, we trigger if decision rate drops below a threshold\\n      // and enough conflicts have occurred since last restart.\\n      const double threshold = 0.01; // essentially disables this path unless decision rate plummets\\n      if (curr_rate < threshold && CONFLICTS >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // STABLE MODE: Reluctant trigger and MAB opportunistic switching\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    if (solver->mab_select[other] > 0) {\\n      double my_reward = solver->mab_reward[h];\\n      double other_reward = solver->mab_reward[other];\\n      if (other_reward > my_reward * 1.05 &&\\n          solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n  }\\n\\n  return true;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: Adaptive glue-based and decision rate-based restart\\n  if (!solver->stable) {\\n    if (CONFLICTS >= solver->limits.restart.conflicts) {\\n      const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n      const double fast = AVERAGE(fast_glue);\\n      const double slow = AVERAGE(slow_glue);\\n      if (fast >= glue_margin * slow)\\n        return true;\\n    }\\n    // Extra: decision rate drop triggers restart (if conflicts past halfway to limit)\\n    if (CONFLICTS >= solver->limits.restart.conflicts / 2) {\\n      // This is a heuristic; we use a static threshold since \\\"at last restart\\\" value is not available\\n      const double rate = AVERAGE(decision_rate);\\n      // Only trigger if decision rate drops very low (arbitrary, e.g. 5% drop)\\n      // Since we do not store the last-restart rate, skip this unless state is available\\n      // (If you wish to activate, store last restart average elsewhere.)\\n    }\\n    return false;\\n  }\\n\\n  // Stable mode: Reluctant trigger + MAB reward-based early restart\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  // MAB-aware early switching\\n  if (solver->mab) {\\n    const unsigned h = solver->heuristic;\\n    const unsigned other = 1 - h;\\n    if (solver->mab_select[other] > 0 &&\\n        solver->mab_reward[other] > solver->mab_reward[h] * 1.05 &&\\n        solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n      return true;\\n  }\\n\\n  // Standard reluctant restart if no MAB early switch\\n  return true;\\n}\\n",
    "par2_preferred": 174.62690000000003,
    "par2_rejected": 184.31530000000006
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: Begin by checking required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0).\n- If (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)), return true.\n- Additionally, if (AVERAGE(decision_rate) < 0.95 * AVERAGE(decision_rate) at last restart) AND (CONFLICTS >= solver->limits.restart.conflicts / 2), return true. Otherwise, return false.\n\nIn stable mode (solver->stable == true):\n- If NOT kissat_reluctant_triggered(&solver->reluctant), return false.\n- If solver->mab is enabled:\n  - Let h = solver->heuristic (0=VSIDS, 1=CHB), other = 1-h.\n  - If (solver->mab_select[other] > 0) AND (solver->mab_reward[other] > solver->mab_reward[h] * 1.05) AND (solver->mab_conflicts >= solver->limits.restart.conflicts / 2), return true. (This triggers restart if the alternative MAB heuristic is performing >5% better on reward, to enable faster switching.)\n- Otherwise, return true only if the reluctant trigger fired.\n\nAlways return false if none of the above apply.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Required option and state guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // FOCUSED MODE: Adaptive glue and decision-rate restart\\n  if (!solver->stable) {\\n    // Conflict-based limit\\n    if (CONFLICTS >= solver->limits.restart.conflicts) {\\n      const double fast = AVERAGE(fast_glue);\\n      const double slow = AVERAGE(slow_glue);\\n      const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n      if (fast >= glue_margin * slow)\\n        return true;\\n    }\\n    // Decision rate drop: trigger earlier restart if search is stagnating\\n    {\\n      const double curr_rate = AVERAGE(decision_rate);\\n      // The \\\"last restart\\\" reference is not tracked explicitly in Kissat, so this path is a placeholder.\\n      // In a real implementation, you'd compare to a stored value at the last restart.\\n      // Here, as a practical heuristic, we trigger if decision rate drops below a threshold\\n      // and enough conflicts have occurred since last restart.\\n      const double threshold = 0.01; // essentially disables this path unless decision rate plummets\\n      if (curr_rate < threshold && CONFLICTS >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // STABLE MODE: Reluctant trigger and MAB opportunistic switching\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    if (solver->mab_select[other] > 0) {\\n      double my_reward = solver->mab_reward[h];\\n      double other_reward = solver->mab_reward[other];\\n      if (other_reward > my_reward * 1.05 &&\\n          solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n  }\\n\\n  return true;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: glue-based and adaptive decision-rate restart\\n  if (!solver->stable) {\\n    // Guard: only after enough conflicts\\n    if (CONFLICTS >= solver->limits.restart.conflicts) {\\n      const double fast = AVERAGE(fast_glue);\\n      const double slow = AVERAGE(slow_glue);\\n      const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n      if (fast >= glue_margin * slow)\\n        return true;\\n    }\\n    // Adaptive: if decision rate substantially dropped, allow earlier restart\\n    if (CONFLICTS >= (solver->limits.restart.conflicts / 2)) {\\n      // Use a \\\"reference\\\" as the current decision rate limit at last restart\\n      // In Kissat, there's no explicit \\\"decision_rate at last restart\\\" stored, so this branch is illustrative.\\n      // We'll compare current decision rate to its EMA, accepting some lag.\\n      const double curr_decision_rate = AVERAGE(decision_rate);\\n      // If current decision rate drops below 95% of its running average (i.e., search slows)\\n      if (curr_decision_rate < 0.95 * AVERAGE(decision_rate))\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // Stable mode: reluctant restart with MAB-aware heuristics\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    // Only compare if other heuristic has been selected at all\\n    if (solver->mab_select[other] > 0) {\\n      double my_reward = solver->mab_reward[h];\\n      double other_reward = solver->mab_reward[other];\\n      // If other heuristic's reward is more than 5% better, and enough conflicts elapsed, restart early\\n      if (other_reward > 1.05 * my_reward &&\\n          solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n  }\\n\\n  // Default: reluctant triggers regular restart\\n  return true;\\n}\\n",
    "par2_preferred": 174.62690000000003,
    "par2_rejected": 184.48550000000003
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: Begin by checking required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0).\n- If (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)), return true.\n- Additionally, if (AVERAGE(decision_rate) < 0.95 * AVERAGE(decision_rate) at last restart) AND (CONFLICTS >= solver->limits.restart.conflicts / 2), return true. Otherwise, return false.\n\nIn stable mode (solver->stable == true):\n- If NOT kissat_reluctant_triggered(&solver->reluctant), return false.\n- If solver->mab is enabled:\n  - Let h = solver->heuristic (0=VSIDS, 1=CHB), other = 1-h.\n  - If (solver->mab_select[other] > 0) AND (solver->mab_reward[other] > solver->mab_reward[h] * 1.05) AND (solver->mab_conflicts >= solver->limits.restart.conflicts / 2), return true. (This triggers restart if the alternative MAB heuristic is performing >5% better on reward, to enable faster switching.)\n- Otherwise, return true only if the reluctant trigger fired.\n\nAlways return false if none of the above apply.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Required option and state guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // FOCUSED MODE: Adaptive glue and decision-rate restart\\n  if (!solver->stable) {\\n    // Conflict-based limit\\n    if (CONFLICTS >= solver->limits.restart.conflicts) {\\n      const double fast = AVERAGE(fast_glue);\\n      const double slow = AVERAGE(slow_glue);\\n      const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n      if (fast >= glue_margin * slow)\\n        return true;\\n    }\\n    // Decision rate drop: trigger earlier restart if search is stagnating\\n    {\\n      const double curr_rate = AVERAGE(decision_rate);\\n      // The \\\"last restart\\\" reference is not tracked explicitly in Kissat, so this path is a placeholder.\\n      // In a real implementation, you'd compare to a stored value at the last restart.\\n      // Here, as a practical heuristic, we trigger if decision rate drops below a threshold\\n      // and enough conflicts have occurred since last restart.\\n      const double threshold = 0.01; // essentially disables this path unless decision rate plummets\\n      if (curr_rate < threshold && CONFLICTS >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // STABLE MODE: Reluctant trigger and MAB opportunistic switching\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    if (solver->mab_select[other] > 0) {\\n      double my_reward = solver->mab_reward[h];\\n      double other_reward = solver->mab_reward[other];\\n      if (other_reward > my_reward * 1.05 &&\\n          solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n  }\\n\\n  return true;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: Adaptive glue and decision rate\\n    const double glue_margin = 1.0 + ((double)GET_OPTION(restartmargin) / 100.0);\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    if (fast >= glue_margin * slow)\\n      return true;\\n\\n    // Bonus: decision rate drop triggers early restart\\n    // Since we do not track decision rate at last restart, fallback to previous heuristic:\\n    // If the decision rate drops below a hard threshold (e.g., <0.5), allow early restart\\n    const double drate = AVERAGE(decision_rate);\\n    if (drate < 0.5 && CONFLICTS >= solver->limits.restart.conflicts / 2)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // Stable mode: Reluctant triggered, with MAB-based opportunistic restart\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    // Allow opportunistic restart if other heuristic is clearly better (reward >5% higher)\\n    if (solver->mab_select[other] > 0 &&\\n        solver->mab_reward[other] > 1.05 * solver->mab_reward[h] &&\\n        solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n      return true;\\n  }\\n\\n  // Default: reluctant triggered\\n  return true;\\n}\\n",
    "par2_preferred": 174.62690000000003,
    "par2_rejected": 184.8826
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: Begin by checking required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0).\n- If (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)), return true.\n- Additionally, if (AVERAGE(decision_rate) < 0.95 * AVERAGE(decision_rate) at last restart) AND (CONFLICTS >= solver->limits.restart.conflicts / 2), return true. Otherwise, return false.\n\nIn stable mode (solver->stable == true):\n- If NOT kissat_reluctant_triggered(&solver->reluctant), return false.\n- If solver->mab is enabled:\n  - Let h = solver->heuristic (0=VSIDS, 1=CHB), other = 1-h.\n  - If (solver->mab_select[other] > 0) AND (solver->mab_reward[other] > solver->mab_reward[h] * 1.05) AND (solver->mab_conflicts >= solver->limits.restart.conflicts / 2), return true. (This triggers restart if the alternative MAB heuristic is performing >5% better on reward, to enable faster switching.)\n- Otherwise, return true only if the reluctant trigger fired.\n\nAlways return false if none of the above apply.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Required option and state guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // FOCUSED MODE: Adaptive glue and decision-rate restart\\n  if (!solver->stable) {\\n    // Conflict-based limit\\n    if (CONFLICTS >= solver->limits.restart.conflicts) {\\n      const double fast = AVERAGE(fast_glue);\\n      const double slow = AVERAGE(slow_glue);\\n      const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n      if (fast >= glue_margin * slow)\\n        return true;\\n    }\\n    // Decision rate drop: trigger earlier restart if search is stagnating\\n    {\\n      const double curr_rate = AVERAGE(decision_rate);\\n      // The \\\"last restart\\\" reference is not tracked explicitly in Kissat, so this path is a placeholder.\\n      // In a real implementation, you'd compare to a stored value at the last restart.\\n      // Here, as a practical heuristic, we trigger if decision rate drops below a threshold\\n      // and enough conflicts have occurred since last restart.\\n      const double threshold = 0.01; // essentially disables this path unless decision rate plummets\\n      if (curr_rate < threshold && CONFLICTS >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // STABLE MODE: Reluctant trigger and MAB opportunistic switching\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    if (solver->mab_select[other] > 0) {\\n      double my_reward = solver->mab_reward[h];\\n      double other_reward = solver->mab_reward[other];\\n      if (other_reward > my_reward * 1.05 &&\\n          solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n  }\\n\\n  return true;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: search tree non-root?\\n  if (!solver->level)\\n    return false;\\n\\n  // Mode: Focused (unstable) = glue-based + adaptive decision-rate\\n  if (!solver->stable) {\\n    // Glue-based restart: margin on fast/slow glue, only if enough conflicts\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        fast >= margin * slow)\\n      return true;\\n\\n    // Decision-rate adaptation: if decision rate dropped, restart early\\n    // (No direct access to \\\"decision rate at last restart\\\", so skip this extra)\\n    // Alternatively, allow early restart if glue is poor and half the interval passed\\n    if (CONFLICTS >= solver->limits.restart.conflicts / 2 &&\\n        fast >= 1.2 * slow)\\n      return true;\\n\\n    // Otherwise, no restart\\n    return false;\\n  }\\n\\n  // Mode: Stable = reluctant-based, with MAB early switch if needed\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  // Extra: If MAB enabled, allow opportunistic early restarts \\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    // \\\"other\\\" heuristic must have been tried\\n    if (solver->mab_select[other] > 0) {\\n      double my_reward = solver->mab_reward[h];\\n      double other_reward = solver->mab_reward[other];\\n      // If the alternative heuristic is >5% better in reward, and we've spent at least half the interval,\\n      // allow restart to enable faster switching\\n      if (other_reward > 1.05 * my_reward &&\\n          solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n  }\\n\\n  // Default: reluctant trigger controls restart\\n  return true;\\n}\\n",
    "par2_preferred": 174.62690000000003,
    "par2_rejected": 297.0078
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: Begin by checking required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0).\n- If (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)), return true.\n- Additionally, if (AVERAGE(decision_rate) < 0.95 * AVERAGE(decision_rate) at last restart) AND (CONFLICTS >= solver->limits.restart.conflicts / 2), return true. Otherwise, return false.\n\nIn stable mode (solver->stable == true):\n- If NOT kissat_reluctant_triggered(&solver->reluctant), return false.\n- If solver->mab is enabled:\n  - Let h = solver->heuristic (0=VSIDS, 1=CHB), other = 1-h.\n  - If (solver->mab_select[other] > 0) AND (solver->mab_reward[other] > solver->mab_reward[h] * 1.05) AND (solver->mab_conflicts >= solver->limits.restart.conflicts / 2), return true. (This triggers restart if the alternative MAB heuristic is performing >5% better on reward, to enable faster switching.)\n- Otherwise, return true only if the reluctant trigger fired.\n\nAlways return false if none of the above apply.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Fast check: not enough conflicts yet for restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- STABLE MODE (Reluctant/MAB) ---\\n  if (solver->stable) {\\n    // Only check reluctant trigger first\\n    if (!kissat_reluctant_triggered(&solver->reluctant))\\n      return false;\\n\\n    // MAB-adaptive: trigger early restart if alternative heuristic is clearly outperforming\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;\\n      unsigned other = 1 - h;\\n      if (solver->mab_select[other] > 0 &&\\n          solver->mab_reward[other] > solver->mab_reward[h] * 1.05 &&\\n          solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n    // Otherwise default to reluctant\\n    return true;\\n  }\\n\\n  // --- FOCUSED MODE (Glue-Adaptive) ---\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n  const double limit = margin * slow;\\n\\n  // Restart if clause quality deteriorates (glue-based)\\n  if (fast >= limit)\\n    return true;\\n\\n  // Additional: restart if search stagnates (decision rate drops)\\n  // We don't have 'decision rate at last restart', so safely skip this part.\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: search tree non-root?\\n  if (!solver->level)\\n    return false;\\n\\n  // Mode: Focused (unstable) = glue-based + adaptive decision-rate\\n  if (!solver->stable) {\\n    // Glue-based restart: margin on fast/slow glue, only if enough conflicts\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        fast >= margin * slow)\\n      return true;\\n\\n    // Decision-rate adaptation: if decision rate dropped, restart early\\n    // (No direct access to \\\"decision rate at last restart\\\", so skip this extra)\\n    // Alternatively, allow early restart if glue is poor and half the interval passed\\n    if (CONFLICTS >= solver->limits.restart.conflicts / 2 &&\\n        fast >= 1.2 * slow)\\n      return true;\\n\\n    // Otherwise, no restart\\n    return false;\\n  }\\n\\n  // Mode: Stable = reluctant-based, with MAB early switch if needed\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  // Extra: If MAB enabled, allow opportunistic early restarts \\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    // \\\"other\\\" heuristic must have been tried\\n    if (solver->mab_select[other] > 0) {\\n      double my_reward = solver->mab_reward[h];\\n      double other_reward = solver->mab_reward[other];\\n      // If the alternative heuristic is >5% better in reward, and we've spent at least half the interval,\\n      // allow restart to enable faster switching\\n      if (other_reward > 1.05 * my_reward &&\\n          solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n  }\\n\\n  // Default: reluctant trigger controls restart\\n  return true;\\n}\\n",
    "par2_preferred": 181.6064,
    "par2_rejected": 297.0078
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: Begin by checking required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0).\n- If (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)), return true.\n- Additionally, if (AVERAGE(decision_rate) < 0.95 * AVERAGE(decision_rate) at last restart) AND (CONFLICTS >= solver->limits.restart.conflicts / 2), return true. Otherwise, return false.\n\nIn stable mode (solver->stable == true):\n- If NOT kissat_reluctant_triggered(&solver->reluctant), return false.\n- If solver->mab is enabled:\n  - Let h = solver->heuristic (0=VSIDS, 1=CHB), other = 1-h.\n  - If (solver->mab_select[other] > 0) AND (solver->mab_reward[other] > solver->mab_reward[h] * 1.05) AND (solver->mab_conflicts >= solver->limits.restart.conflicts / 2), return true. (This triggers restart if the alternative MAB heuristic is performing >5% better on reward, to enable faster switching.)\n- Otherwise, return true only if the reluctant trigger fired.\n\nAlways return false if none of the above apply.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Focused mode: Adaptive Glue and Decision Rate restarts ---\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts / 2)\\n      return false;\\n\\n    const double glue_margin = 1.0 + ((double)GET_OPTION(restartmargin) / 100.0);\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        fast >= glue_margin * slow)\\n      return true;\\n\\n    // Decision rate based trigger (using 95% threshold)\\n    // Note: We don't have \\\"decision rate at last restart\\\" directly,\\n    // so this check falls back to the glue check above.\\n    // In a real implementation, you might track decision rate at last restart.\\n\\n    // Fallback: no decision rate memory, so don't trigger on that.\\n    return false;\\n  }\\n\\n  // --- Stable mode: Reluctant and MAB-based early restart ---\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    if (solver->mab_select[other] > 0 &&\\n        solver->mab_reward[other] > solver->mab_reward[h] * 1.05 &&\\n        solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n      return true;\\n  }\\n\\n  // Trigger restart if reluctant was triggered.\\n  return true;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: search tree non-root?\\n  if (!solver->level)\\n    return false;\\n\\n  // Mode: Focused (unstable) = glue-based + adaptive decision-rate\\n  if (!solver->stable) {\\n    // Glue-based restart: margin on fast/slow glue, only if enough conflicts\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        fast >= margin * slow)\\n      return true;\\n\\n    // Decision-rate adaptation: if decision rate dropped, restart early\\n    // (No direct access to \\\"decision rate at last restart\\\", so skip this extra)\\n    // Alternatively, allow early restart if glue is poor and half the interval passed\\n    if (CONFLICTS >= solver->limits.restart.conflicts / 2 &&\\n        fast >= 1.2 * slow)\\n      return true;\\n\\n    // Otherwise, no restart\\n    return false;\\n  }\\n\\n  // Mode: Stable = reluctant-based, with MAB early switch if needed\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  // Extra: If MAB enabled, allow opportunistic early restarts \\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    // \\\"other\\\" heuristic must have been tried\\n    if (solver->mab_select[other] > 0) {\\n      double my_reward = solver->mab_reward[h];\\n      double other_reward = solver->mab_reward[other];\\n      // If the alternative heuristic is >5% better in reward, and we've spent at least half the interval,\\n      // allow restart to enable faster switching\\n      if (other_reward > 1.05 * my_reward &&\\n          solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n  }\\n\\n  // Default: reluctant trigger controls restart\\n  return true;\\n}\\n",
    "par2_preferred": 183.00689999999994,
    "par2_rejected": 297.0078
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: Begin by checking required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0).\n- If (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)), return true.\n- Additionally, if (AVERAGE(decision_rate) < 0.95 * AVERAGE(decision_rate) at last restart) AND (CONFLICTS >= solver->limits.restart.conflicts / 2), return true. Otherwise, return false.\n\nIn stable mode (solver->stable == true):\n- If NOT kissat_reluctant_triggered(&solver->reluctant), return false.\n- If solver->mab is enabled:\n  - Let h = solver->heuristic (0=VSIDS, 1=CHB), other = 1-h.\n  - If (solver->mab_select[other] > 0) AND (solver->mab_reward[other] > solver->mab_reward[h] * 1.05) AND (solver->mab_conflicts >= solver->limits.restart.conflicts / 2), return true. (This triggers restart if the alternative MAB heuristic is performing >5% better on reward, to enable faster switching.)\n- Otherwise, return true only if the reluctant trigger fired.\n\nAlways return false if none of the above apply.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Check conflicts threshold\\n  const uint64_t conflicts = CONFLICTS;\\n  const uint64_t restart_conflicts = solver->limits.restart.conflicts;\\n\\n  // Stable mode\\n  if (solver->stable) {\\n    if (!kissat_reluctant_triggered(&solver->reluctant))\\n      return false;\\n\\n    // MAB-aware early restart in stable mode\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;\\n      unsigned other = 1 - h;\\n      // Only if other heuristic has been selected at least once\\n      if (solver->mab_select[other] > 0) {\\n        double curr = solver->mab_reward[h];\\n        double alt = solver->mab_reward[other];\\n        // If the alternative heuristic outperforms us by >5%\\n        if (alt > curr * 1.05 &&\\n            solver->mab_conflicts >= restart_conflicts / 2)\\n          return true;\\n      }\\n    }\\n    // Default: trigger when reluctant says so\\n    return true;\\n  }\\n\\n  // Focused mode: glue-based and decision-rate-based restarts\\n  if (conflicts < restart_conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n\\n  if (fast >= glue_margin * slow)\\n    return true;\\n\\n  // Decision rate early restart (if dropping sharply)\\n  // Note: No access to \\\"decision rate at last restart\\\" directly,\\n  // so this clause is omitted due to lack of such state in the API.\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: search tree non-root?\\n  if (!solver->level)\\n    return false;\\n\\n  // Mode: Focused (unstable) = glue-based + adaptive decision-rate\\n  if (!solver->stable) {\\n    // Glue-based restart: margin on fast/slow glue, only if enough conflicts\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        fast >= margin * slow)\\n      return true;\\n\\n    // Decision-rate adaptation: if decision rate dropped, restart early\\n    // (No direct access to \\\"decision rate at last restart\\\", so skip this extra)\\n    // Alternatively, allow early restart if glue is poor and half the interval passed\\n    if (CONFLICTS >= solver->limits.restart.conflicts / 2 &&\\n        fast >= 1.2 * slow)\\n      return true;\\n\\n    // Otherwise, no restart\\n    return false;\\n  }\\n\\n  // Mode: Stable = reluctant-based, with MAB early switch if needed\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  // Extra: If MAB enabled, allow opportunistic early restarts \\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    // \\\"other\\\" heuristic must have been tried\\n    if (solver->mab_select[other] > 0) {\\n      double my_reward = solver->mab_reward[h];\\n      double other_reward = solver->mab_reward[other];\\n      // If the alternative heuristic is >5% better in reward, and we've spent at least half the interval,\\n      // allow restart to enable faster switching\\n      if (other_reward > 1.05 * my_reward &&\\n          solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n  }\\n\\n  // Default: reluctant trigger controls restart\\n  return true;\\n}\\n",
    "par2_preferred": 183.07760000000002,
    "par2_rejected": 297.0078
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: Begin by checking required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0).\n- If (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)), return true.\n- Additionally, if (AVERAGE(decision_rate) < 0.95 * AVERAGE(decision_rate) at last restart) AND (CONFLICTS >= solver->limits.restart.conflicts / 2), return true. Otherwise, return false.\n\nIn stable mode (solver->stable == true):\n- If NOT kissat_reluctant_triggered(&solver->reluctant), return false.\n- If solver->mab is enabled:\n  - Let h = solver->heuristic (0=VSIDS, 1=CHB), other = 1-h.\n  - If (solver->mab_select[other] > 0) AND (solver->mab_reward[other] > solver->mab_reward[h] * 1.05) AND (solver->mab_conflicts >= solver->limits.restart.conflicts / 2), return true. (This triggers restart if the alternative MAB heuristic is performing >5% better on reward, to enable faster switching.)\n- Otherwise, return true only if the reluctant trigger fired.\n\nAlways return false if none of the above apply.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: glue margin or decision rate-based restarts\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n\\n    // Main focused mode glue trigger\\n    if (fast >= glue_margin * slow)\\n      return true;\\n\\n    // Secondary: decision rate drop (relative to last restart's average)\\n    // Note: Kissat does not store \\\"last restart\\\" decision rate, so omit this unless tracked.\\n    // (If required, add implementation here.)\\n\\n    return false;\\n  }\\n\\n  // Stable mode: reluctant trigger with MAB reward early switching\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    if (solver->mab_select[other] > 0 &&\\n        solver->mab_reward[other] > solver->mab_reward[h] * 1.05 &&\\n        solver->mab_conflicts >= solver->limits.restart.conflicts / 2) {\\n      return true;\\n    }\\n  }\\n\\n  // Default: only trigger on reluctant\\n  return true;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: search tree non-root?\\n  if (!solver->level)\\n    return false;\\n\\n  // Mode: Focused (unstable) = glue-based + adaptive decision-rate\\n  if (!solver->stable) {\\n    // Glue-based restart: margin on fast/slow glue, only if enough conflicts\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        fast >= margin * slow)\\n      return true;\\n\\n    // Decision-rate adaptation: if decision rate dropped, restart early\\n    // (No direct access to \\\"decision rate at last restart\\\", so skip this extra)\\n    // Alternatively, allow early restart if glue is poor and half the interval passed\\n    if (CONFLICTS >= solver->limits.restart.conflicts / 2 &&\\n        fast >= 1.2 * slow)\\n      return true;\\n\\n    // Otherwise, no restart\\n    return false;\\n  }\\n\\n  // Mode: Stable = reluctant-based, with MAB early switch if needed\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  // Extra: If MAB enabled, allow opportunistic early restarts \\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    // \\\"other\\\" heuristic must have been tried\\n    if (solver->mab_select[other] > 0) {\\n      double my_reward = solver->mab_reward[h];\\n      double other_reward = solver->mab_reward[other];\\n      // If the alternative heuristic is >5% better in reward, and we've spent at least half the interval,\\n      // allow restart to enable faster switching\\n      if (other_reward > 1.05 * my_reward &&\\n          solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n  }\\n\\n  // Default: reluctant trigger controls restart\\n  return true;\\n}\\n",
    "par2_preferred": 183.0805,
    "par2_rejected": 297.0078
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: Begin by checking required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0).\n- If (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)), return true.\n- Additionally, if (AVERAGE(decision_rate) < 0.95 * AVERAGE(decision_rate) at last restart) AND (CONFLICTS >= solver->limits.restart.conflicts / 2), return true. Otherwise, return false.\n\nIn stable mode (solver->stable == true):\n- If NOT kissat_reluctant_triggered(&solver->reluctant), return false.\n- If solver->mab is enabled:\n  - Let h = solver->heuristic (0=VSIDS, 1=CHB), other = 1-h.\n  - If (solver->mab_select[other] > 0) AND (solver->mab_reward[other] > solver->mab_reward[h] * 1.05) AND (solver->mab_conflicts >= solver->limits.restart.conflicts / 2), return true. (This triggers restart if the alternative MAB heuristic is performing >5% better on reward, to enable faster switching.)\n- Otherwise, return true only if the reluctant trigger fired.\n\nAlways return false if none of the above apply.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: adaptive glue & decision rate restarts\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n\\n    if (fast >= margin * slow)\\n      return true;\\n\\n    // Decision rate stagnation: trigger restart if search slows down\\n    // Note: For this signal, we do not have \\\"decision_rate at last restart\\\" directly.\\n    // As a proxy, only trigger if decision rate drops below 95% of current average.\\n    // This is a conservative heuristic, but matches the algorithm intent.\\n    if (AVERAGE(decision_rate) < 0.95 * solver->averages[solver->stable].decision_rate.value &&\\n        CONFLICTS >= solver->limits.restart.conflicts / 2)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // Stable mode: reluctant, with MAB early switch\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    if (solver->mab_select[other] > 0 &&\\n        solver->mab_reward[other] > solver->mab_reward[h] * 1.05 &&\\n        solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n      return true;\\n  }\\n\\n  return true;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: search tree non-root?\\n  if (!solver->level)\\n    return false;\\n\\n  // Mode: Focused (unstable) = glue-based + adaptive decision-rate\\n  if (!solver->stable) {\\n    // Glue-based restart: margin on fast/slow glue, only if enough conflicts\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        fast >= margin * slow)\\n      return true;\\n\\n    // Decision-rate adaptation: if decision rate dropped, restart early\\n    // (No direct access to \\\"decision rate at last restart\\\", so skip this extra)\\n    // Alternatively, allow early restart if glue is poor and half the interval passed\\n    if (CONFLICTS >= solver->limits.restart.conflicts / 2 &&\\n        fast >= 1.2 * slow)\\n      return true;\\n\\n    // Otherwise, no restart\\n    return false;\\n  }\\n\\n  // Mode: Stable = reluctant-based, with MAB early switch if needed\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  // Extra: If MAB enabled, allow opportunistic early restarts \\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    // \\\"other\\\" heuristic must have been tried\\n    if (solver->mab_select[other] > 0) {\\n      double my_reward = solver->mab_reward[h];\\n      double other_reward = solver->mab_reward[other];\\n      // If the alternative heuristic is >5% better in reward, and we've spent at least half the interval,\\n      // allow restart to enable faster switching\\n      if (other_reward > 1.05 * my_reward &&\\n          solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n  }\\n\\n  // Default: reluctant trigger controls restart\\n  return true;\\n}\\n",
    "par2_preferred": 183.164,
    "par2_rejected": 297.0078
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: Begin by checking required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0).\n- If (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)), return true.\n- Additionally, if (AVERAGE(decision_rate) < 0.95 * AVERAGE(decision_rate) at last restart) AND (CONFLICTS >= solver->limits.restart.conflicts / 2), return true. Otherwise, return false.\n\nIn stable mode (solver->stable == true):\n- If NOT kissat_reluctant_triggered(&solver->reluctant), return false.\n- If solver->mab is enabled:\n  - Let h = solver->heuristic (0=VSIDS, 1=CHB), other = 1-h.\n  - If (solver->mab_select[other] > 0) AND (solver->mab_reward[other] > solver->mab_reward[h] * 1.05) AND (solver->mab_conflicts >= solver->limits.restart.conflicts / 2), return true. (This triggers restart if the alternative MAB heuristic is performing >5% better on reward, to enable faster switching.)\n- Otherwise, return true only if the reluctant trigger fired.\n\nAlways return false if none of the above apply.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: Adaptive glue-based and decision rate-based restart\\n  if (!solver->stable) {\\n    if (CONFLICTS >= solver->limits.restart.conflicts) {\\n      const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n      const double fast = AVERAGE(fast_glue);\\n      const double slow = AVERAGE(slow_glue);\\n      if (fast >= glue_margin * slow)\\n        return true;\\n    }\\n    // Extra: decision rate drop triggers restart (if conflicts past halfway to limit)\\n    if (CONFLICTS >= solver->limits.restart.conflicts / 2) {\\n      // This is a heuristic; we use a static threshold since \\\"at last restart\\\" value is not available\\n      const double rate = AVERAGE(decision_rate);\\n      // Only trigger if decision rate drops very low (arbitrary, e.g. 5% drop)\\n      // Since we do not store the last-restart rate, skip this unless state is available\\n      // (If you wish to activate, store last restart average elsewhere.)\\n    }\\n    return false;\\n  }\\n\\n  // Stable mode: Reluctant trigger + MAB reward-based early restart\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  // MAB-aware early switching\\n  if (solver->mab) {\\n    const unsigned h = solver->heuristic;\\n    const unsigned other = 1 - h;\\n    if (solver->mab_select[other] > 0 &&\\n        solver->mab_reward[other] > solver->mab_reward[h] * 1.05 &&\\n        solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n      return true;\\n  }\\n\\n  // Standard reluctant restart if no MAB early switch\\n  return true;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: search tree non-root?\\n  if (!solver->level)\\n    return false;\\n\\n  // Mode: Focused (unstable) = glue-based + adaptive decision-rate\\n  if (!solver->stable) {\\n    // Glue-based restart: margin on fast/slow glue, only if enough conflicts\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        fast >= margin * slow)\\n      return true;\\n\\n    // Decision-rate adaptation: if decision rate dropped, restart early\\n    // (No direct access to \\\"decision rate at last restart\\\", so skip this extra)\\n    // Alternatively, allow early restart if glue is poor and half the interval passed\\n    if (CONFLICTS >= solver->limits.restart.conflicts / 2 &&\\n        fast >= 1.2 * slow)\\n      return true;\\n\\n    // Otherwise, no restart\\n    return false;\\n  }\\n\\n  // Mode: Stable = reluctant-based, with MAB early switch if needed\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  // Extra: If MAB enabled, allow opportunistic early restarts \\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    // \\\"other\\\" heuristic must have been tried\\n    if (solver->mab_select[other] > 0) {\\n      double my_reward = solver->mab_reward[h];\\n      double other_reward = solver->mab_reward[other];\\n      // If the alternative heuristic is >5% better in reward, and we've spent at least half the interval,\\n      // allow restart to enable faster switching\\n      if (other_reward > 1.05 * my_reward &&\\n          solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n  }\\n\\n  // Default: reluctant trigger controls restart\\n  return true;\\n}\\n",
    "par2_preferred": 184.31530000000006,
    "par2_rejected": 297.0078
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: Begin by checking required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0).\n- If (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)), return true.\n- Additionally, if (AVERAGE(decision_rate) < 0.95 * AVERAGE(decision_rate) at last restart) AND (CONFLICTS >= solver->limits.restart.conflicts / 2), return true. Otherwise, return false.\n\nIn stable mode (solver->stable == true):\n- If NOT kissat_reluctant_triggered(&solver->reluctant), return false.\n- If solver->mab is enabled:\n  - Let h = solver->heuristic (0=VSIDS, 1=CHB), other = 1-h.\n  - If (solver->mab_select[other] > 0) AND (solver->mab_reward[other] > solver->mab_reward[h] * 1.05) AND (solver->mab_conflicts >= solver->limits.restart.conflicts / 2), return true. (This triggers restart if the alternative MAB heuristic is performing >5% better on reward, to enable faster switching.)\n- Otherwise, return true only if the reluctant trigger fired.\n\nAlways return false if none of the above apply.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: glue-based and adaptive decision-rate restart\\n  if (!solver->stable) {\\n    // Guard: only after enough conflicts\\n    if (CONFLICTS >= solver->limits.restart.conflicts) {\\n      const double fast = AVERAGE(fast_glue);\\n      const double slow = AVERAGE(slow_glue);\\n      const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n      if (fast >= glue_margin * slow)\\n        return true;\\n    }\\n    // Adaptive: if decision rate substantially dropped, allow earlier restart\\n    if (CONFLICTS >= (solver->limits.restart.conflicts / 2)) {\\n      // Use a \\\"reference\\\" as the current decision rate limit at last restart\\n      // In Kissat, there's no explicit \\\"decision_rate at last restart\\\" stored, so this branch is illustrative.\\n      // We'll compare current decision rate to its EMA, accepting some lag.\\n      const double curr_decision_rate = AVERAGE(decision_rate);\\n      // If current decision rate drops below 95% of its running average (i.e., search slows)\\n      if (curr_decision_rate < 0.95 * AVERAGE(decision_rate))\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // Stable mode: reluctant restart with MAB-aware heuristics\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    // Only compare if other heuristic has been selected at all\\n    if (solver->mab_select[other] > 0) {\\n      double my_reward = solver->mab_reward[h];\\n      double other_reward = solver->mab_reward[other];\\n      // If other heuristic's reward is more than 5% better, and enough conflicts elapsed, restart early\\n      if (other_reward > 1.05 * my_reward &&\\n          solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n  }\\n\\n  // Default: reluctant triggers regular restart\\n  return true;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: search tree non-root?\\n  if (!solver->level)\\n    return false;\\n\\n  // Mode: Focused (unstable) = glue-based + adaptive decision-rate\\n  if (!solver->stable) {\\n    // Glue-based restart: margin on fast/slow glue, only if enough conflicts\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        fast >= margin * slow)\\n      return true;\\n\\n    // Decision-rate adaptation: if decision rate dropped, restart early\\n    // (No direct access to \\\"decision rate at last restart\\\", so skip this extra)\\n    // Alternatively, allow early restart if glue is poor and half the interval passed\\n    if (CONFLICTS >= solver->limits.restart.conflicts / 2 &&\\n        fast >= 1.2 * slow)\\n      return true;\\n\\n    // Otherwise, no restart\\n    return false;\\n  }\\n\\n  // Mode: Stable = reluctant-based, with MAB early switch if needed\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  // Extra: If MAB enabled, allow opportunistic early restarts \\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    // \\\"other\\\" heuristic must have been tried\\n    if (solver->mab_select[other] > 0) {\\n      double my_reward = solver->mab_reward[h];\\n      double other_reward = solver->mab_reward[other];\\n      // If the alternative heuristic is >5% better in reward, and we've spent at least half the interval,\\n      // allow restart to enable faster switching\\n      if (other_reward > 1.05 * my_reward &&\\n          solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n  }\\n\\n  // Default: reluctant trigger controls restart\\n  return true;\\n}\\n",
    "par2_preferred": 184.48550000000003,
    "par2_rejected": 297.0078
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restart\n\nAlgorithm: Begin by checking required guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- Compute glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0).\n- If (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)), return true.\n- Additionally, if (AVERAGE(decision_rate) < 0.95 * AVERAGE(decision_rate) at last restart) AND (CONFLICTS >= solver->limits.restart.conflicts / 2), return true. Otherwise, return false.\n\nIn stable mode (solver->stable == true):\n- If NOT kissat_reluctant_triggered(&solver->reluctant), return false.\n- If solver->mab is enabled:\n  - Let h = solver->heuristic (0=VSIDS, 1=CHB), other = 1-h.\n  - If (solver->mab_select[other] > 0) AND (solver->mab_reward[other] > solver->mab_reward[h] * 1.05) AND (solver->mab_conflicts >= solver->limits.restart.conflicts / 2), return true. (This triggers restart if the alternative MAB heuristic is performing >5% better on reward, to enable faster switching.)\n- Otherwise, return true only if the reluctant trigger fired.\n\nAlways return false if none of the above apply.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: Adaptive glue and decision rate\\n    const double glue_margin = 1.0 + ((double)GET_OPTION(restartmargin) / 100.0);\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    if (fast >= glue_margin * slow)\\n      return true;\\n\\n    // Bonus: decision rate drop triggers early restart\\n    // Since we do not track decision rate at last restart, fallback to previous heuristic:\\n    // If the decision rate drops below a hard threshold (e.g., <0.5), allow early restart\\n    const double drate = AVERAGE(decision_rate);\\n    if (drate < 0.5 && CONFLICTS >= solver->limits.restart.conflicts / 2)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // Stable mode: Reluctant triggered, with MAB-based opportunistic restart\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    // Allow opportunistic restart if other heuristic is clearly better (reward >5% higher)\\n    if (solver->mab_select[other] > 0 &&\\n        solver->mab_reward[other] > 1.05 * solver->mab_reward[h] &&\\n        solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n      return true;\\n  }\\n\\n  // Default: reluctant triggered\\n  return true;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: search tree non-root?\\n  if (!solver->level)\\n    return false;\\n\\n  // Mode: Focused (unstable) = glue-based + adaptive decision-rate\\n  if (!solver->stable) {\\n    // Glue-based restart: margin on fast/slow glue, only if enough conflicts\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        fast >= margin * slow)\\n      return true;\\n\\n    // Decision-rate adaptation: if decision rate dropped, restart early\\n    // (No direct access to \\\"decision rate at last restart\\\", so skip this extra)\\n    // Alternatively, allow early restart if glue is poor and half the interval passed\\n    if (CONFLICTS >= solver->limits.restart.conflicts / 2 &&\\n        fast >= 1.2 * slow)\\n      return true;\\n\\n    // Otherwise, no restart\\n    return false;\\n  }\\n\\n  // Mode: Stable = reluctant-based, with MAB early switch if needed\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  // Extra: If MAB enabled, allow opportunistic early restarts \\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned other = 1 - h;\\n    // \\\"other\\\" heuristic must have been tried\\n    if (solver->mab_select[other] > 0) {\\n      double my_reward = solver->mab_reward[h];\\n      double other_reward = solver->mab_reward[other];\\n      // If the alternative heuristic is >5% better in reward, and we've spent at least half the interval,\\n      // allow restart to enable faster switching\\n      if (other_reward > 1.05 * my_reward &&\\n          solver->mab_conflicts >= solver->limits.restart.conflicts / 2)\\n        return true;\\n    }\\n  }\\n\\n  // Default: reluctant trigger controls restart\\n  return true;\\n}\\n",
    "par2_preferred": 184.8826,
    "par2_rejected": 297.0078
  },
  {
    "algorithm_description": "Name: Glue+MAB Adaptive Restart\n\nAlgorithm: 1. If solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n\n2. If solver->stable == false (focused mode):\n   a. Compute margin = GET_OPTION(restartmargin).\n   b. Trigger restart if:\n      - CONFLICTS >= solver->limits.restart.conflicts\n      - AND AVERAGE(fast_glue) >= (1.0 + margin/100.0) * AVERAGE(slow_glue)\n      - AND AVERAGE(decision_rate) < 1.2 * AVERAGE(slow_glue) // Only if decision rate is dropping, i.e. search is stagnating\n   c. Return true if all above are satisfied; else false.\n\n3. If solver->stable == true (stable mode):\n   a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n   b. If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   c. // MAB-aware fast-path: If solver->mab is enabled and solver->mab_decisions/conflicts < (0.8 * max(solver->mab_reward[0], solver->mab_reward[1])), return true.\n      - This triggers an earlier restart if current progress per conflict drops below 80% of best recent MAB reward (using observed log2(decisions)/log2(conflicts)), indicating search inefficiency.\n   d. Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: enough conflicts for next restart window?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode: Glue+Decision-rate adaptive restart ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast < limit)\\n      return false;\\n\\n    // Stagnation: compare decision rate to glue baseline\\n    const double rate = AVERAGE(decision_rate);\\n    if (rate < 1.2 * slow)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode: Reluctant Luby, with MAB-early-exit if enabled ---\\n  // Only allow restart if we're at or past the next restart conflict limit\\n  // (already checked above).\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: Early restart if search is clearly underperforming\\n  if (solver->mab) {\\n    // Compute average reward for VSIDS/CHB arms (protection against div0)\\n    double max_reward = 0.0;\\n    if (solver->mab_select[0])\\n      max_reward = solver->mab_reward[0] / solver->mab_select[0];\\n    if (solver->mab_select[1]) {\\n      double chb_avg = solver->mab_reward[1] / solver->mab_select[1];\\n      if (chb_avg > max_reward)\\n        max_reward = chb_avg;\\n    }\\n    // Only trigger if we have at least some reward history\\n    if (max_reward > 0.0 && solver->mab_conflicts > 0) {\\n      double mab_decisions_per_conflict = solver->mab_decisions / solver->mab_conflicts;\\n      if (mab_decisions_per_conflict < 0.8 * max_reward)\\n        return true;\\n    }\\n  }\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Restart globally disabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Don't restart if no decisions made yet.\\n  if (!solver->level)\\n    return false;\\n\\n  // Not yet reached the next restart conflict threshold.\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode: glue+decision-rate restart ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const int margin = GET_OPTION(restartmargin);\\n    const double glue_limit = (1.0 + ((double)margin / 100.0)) * slow;\\n    const double decision_rate = AVERAGE(decision_rate);\\n\\n    // Only restart if glue ratio is exceeded and the decision rate is dropping (search stagnation).\\n    // The threshold 1.2*slow_glue for decision rate is an empirical 'stagnation floor'.\\n    if (fast >= glue_limit && decision_rate < 1.2 * slow)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode: Luby, with MAB adaptive trigger ---\\n  // Luby: only restart if reluctant trigger fires\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // If MAB is enabled, allow adaptive early restart if progress is bad\\n  if (solver->mab && solver->mab_conflicts > 0) {\\n    // Use per-restart decisions/conflicts as current reward\\n    double current_reward = solver->mab_decisions / (double)solver->mab_conflicts;\\n\\n    // Use the best recent cumulative reward as the reference\\n    double mab0 = solver->mab_reward[0];\\n    double mab1 = solver->mab_reward[1];\\n    double best_reward = (mab0 > mab1) ? mab0 : mab1;\\n\\n    // Defensive: avoid division by zero/NaN\\n    if (best_reward > 0.0) {\\n      // If current progress per conflict is less than 80% of best recent, restart\\n      if (current_reward < 0.8 * best_reward)\\n        return true;\\n    }\\n  }\\n\\n  // Otherwise, no restart\\n  return false;\\n}\\n",
    "par2_preferred": 186.64529999999996,
    "par2_rejected": 202.3066
  },
  {
    "algorithm_description": "Name: Glue+MAB Adaptive Restart\n\nAlgorithm: 1. If solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n\n2. If solver->stable == false (focused mode):\n   a. Compute margin = GET_OPTION(restartmargin).\n   b. Trigger restart if:\n      - CONFLICTS >= solver->limits.restart.conflicts\n      - AND AVERAGE(fast_glue) >= (1.0 + margin/100.0) * AVERAGE(slow_glue)\n      - AND AVERAGE(decision_rate) < 1.2 * AVERAGE(slow_glue) // Only if decision rate is dropping, i.e. search is stagnating\n   c. Return true if all above are satisfied; else false.\n\n3. If solver->stable == true (stable mode):\n   a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n   b. If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   c. // MAB-aware fast-path: If solver->mab is enabled and solver->mab_decisions/conflicts < (0.8 * max(solver->mab_reward[0], solver->mab_reward[1])), return true.\n      - This triggers an earlier restart if current progress per conflict drops below 80% of best recent MAB reward (using observed log2(decisions)/log2(conflicts)), indicating search inefficiency.\n   d. Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: enough conflicts for next restart window?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode: Glue+Decision-rate adaptive restart ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast < limit)\\n      return false;\\n\\n    // Stagnation: compare decision rate to glue baseline\\n    const double rate = AVERAGE(decision_rate);\\n    if (rate < 1.2 * slow)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode: Reluctant Luby, with MAB-early-exit if enabled ---\\n  // Only allow restart if we're at or past the next restart conflict limit\\n  // (already checked above).\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: Early restart if search is clearly underperforming\\n  if (solver->mab) {\\n    // Compute average reward for VSIDS/CHB arms (protection against div0)\\n    double max_reward = 0.0;\\n    if (solver->mab_select[0])\\n      max_reward = solver->mab_reward[0] / solver->mab_select[0];\\n    if (solver->mab_select[1]) {\\n      double chb_avg = solver->mab_reward[1] / solver->mab_select[1];\\n      if (chb_avg > max_reward)\\n        max_reward = chb_avg;\\n    }\\n    // Only trigger if we have at least some reward history\\n    if (max_reward > 0.0 && solver->mab_conflicts > 0) {\\n      double mab_decisions_per_conflict = solver->mab_decisions / solver->mab_conflicts;\\n      if (mab_decisions_per_conflict < 0.8 * max_reward)\\n        return true;\\n    }\\n  }\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guards: options, at root, etc.\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (solver->unassigned == 0)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue and decision rate based\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const int margin_opt = GET_OPTION(restartmargin);\\n    const double margin = (100.0 + margin_opt) / 100.0;\\n    const double glue_limit = margin * slow;\\n\\n    // Decision rate stagnation cutoff\\n    const double decision_rate = AVERAGE(decision_rate);\\n    const double decision_rate_limit = 1.2 * slow;\\n\\n    // All conditions must be satisfied\\n    if (fast >= glue_limit && decision_rate < decision_rate_limit)\\n      return true;\\n    else\\n      return false;\\n  } else {\\n    // Stable mode: reluctant + MAB-aware shortcut\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    // Standard reluctant (Luby) restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: If enabled and current progress is below 80% of best MAB reward, restart early\\n    if (solver->mab && solver->mab_conflicts > 0) {\\n      double reward0 = solver->mab_reward[0];\\n      double reward1 = solver->mab_reward[1];\\n      double best_reward = reward0 > reward1 ? reward0 : reward1;\\n      if (best_reward > 0.0) {\\n        double current_progress = solver->mab_decisions / (double)solver->mab_conflicts;\\n        if (current_progress < 0.8 * best_reward)\\n          return true;\\n      }\\n    }\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 186.64529999999996,
    "par2_rejected": 203.79510000000002
  },
  {
    "algorithm_description": "Name: Glue+MAB Adaptive Restart\n\nAlgorithm: 1. If solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n\n2. If solver->stable == false (focused mode):\n   a. Compute margin = GET_OPTION(restartmargin).\n   b. Trigger restart if:\n      - CONFLICTS >= solver->limits.restart.conflicts\n      - AND AVERAGE(fast_glue) >= (1.0 + margin/100.0) * AVERAGE(slow_glue)\n      - AND AVERAGE(decision_rate) < 1.2 * AVERAGE(slow_glue) // Only if decision rate is dropping, i.e. search is stagnating\n   c. Return true if all above are satisfied; else false.\n\n3. If solver->stable == true (stable mode):\n   a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n   b. If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   c. // MAB-aware fast-path: If solver->mab is enabled and solver->mab_decisions/conflicts < (0.8 * max(solver->mab_reward[0], solver->mab_reward[1])), return true.\n      - This triggers an earlier restart if current progress per conflict drops below 80% of best recent MAB reward (using observed log2(decisions)/log2(conflicts)), indicating search inefficiency.\n   d. Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: enough conflicts for next restart window?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode: Glue+Decision-rate adaptive restart ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast < limit)\\n      return false;\\n\\n    // Stagnation: compare decision rate to glue baseline\\n    const double rate = AVERAGE(decision_rate);\\n    if (rate < 1.2 * slow)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode: Reluctant Luby, with MAB-early-exit if enabled ---\\n  // Only allow restart if we're at or past the next restart conflict limit\\n  // (already checked above).\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: Early restart if search is clearly underperforming\\n  if (solver->mab) {\\n    // Compute average reward for VSIDS/CHB arms (protection against div0)\\n    double max_reward = 0.0;\\n    if (solver->mab_select[0])\\n      max_reward = solver->mab_reward[0] / solver->mab_select[0];\\n    if (solver->mab_select[1]) {\\n      double chb_avg = solver->mab_reward[1] / solver->mab_select[1];\\n      if (chb_avg > max_reward)\\n        max_reward = chb_avg;\\n    }\\n    // Only trigger if we have at least some reward history\\n    if (max_reward > 0.0 && solver->mab_conflicts > 0) {\\n      double mab_decisions_per_conflict = solver->mab_decisions / solver->mab_conflicts;\\n      if (mab_decisions_per_conflict < 0.8 * max_reward)\\n        return true;\\n    }\\n  }\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. Guard: restarts enabled, in search, at decision level > 0\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // 2. Focused mode: glue-based + stagnation criteria\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    const double decision_rate = AVERAGE(decision_rate);\\n    // Stagnation: decision rate should be less than 1.2 * slow glue\\n    if (fast >= limit && decision_rate < 1.2 * slow)\\n      return true;\\n    return false;\\n  }\\n\\n  // 3. Stable mode: Luby/reltuctant, with MAB-aware early restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // 3.a. Standard Luby/reltuctant trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // 3.b. MAB: If enabled, early restart if current progress is poor\\n  if (solver->mab) {\\n    // Defensive: avoid div by zero\\n    if (solver->mab_conflicts > 0) {\\n      // Progress = decisions/conflicts since last restart\\n      const double progress = solver->mab_decisions / (double)solver->mab_conflicts;\\n      // Find best historical reward\\n      double best = solver->mab_reward[0];\\n      if (solver->mab_reward[1] > best)\\n        best = solver->mab_reward[1];\\n      // Defensive: avoid division by zero or negative best\\n      if (best > 0.0 && progress < 0.8 * best)\\n        return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 186.64529999999996,
    "par2_rejected": 204.00969999999998
  },
  {
    "algorithm_description": "Name: Glue+MAB Adaptive Restart\n\nAlgorithm: 1. If solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n\n2. If solver->stable == false (focused mode):\n   a. Compute margin = GET_OPTION(restartmargin).\n   b. Trigger restart if:\n      - CONFLICTS >= solver->limits.restart.conflicts\n      - AND AVERAGE(fast_glue) >= (1.0 + margin/100.0) * AVERAGE(slow_glue)\n      - AND AVERAGE(decision_rate) < 1.2 * AVERAGE(slow_glue) // Only if decision rate is dropping, i.e. search is stagnating\n   c. Return true if all above are satisfied; else false.\n\n3. If solver->stable == true (stable mode):\n   a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n   b. If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   c. // MAB-aware fast-path: If solver->mab is enabled and solver->mab_decisions/conflicts < (0.8 * max(solver->mab_reward[0], solver->mab_reward[1])), return true.\n      - This triggers an earlier restart if current progress per conflict drops below 80% of best recent MAB reward (using observed log2(decisions)/log2(conflicts)), indicating search inefficiency.\n   d. Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: enough conflicts for next restart window?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode: Glue+Decision-rate adaptive restart ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast < limit)\\n      return false;\\n\\n    // Stagnation: compare decision rate to glue baseline\\n    const double rate = AVERAGE(decision_rate);\\n    if (rate < 1.2 * slow)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode: Reluctant Luby, with MAB-early-exit if enabled ---\\n  // Only allow restart if we're at or past the next restart conflict limit\\n  // (already checked above).\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: Early restart if search is clearly underperforming\\n  if (solver->mab) {\\n    // Compute average reward for VSIDS/CHB arms (protection against div0)\\n    double max_reward = 0.0;\\n    if (solver->mab_select[0])\\n      max_reward = solver->mab_reward[0] / solver->mab_select[0];\\n    if (solver->mab_select[1]) {\\n      double chb_avg = solver->mab_reward[1] / solver->mab_select[1];\\n      if (chb_avg > max_reward)\\n        max_reward = chb_avg;\\n    }\\n    // Only trigger if we have at least some reward history\\n    if (max_reward > 0.0 && solver->mab_conflicts > 0) {\\n      double mab_decisions_per_conflict = solver->mab_decisions / solver->mab_conflicts;\\n      if (mab_decisions_per_conflict < 0.8 * max_reward)\\n        return true;\\n    }\\n  }\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: Restarts disabled by option\\n  if (!GET_OPTION(restart))\\n    return false;\\n  // Guard: No restart at root level\\n  if (!solver->level)\\n    return false;\\n  // Guard: Not enough conflicts for next allowed restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Focused mode: Glue+DecisionRate restart\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    const double decision_rate = AVERAGE(decision_rate);\\n\\n    // Only trigger if glue is bad AND decision rate is dropping (stagnation)\\n    if (fast >= limit && decision_rate < 1.2 * slow)\\n      return true;\\n    else\\n      return false;\\n  }\\n\\n  // Stable mode: reluctant + MAB reward aware\\n  // Luby/reluctant trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-augmented: if enabled, check for search inefficiency\\n  if (solver->mab && solver->mab_conflicts > 0) {\\n    // Defensive: avoid division by zero\\n    double curr = solver->mab_decisions / (double) solver->mab_conflicts;\\n    double best = solver->mab_reward[0];\\n    if (solver->mab_reward[1] > best)\\n      best = solver->mab_reward[1];\\n    // Only trigger if current is < 80% of best observed reward and best > 0\\n    if (best > 0.0 && curr < 0.8 * best)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 186.64529999999996,
    "par2_rejected": 204.04769999999994
  },
  {
    "algorithm_description": "Name: Glue+MAB Adaptive Restart\n\nAlgorithm: 1. If solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n\n2. If solver->stable == false (focused mode):\n   a. Compute margin = GET_OPTION(restartmargin).\n   b. Trigger restart if:\n      - CONFLICTS >= solver->limits.restart.conflicts\n      - AND AVERAGE(fast_glue) >= (1.0 + margin/100.0) * AVERAGE(slow_glue)\n      - AND AVERAGE(decision_rate) < 1.2 * AVERAGE(slow_glue) // Only if decision rate is dropping, i.e. search is stagnating\n   c. Return true if all above are satisfied; else false.\n\n3. If solver->stable == true (stable mode):\n   a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n   b. If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   c. // MAB-aware fast-path: If solver->mab is enabled and solver->mab_decisions/conflicts < (0.8 * max(solver->mab_reward[0], solver->mab_reward[1])), return true.\n      - This triggers an earlier restart if current progress per conflict drops below 80% of best recent MAB reward (using observed log2(decisions)/log2(conflicts)), indicating search inefficiency.\n   d. Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: enough conflicts for next restart window?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode: Glue+Decision-rate adaptive restart ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast < limit)\\n      return false;\\n\\n    // Stagnation: compare decision rate to glue baseline\\n    const double rate = AVERAGE(decision_rate);\\n    if (rate < 1.2 * slow)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode: Reluctant Luby, with MAB-early-exit if enabled ---\\n  // Only allow restart if we're at or past the next restart conflict limit\\n  // (already checked above).\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: Early restart if search is clearly underperforming\\n  if (solver->mab) {\\n    // Compute average reward for VSIDS/CHB arms (protection against div0)\\n    double max_reward = 0.0;\\n    if (solver->mab_select[0])\\n      max_reward = solver->mab_reward[0] / solver->mab_select[0];\\n    if (solver->mab_select[1]) {\\n      double chb_avg = solver->mab_reward[1] / solver->mab_select[1];\\n      if (chb_avg > max_reward)\\n        max_reward = chb_avg;\\n    }\\n    // Only trigger if we have at least some reward history\\n    if (max_reward > 0.0 && solver->mab_conflicts > 0) {\\n      double mab_decisions_per_conflict = solver->mab_decisions / solver->mab_conflicts;\\n      if (mab_decisions_per_conflict < 0.8 * max_reward)\\n        return true;\\n    }\\n  }\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts globally disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: only restart if not at root level\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: only restart if conflict threshold reached\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Focused mode: glue margin + decision rate stagnation\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const int margin_opt = GET_OPTION(restartmargin);\\n    const double margin = (100.0 + margin_opt) / 100.0;\\n    const double limit = margin * slow;\\n\\n    // Decision rate stagnation: below 1.2 * slow_glue (acts as a quality floor)\\n    const double dec_rate = AVERAGE(decision_rate);\\n    const double stagnation_limit = 1.2 * slow;\\n\\n    if (fast >= limit && dec_rate < stagnation_limit)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // Stable mode: Luby/reluctant + MAB-aware early restart\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB fast-path: if enabled, restart if progress is poor relative to best reward\\n  if (solver->mab && solver->mab_conflicts > 0) {\\n    // Defensive: avoid division by zero\\n    double mab_progress = solver->mab_decisions / (double) solver->mab_conflicts;\\n    double reward0 = solver->mab_reward[0];\\n    double reward1 = solver->mab_reward[1];\\n    double best_reward = reward0 > reward1 ? reward0 : reward1;\\n    // Only consider if best_reward is positive and meaningful\\n    if (best_reward > 0.0 && mab_progress < 0.8 * best_reward)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 186.64529999999996,
    "par2_rejected": 204.05539999999993
  },
  {
    "algorithm_description": "Name: Glue+MAB Adaptive Restart\n\nAlgorithm: 1. If solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n\n2. If solver->stable == false (focused mode):\n   a. Compute margin = GET_OPTION(restartmargin).\n   b. Trigger restart if:\n      - CONFLICTS >= solver->limits.restart.conflicts\n      - AND AVERAGE(fast_glue) >= (1.0 + margin/100.0) * AVERAGE(slow_glue)\n      - AND AVERAGE(decision_rate) < 1.2 * AVERAGE(slow_glue) // Only if decision rate is dropping, i.e. search is stagnating\n   c. Return true if all above are satisfied; else false.\n\n3. If solver->stable == true (stable mode):\n   a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n   b. If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   c. // MAB-aware fast-path: If solver->mab is enabled and solver->mab_decisions/conflicts < (0.8 * max(solver->mab_reward[0], solver->mab_reward[1])), return true.\n      - This triggers an earlier restart if current progress per conflict drops below 80% of best recent MAB reward (using observed log2(decisions)/log2(conflicts)), indicating search inefficiency.\n   d. Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: enough conflicts for next restart window?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode: Glue+Decision-rate adaptive restart ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast < limit)\\n      return false;\\n\\n    // Stagnation: compare decision rate to glue baseline\\n    const double rate = AVERAGE(decision_rate);\\n    if (rate < 1.2 * slow)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode: Reluctant Luby, with MAB-early-exit if enabled ---\\n  // Only allow restart if we're at or past the next restart conflict limit\\n  // (already checked above).\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: Early restart if search is clearly underperforming\\n  if (solver->mab) {\\n    // Compute average reward for VSIDS/CHB arms (protection against div0)\\n    double max_reward = 0.0;\\n    if (solver->mab_select[0])\\n      max_reward = solver->mab_reward[0] / solver->mab_select[0];\\n    if (solver->mab_select[1]) {\\n      double chb_avg = solver->mab_reward[1] / solver->mab_select[1];\\n      if (chb_avg > max_reward)\\n        max_reward = chb_avg;\\n    }\\n    // Only trigger if we have at least some reward history\\n    if (max_reward > 0.0 && solver->mab_conflicts > 0) {\\n      double mab_decisions_per_conflict = solver->mab_decisions / solver->mab_conflicts;\\n      if (mab_decisions_per_conflict < 0.8 * max_reward)\\n        return true;\\n    }\\n  }\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // At root level, no restart.\\n  if (!solver->level)\\n    return false;\\n\\n  // Not enough conflicts for next restart window.\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // ========== Focused mode ==========\\n  if (!solver->stable) {\\n    // --- Glue-based restart ---\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    // --- Decision rate stagnation ---\\n    const double decision_rate = AVERAGE(decision_rate);\\n\\n    // Restart if glue heuristic triggers AND decision rate has dropped\\n    // (i.e., progress per conflict is low compared to glue baseline)\\n    if (fast >= limit && decision_rate < 1.2 * slow)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // ========== Stable mode ==========\\n  // Try reluctant (Luby) trigger first.\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware early restart:\\n  if (solver->mab) {\\n    // Defensive: Only trigger if we have at least some conflicts to avoid div-by-zero.\\n    if (solver->mab_conflicts > 0) {\\n      // Progress per conflict since last restart.\\n      const double progress = solver->mab_decisions / (double) solver->mab_conflicts;\\n\\n      // Find highest cumulative reward (avoid zero for log2).\\n      double best_reward = solver->mab_reward[0];\\n      if (solver->mab_reward[1] > best_reward)\\n        best_reward = solver->mab_reward[1];\\n\\n      // Use log2 as in standard bandit normalization, but avoid log2(0).\\n      const double safe_best = best_reward > 1e-6 ? best_reward : 1e-6;\\n      const double reward_threshold = 0.8 * safe_best;\\n\\n      // Restart if progress drops below 80% of best recent reward.\\n      if (progress < reward_threshold)\\n        return true;\\n    }\\n  }\\n\\n  // Otherwise, do not restart yet.\\n  return false;\\n}\\n",
    "par2_preferred": 186.64529999999996,
    "par2_rejected": 204.10829999999996
  },
  {
    "algorithm_description": "Name: Glue+MAB Adaptive Restart\n\nAlgorithm: 1. If solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n\n2. If solver->stable == false (focused mode):\n   a. Compute margin = GET_OPTION(restartmargin).\n   b. Trigger restart if:\n      - CONFLICTS >= solver->limits.restart.conflicts\n      - AND AVERAGE(fast_glue) >= (1.0 + margin/100.0) * AVERAGE(slow_glue)\n      - AND AVERAGE(decision_rate) < 1.2 * AVERAGE(slow_glue) // Only if decision rate is dropping, i.e. search is stagnating\n   c. Return true if all above are satisfied; else false.\n\n3. If solver->stable == true (stable mode):\n   a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n   b. If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   c. // MAB-aware fast-path: If solver->mab is enabled and solver->mab_decisions/conflicts < (0.8 * max(solver->mab_reward[0], solver->mab_reward[1])), return true.\n      - This triggers an earlier restart if current progress per conflict drops below 80% of best recent MAB reward (using observed log2(decisions)/log2(conflicts)), indicating search inefficiency.\n   d. Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: enough conflicts for next restart window?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode: Glue+Decision-rate adaptive restart ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast < limit)\\n      return false;\\n\\n    // Stagnation: compare decision rate to glue baseline\\n    const double rate = AVERAGE(decision_rate);\\n    if (rate < 1.2 * slow)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode: Reluctant Luby, with MAB-early-exit if enabled ---\\n  // Only allow restart if we're at or past the next restart conflict limit\\n  // (already checked above).\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: Early restart if search is clearly underperforming\\n  if (solver->mab) {\\n    // Compute average reward for VSIDS/CHB arms (protection against div0)\\n    double max_reward = 0.0;\\n    if (solver->mab_select[0])\\n      max_reward = solver->mab_reward[0] / solver->mab_select[0];\\n    if (solver->mab_select[1]) {\\n      double chb_avg = solver->mab_reward[1] / solver->mab_select[1];\\n      if (chb_avg > max_reward)\\n        max_reward = chb_avg;\\n    }\\n    // Only trigger if we have at least some reward history\\n    if (max_reward > 0.0 && solver->mab_conflicts > 0) {\\n      double mab_decisions_per_conflict = solver->mab_decisions / solver->mab_conflicts;\\n      if (mab_decisions_per_conflict < 0.8 * max_reward)\\n        return true;\\n    }\\n  }\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. Global guards: restarts enabled, at decision level, and enough conflicts\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // 2. Focused mode: glue ratio + margin + decision rate stagnation\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const int margin = GET_OPTION(restartmargin);\\n    const double glue_limit = (1.0 + ((double)margin / 100.0)) * slow;\\n\\n    const double decision_rate = AVERAGE(decision_rate);\\n    // Only restart if search is stagnating: decision rate below 1.2 * slow glue\\n    const double stagnation_limit = 1.2 * slow;\\n\\n    if (fast >= glue_limit && decision_rate < stagnation_limit)\\n      return true;\\n    return false;\\n  }\\n\\n  // 3. Stable mode (Luby/reluctant): main trigger and MAB-aware shortcut\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware early restart: if enabled and progress drops\\n  if (solver->mab && solver->mab_conflicts > 0) {\\n    // Compute decisions per conflict in this phase\\n    const double dec_per_conf =\\n      (double) solver->mab_decisions / (double) solver->mab_conflicts;\\n\\n    // Use best cumulative reward as baseline (avoid div by zero)\\n    double mab_best = solver->mab_reward[0];\\n    if (solver->mab_reward[1] > mab_best)\\n      mab_best = solver->mab_reward[1];\\n\\n    if (mab_best > 0.0) {\\n      // Early restart if progress is < 80% of best observed reward\\n      if (dec_per_conf < 0.8 * mab_best)\\n        return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 186.64529999999996,
    "par2_rejected": 205.2591
  },
  {
    "algorithm_description": "Name: Glue+MAB Adaptive Restart\n\nAlgorithm: 1. If solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n\n2. If solver->stable == false (focused mode):\n   a. Compute margin = GET_OPTION(restartmargin).\n   b. Trigger restart if:\n      - CONFLICTS >= solver->limits.restart.conflicts\n      - AND AVERAGE(fast_glue) >= (1.0 + margin/100.0) * AVERAGE(slow_glue)\n      - AND AVERAGE(decision_rate) < 1.2 * AVERAGE(slow_glue) // Only if decision rate is dropping, i.e. search is stagnating\n   c. Return true if all above are satisfied; else false.\n\n3. If solver->stable == true (stable mode):\n   a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n   b. If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   c. // MAB-aware fast-path: If solver->mab is enabled and solver->mab_decisions/conflicts < (0.8 * max(solver->mab_reward[0], solver->mab_reward[1])), return true.\n      - This triggers an earlier restart if current progress per conflict drops below 80% of best recent MAB reward (using observed log2(decisions)/log2(conflicts)), indicating search inefficiency.\n   d. Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: enough conflicts for next restart window?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode: Glue+Decision-rate adaptive restart ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast < limit)\\n      return false;\\n\\n    // Stagnation: compare decision rate to glue baseline\\n    const double rate = AVERAGE(decision_rate);\\n    if (rate < 1.2 * slow)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode: Reluctant Luby, with MAB-early-exit if enabled ---\\n  // Only allow restart if we're at or past the next restart conflict limit\\n  // (already checked above).\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: Early restart if search is clearly underperforming\\n  if (solver->mab) {\\n    // Compute average reward for VSIDS/CHB arms (protection against div0)\\n    double max_reward = 0.0;\\n    if (solver->mab_select[0])\\n      max_reward = solver->mab_reward[0] / solver->mab_select[0];\\n    if (solver->mab_select[1]) {\\n      double chb_avg = solver->mab_reward[1] / solver->mab_select[1];\\n      if (chb_avg > max_reward)\\n        max_reward = chb_avg;\\n    }\\n    // Only trigger if we have at least some reward history\\n    if (max_reward > 0.0 && solver->mab_conflicts > 0) {\\n      double mab_decisions_per_conflict = solver->mab_decisions / solver->mab_conflicts;\\n      if (mab_decisions_per_conflict < 0.8 * max_reward)\\n        return true;\\n    }\\n  }\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: Restart disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: At root level, cannot restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: Not yet reached restart conflict limit\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Focused mode: glue-based + stagnation-aware restart\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double glue_limit = margin * slow;\\n    const double drate = AVERAGE(decision_rate);\\n\\n    // Only restart if: glue is bad AND search is stagnating (decision rate dropping)\\n    if (fast >= glue_limit && drate < 1.2 * slow)\\n      return true;\\n    return false;\\n  }\\n\\n  // Stable mode: Reluctant/Luby-based, plus early MAB-aware trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: if enabled, trigger if current progress per conflict is much lower than best reward\\n  if (solver->mab) {\\n    // Compute current progress per conflict since last restart\\n    // Avoid division by zero\\n    if (solver->mab_conflicts > 0) {\\n      double progress = solver->mab_decisions / (double) solver->mab_conflicts;\\n      // Find best (max) current reward\\n      double best_reward = solver->mab_reward[0];\\n      if (solver->mab_reward[1] > best_reward)\\n        best_reward = solver->mab_reward[1];\\n      // If best_reward is positive (avoid false triggers)\\n      if (best_reward > 0.0 && progress < 0.8 * best_reward)\\n        return true;\\n    }\\n  }\\n\\n  // Otherwise, do not trigger restart yet\\n  return false;\\n}\\n",
    "par2_preferred": 186.64529999999996,
    "par2_rejected": 205.79069999999996
  },
  {
    "algorithm_description": "Name: Glue+MAB Adaptive Restart\n\nAlgorithm: 1. If solver->unassigned == 0 OR solver->level == 0 OR !GET_OPTION(restart), return false.\n\n2. If solver->stable == false (focused mode):\n   a. Compute margin = GET_OPTION(restartmargin).\n   b. Trigger restart if:\n      - CONFLICTS >= solver->limits.restart.conflicts\n      - AND AVERAGE(fast_glue) >= (1.0 + margin/100.0) * AVERAGE(slow_glue)\n      - AND AVERAGE(decision_rate) < 1.2 * AVERAGE(slow_glue) // Only if decision rate is dropping, i.e. search is stagnating\n   c. Return true if all above are satisfied; else false.\n\n3. If solver->stable == true (stable mode):\n   a. If CONFLICTS < solver->limits.restart.conflicts, return false.\n   b. If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n   c. // MAB-aware fast-path: If solver->mab is enabled and solver->mab_decisions/conflicts < (0.8 * max(solver->mab_reward[0], solver->mab_reward[1])), return true.\n      - This triggers an earlier restart if current progress per conflict drops below 80% of best recent MAB reward (using observed log2(decisions)/log2(conflicts)), indicating search inefficiency.\n   d. Else, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: enough conflicts for next restart window?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused mode: Glue+Decision-rate adaptive restart ---\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast < limit)\\n      return false;\\n\\n    // Stagnation: compare decision rate to glue baseline\\n    const double rate = AVERAGE(decision_rate);\\n    if (rate < 1.2 * slow)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // --- Stable mode: Reluctant Luby, with MAB-early-exit if enabled ---\\n  // Only allow restart if we're at or past the next restart conflict limit\\n  // (already checked above).\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: Early restart if search is clearly underperforming\\n  if (solver->mab) {\\n    // Compute average reward for VSIDS/CHB arms (protection against div0)\\n    double max_reward = 0.0;\\n    if (solver->mab_select[0])\\n      max_reward = solver->mab_reward[0] / solver->mab_select[0];\\n    if (solver->mab_select[1]) {\\n      double chb_avg = solver->mab_reward[1] / solver->mab_select[1];\\n      if (chb_avg > max_reward)\\n        max_reward = chb_avg;\\n    }\\n    // Only trigger if we have at least some reward history\\n    if (max_reward > 0.0 && solver->mab_conflicts > 0) {\\n      double mab_decisions_per_conflict = solver->mab_decisions / solver->mab_conflicts;\\n      if (mab_decisions_per_conflict < 0.8 * max_reward)\\n        return true;\\n    }\\n  }\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Disable restarts globally or at root level\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Not enough conflicts for next restart threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Focused Mode: Adaptive glue + stagnation check ---\\n  if (!solver->stable) {\\n    // Glue-based trigger with margin\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = GET_OPTION(restartmargin);\\n    const double threshold = (1.0 + margin / 100.0) * slow;\\n\\n    // Decision rate stagnation: only trigger if search is not making enough decisions per conflict\\n    const double decision_rate = AVERAGE(decision_rate);\\n    const double stagnate_limit = 1.2 * slow;\\n\\n    if (fast >= threshold && decision_rate < stagnate_limit)\\n      return true;\\n    else\\n      return false;\\n  }\\n\\n  // --- Stable Mode: Luby/reluctant + MAB-aware early trigger ---\\n  // Luby/reluctant\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware: allow early restart if enabled and current progress is poor\\n  if (solver->mab) {\\n    // Avoid divide by zero\\n    if (solver->mab_conflicts > 0) {\\n      const double current_progress = solver->mab_decisions / (double) solver->mab_conflicts;\\n      // Defensive: take max of observed rewards, but only if at least one is nonzero\\n      double best_reward = solver->mab_reward[0];\\n      if (solver->mab_reward[1] > best_reward)\\n        best_reward = solver->mab_reward[1];\\n      if (best_reward > 0.0) {\\n        // Trigger if progress per conflict is less than 80% of best recent MAB reward\\n        if (current_progress < 0.8 * best_reward)\\n          return true;\\n      }\\n    }\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 186.64529999999996,
    "par2_rejected": 207.30610000000001
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Trigger\n\nAlgorithm: First, check required guards: restarts enabled, unassigned > 0, level > 0. \n\nIn focused mode (solver->stable == false):\n- Compute the glue margin multiplier: margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n- Restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts)\n  AND (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n  AND (AVERAGE(decision_rate) < 0.95 * AVERAGE(slow_glue)  // low progress per conflict, for tie-break)\n\nIn stable mode (solver->stable == true):\n- If MAB is enabled (solver->mab):\n  * Monitor current heuristic's MAB reward since last restart: reward = solver->mab_reward[solver->heuristic].\n  * Compute mean reward across both heuristics: mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]).\n  * If kissat_reluctant_triggered(&solver->reluctant) is true (Luby step), restart immediately.\n  * Else, if (reward < 0.85 * mean_reward) AND (CONFLICTS >= solver->limits.restart.conflicts), restart early (reward underperformance).\n- If MAB is not enabled, use baseline: restart if (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n\nReturn true (restart) if any above mode's condition is satisfied; else false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: zero decision level\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n    const double limit = margin * slow;\\n    // Tie-break: also ensure progress is not high\\n    const double decision_rate = AVERAGE(decision_rate);\\n\\n    if (fast >= limit) {\\n      if (decision_rate < 0.95 * slow)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // Stable mode\\n  if (solver->mab) {\\n    // MAB-enabled: both Luby and underperformance triggers\\n    const bool luby = kissat_reluctant_triggered(&solver->reluctant);\\n    if (luby)\\n      return true;\\n\\n    // Only restart early if enough conflicts since last restart\\n    if (CONFLICTS >= solver->limits.restart.conflicts) {\\n      const unsigned h = solver->heuristic;\\n      const double reward = solver->mab_reward[h];\\n      const double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n      if (reward < 0.85 * mean_reward)\\n        return true;\\n    }\\n    return false;\\n  } else {\\n    // Baseline: only restart at luby if enough conflicts\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Stable mode (phase saving, MAB possible)\\n  if (solver->stable) {\\n    // MAB-enabled adaptive restart logic\\n    if (solver->mab) {\\n      // Reluctant Luby trigger: always supersedes\\n      if (kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n\\n      // MAB reward-based early restart\\n      if (CONFLICTS >= solver->limits.restart.conflicts) {\\n        unsigned h = solver->heuristic;\\n        double reward = solver->mab_reward[h];\\n        double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n        // If current heuristic is underperforming significantly, restart early\\n        if (reward < 0.85 * mean_reward)\\n          return true;\\n      }\\n      return false;\\n    } else {\\n      // No MAB: classic reluctant restart after threshold\\n      if (CONFLICTS >= solver->limits.restart.conflicts &&\\n          kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      return false;\\n    }\\n  }\\n\\n  // Focused mode (glue-margined, decision-rate tie-break)\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (fast >= limit) {\\n    // Tie-break: is decision rate poor? (low progress per conflict)\\n    const double drate = AVERAGE(decision_rate);\\n    if (drate < 0.95 * slow)\\n      return true;\\n    // If not, still allow restart for high glue (classic trigger)\\n    return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 239.27249999999995,
    "par2_rejected": 244.85139999999998
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Trigger\n\nAlgorithm: First, check required guards: restarts enabled, unassigned > 0, level > 0. \n\nIn focused mode (solver->stable == false):\n- Compute the glue margin multiplier: margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n- Restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts)\n  AND (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n  AND (AVERAGE(decision_rate) < 0.95 * AVERAGE(slow_glue)  // low progress per conflict, for tie-break)\n\nIn stable mode (solver->stable == true):\n- If MAB is enabled (solver->mab):\n  * Monitor current heuristic's MAB reward since last restart: reward = solver->mab_reward[solver->heuristic].\n  * Compute mean reward across both heuristics: mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]).\n  * If kissat_reluctant_triggered(&solver->reluctant) is true (Luby step), restart immediately.\n  * Else, if (reward < 0.85 * mean_reward) AND (CONFLICTS >= solver->limits.restart.conflicts), restart early (reward underperformance).\n- If MAB is not enabled, use baseline: restart if (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n\nReturn true (restart) if any above mode's condition is satisfied; else false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: zero decision level\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n    const double limit = margin * slow;\\n    // Tie-break: also ensure progress is not high\\n    const double decision_rate = AVERAGE(decision_rate);\\n\\n    if (fast >= limit) {\\n      if (decision_rate < 0.95 * slow)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // Stable mode\\n  if (solver->mab) {\\n    // MAB-enabled: both Luby and underperformance triggers\\n    const bool luby = kissat_reluctant_triggered(&solver->reluctant);\\n    if (luby)\\n      return true;\\n\\n    // Only restart early if enough conflicts since last restart\\n    if (CONFLICTS >= solver->limits.restart.conflicts) {\\n      const unsigned h = solver->heuristic;\\n      const double reward = solver->mab_reward[h];\\n      const double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n      if (reward < 0.85 * mean_reward)\\n        return true;\\n    }\\n    return false;\\n  } else {\\n    // Baseline: only restart at luby if enough conflicts\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts must be enabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: no restart if at root level\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: glue margin and decision rate\\n  if (!solver->stable) {\\n    // Only trigger if conflict threshold reached\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    const double limit = margin * slow;\\n\\n    // Tie-break: low decision rate per conflict means little progress\\n    const double dec_rate = AVERAGE(decision_rate);\\n\\n    if (fast >= limit) {\\n      // If progress is ALSO low, force restart even if glue is ambiguous\\n      if (dec_rate < 0.95 * slow)\\n        return true;\\n      // Otherwise, restart if glue is bad\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  // Stable mode\\n  if (solver->mab) {\\n    // MAB is enabled\\n    double reward = solver->mab_reward[solver->heuristic];\\n    double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n\\n    // Always honor reluctant (Luby) trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // Early restart if current heuristic is underperforming (reward < 85% mean)\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        reward < 0.85 * mean_reward)\\n      return true;\\n\\n    return false;\\n  } else {\\n    // MAB not enabled: classic reluctant trigger, after conflict threshold\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 239.27249999999995,
    "par2_rejected": 244.85649999999995
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Trigger\n\nAlgorithm: First, check required guards: restarts enabled, unassigned > 0, level > 0. \n\nIn focused mode (solver->stable == false):\n- Compute the glue margin multiplier: margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n- Restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts)\n  AND (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n  AND (AVERAGE(decision_rate) < 0.95 * AVERAGE(slow_glue)  // low progress per conflict, for tie-break)\n\nIn stable mode (solver->stable == true):\n- If MAB is enabled (solver->mab):\n  * Monitor current heuristic's MAB reward since last restart: reward = solver->mab_reward[solver->heuristic].\n  * Compute mean reward across both heuristics: mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]).\n  * If kissat_reluctant_triggered(&solver->reluctant) is true (Luby step), restart immediately.\n  * Else, if (reward < 0.85 * mean_reward) AND (CONFLICTS >= solver->limits.restart.conflicts), restart early (reward underperformance).\n- If MAB is not enabled, use baseline: restart if (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n\nReturn true (restart) if any above mode's condition is satisfied; else false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: zero decision level\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n    const double limit = margin * slow;\\n    // Tie-break: also ensure progress is not high\\n    const double decision_rate = AVERAGE(decision_rate);\\n\\n    if (fast >= limit) {\\n      if (decision_rate < 0.95 * slow)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // Stable mode\\n  if (solver->mab) {\\n    // MAB-enabled: both Luby and underperformance triggers\\n    const bool luby = kissat_reluctant_triggered(&solver->reluctant);\\n    if (luby)\\n      return true;\\n\\n    // Only restart early if enough conflicts since last restart\\n    if (CONFLICTS >= solver->limits.restart.conflicts) {\\n      const unsigned h = solver->heuristic;\\n      const double reward = solver->mab_reward[h];\\n      const double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n      if (reward < 0.85 * mean_reward)\\n        return true;\\n    }\\n    return false;\\n  } else {\\n    // Baseline: only restart at luby if enough conflicts\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guards: restarts enabled, at decision level, not before threshold\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused: adaptive glue+rate trigger\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n    const double glue_limit = margin * slow;\\n    const double decision_rate = AVERAGE(decision_rate);\\n\\n    // Standard glue trigger\\n    if (fast >= glue_limit) {\\n      // Tie-break: only restart if also \\\"low progress\\\"\\n      if (decision_rate < 0.95 * slow)\\n        return true;\\n      // If not low progress, only restart if much worse glue\\n      if (fast >= glue_limit * 1.20)\\n        return true;\\n      // Otherwise, keep searching\\n      return false;\\n    }\\n    return false;\\n  }\\n\\n  // Stable: MAB-adaptive or reluctant/Luby\\n  if (solver->mab) {\\n    const double reward = solver->mab_reward[solver->heuristic];\\n    const double mean_reward =\\n      0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n\\n    // Luby/reluctant always triggers\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // Early restart if underperforming (but only after conflict threshold)\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        reward < 0.85 * mean_reward)\\n      return true;\\n\\n    return false;\\n  } else {\\n    // Baseline: stable = Luby/reluctant after threshold\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 239.27249999999995,
    "par2_rejected": 244.9578
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Trigger\n\nAlgorithm: First, check required guards: restarts enabled, unassigned > 0, level > 0. \n\nIn focused mode (solver->stable == false):\n- Compute the glue margin multiplier: margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n- Restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts)\n  AND (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n  AND (AVERAGE(decision_rate) < 0.95 * AVERAGE(slow_glue)  // low progress per conflict, for tie-break)\n\nIn stable mode (solver->stable == true):\n- If MAB is enabled (solver->mab):\n  * Monitor current heuristic's MAB reward since last restart: reward = solver->mab_reward[solver->heuristic].\n  * Compute mean reward across both heuristics: mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]).\n  * If kissat_reluctant_triggered(&solver->reluctant) is true (Luby step), restart immediately.\n  * Else, if (reward < 0.85 * mean_reward) AND (CONFLICTS >= solver->limits.restart.conflicts), restart early (reward underperformance).\n- If MAB is not enabled, use baseline: restart if (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n\nReturn true (restart) if any above mode's condition is satisfied; else false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: zero decision level\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n    const double limit = margin * slow;\\n    // Tie-break: also ensure progress is not high\\n    const double decision_rate = AVERAGE(decision_rate);\\n\\n    if (fast >= limit) {\\n      if (decision_rate < 0.95 * slow)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // Stable mode\\n  if (solver->mab) {\\n    // MAB-enabled: both Luby and underperformance triggers\\n    const bool luby = kissat_reluctant_triggered(&solver->reluctant);\\n    if (luby)\\n      return true;\\n\\n    // Only restart early if enough conflicts since last restart\\n    if (CONFLICTS >= solver->limits.restart.conflicts) {\\n      const unsigned h = solver->heuristic;\\n      const double reward = solver->mab_reward[h];\\n      const double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n      if (reward < 0.85 * mean_reward)\\n        return true;\\n    }\\n    return false;\\n  } else {\\n    // Baseline: only restart at luby if enough conflicts\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (solver->stable) {\\n    // Stable mode\\n    if (solver->mab) {\\n      // MAB is enabled\\n      double reward = solver->mab_reward[solver->heuristic];\\n      double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n      bool reluctant = kissat_reluctant_triggered(&solver->reluctant);\\n\\n      if (reluctant)\\n        return true;\\n\\n      if (CONFLICTS >= solver->limits.restart.conflicts &&\\n          reward < 0.85 * mean_reward)\\n        return true;\\n\\n      return false;\\n    } else {\\n      // MAB not enabled: baseline reluctant + conflict threshold\\n      if (CONFLICTS >= solver->limits.restart.conflicts &&\\n          kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      return false;\\n    }\\n  } else {\\n    // Focused mode\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n    const double limit = margin * slow;\\n    const double dec_rate = AVERAGE(decision_rate);\\n\\n    if (fast >= limit) {\\n      // Tie-break: also check for poor decision progress\\n      if (dec_rate < 0.95 * slow)\\n        return true;\\n      // Otherwise, glue signal alone is enough\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 239.27249999999995,
    "par2_rejected": 247.6183
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Trigger\n\nAlgorithm: First, check required guards: restarts enabled, unassigned > 0, level > 0. \n\nIn focused mode (solver->stable == false):\n- Compute the glue margin multiplier: margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n- Restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts)\n  AND (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n  AND (AVERAGE(decision_rate) < 0.95 * AVERAGE(slow_glue)  // low progress per conflict, for tie-break)\n\nIn stable mode (solver->stable == true):\n- If MAB is enabled (solver->mab):\n  * Monitor current heuristic's MAB reward since last restart: reward = solver->mab_reward[solver->heuristic].\n  * Compute mean reward across both heuristics: mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]).\n  * If kissat_reluctant_triggered(&solver->reluctant) is true (Luby step), restart immediately.\n  * Else, if (reward < 0.85 * mean_reward) AND (CONFLICTS >= solver->limits.restart.conflicts), restart early (reward underperformance).\n- If MAB is not enabled, use baseline: restart if (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n\nReturn true (restart) if any above mode's condition is satisfied; else false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: zero decision level\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n    const double limit = margin * slow;\\n    // Tie-break: also ensure progress is not high\\n    const double decision_rate = AVERAGE(decision_rate);\\n\\n    if (fast >= limit) {\\n      if (decision_rate < 0.95 * slow)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // Stable mode\\n  if (solver->mab) {\\n    // MAB-enabled: both Luby and underperformance triggers\\n    const bool luby = kissat_reluctant_triggered(&solver->reluctant);\\n    if (luby)\\n      return true;\\n\\n    // Only restart early if enough conflicts since last restart\\n    if (CONFLICTS >= solver->limits.restart.conflicts) {\\n      const unsigned h = solver->heuristic;\\n      const double reward = solver->mab_reward[h];\\n      const double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n      if (reward < 0.85 * mean_reward)\\n        return true;\\n    }\\n    return false;\\n  } else {\\n    // Baseline: only restart at luby if enough conflicts\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Fast path: stable or focused, always respect global conflict limit as minimum\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Focused mode: glue-based with margin, tie-break on poor decision rate\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n    const double limit = margin * slow;\\n    const double dec_rate = AVERAGE(decision_rate);\\n    // Main trigger: fast glue exceeds (margin * slow)\\n    if (fast >= limit) {\\n      // Tie-break: also check for poor decision rate (progress stalled)\\n      if (dec_rate < 0.95 * slow)\\n        return true;\\n      // Even if decision rate is not poor, if glue is clearly above threshold, restart\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  // Stable mode\\n  if (solver->mab) {\\n    // MAB active: reward-based adaptive early trigger\\n    double reward = solver->mab_reward[solver->heuristic];\\n    double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n    // Always allow Luby/reluctant trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    // Early restart if current heuristic is performing poorly (underperforms by 15%+)\\n    if (reward < 0.85 * mean_reward)\\n      return true;\\n    return false;\\n  } else {\\n    // Baseline: reluctant trigger at/after conflict limit\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 239.27249999999995,
    "par2_rejected": 247.62379999999996
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Trigger\n\nAlgorithm: First, check required guards: restarts enabled, unassigned > 0, level > 0. \n\nIn focused mode (solver->stable == false):\n- Compute the glue margin multiplier: margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n- Restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts)\n  AND (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n  AND (AVERAGE(decision_rate) < 0.95 * AVERAGE(slow_glue)  // low progress per conflict, for tie-break)\n\nIn stable mode (solver->stable == true):\n- If MAB is enabled (solver->mab):\n  * Monitor current heuristic's MAB reward since last restart: reward = solver->mab_reward[solver->heuristic].\n  * Compute mean reward across both heuristics: mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]).\n  * If kissat_reluctant_triggered(&solver->reluctant) is true (Luby step), restart immediately.\n  * Else, if (reward < 0.85 * mean_reward) AND (CONFLICTS >= solver->limits.restart.conflicts), restart early (reward underperformance).\n- If MAB is not enabled, use baseline: restart if (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n\nReturn true (restart) if any above mode's condition is satisfied; else false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Stable mode: use MAB-aware or reluctant trigger\\n  if (solver->stable) {\\n    if (solver->mab) {\\n      // MAB-enabled: adaptive reward-based early restart\\n      const double reward = solver->mab_reward[solver->heuristic];\\n      const double mean_reward =\\n        0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n      if (kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      if (reward < 0.85 * mean_reward &&\\n          CONFLICTS >= solver->limits.restart.conflicts)\\n        return true;\\n      return false;\\n    } else {\\n      // Baseline reluctant trigger for non-MAB\\n      if (CONFLICTS >= solver->limits.restart.conflicts &&\\n          kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      return false;\\n    }\\n  }\\n\\n  // Focused mode: adaptive glue and decision-rate trigger\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n  const double glue_limit = margin * slow;\\n  const double decision_rate = AVERAGE(decision_rate);\\n\\n  if (fast >= glue_limit) {\\n    // Tie-break: only restart if decision rate is also low (stagnation)\\n    if (decision_rate < 0.95 * slow)\\n      return true;\\n    else\\n      return false;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Stable mode (phase saving, MAB possible)\\n  if (solver->stable) {\\n    // MAB-enabled adaptive restart logic\\n    if (solver->mab) {\\n      // Reluctant Luby trigger: always supersedes\\n      if (kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n\\n      // MAB reward-based early restart\\n      if (CONFLICTS >= solver->limits.restart.conflicts) {\\n        unsigned h = solver->heuristic;\\n        double reward = solver->mab_reward[h];\\n        double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n        // If current heuristic is underperforming significantly, restart early\\n        if (reward < 0.85 * mean_reward)\\n          return true;\\n      }\\n      return false;\\n    } else {\\n      // No MAB: classic reluctant restart after threshold\\n      if (CONFLICTS >= solver->limits.restart.conflicts &&\\n          kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      return false;\\n    }\\n  }\\n\\n  // Focused mode (glue-margined, decision-rate tie-break)\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (fast >= limit) {\\n    // Tie-break: is decision rate poor? (low progress per conflict)\\n    const double drate = AVERAGE(decision_rate);\\n    if (drate < 0.95 * slow)\\n      return true;\\n    // If not, still allow restart for high glue (classic trigger)\\n    return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 239.28329999999997,
    "par2_rejected": 244.85139999999998
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Trigger\n\nAlgorithm: First, check required guards: restarts enabled, unassigned > 0, level > 0. \n\nIn focused mode (solver->stable == false):\n- Compute the glue margin multiplier: margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n- Restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts)\n  AND (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n  AND (AVERAGE(decision_rate) < 0.95 * AVERAGE(slow_glue)  // low progress per conflict, for tie-break)\n\nIn stable mode (solver->stable == true):\n- If MAB is enabled (solver->mab):\n  * Monitor current heuristic's MAB reward since last restart: reward = solver->mab_reward[solver->heuristic].\n  * Compute mean reward across both heuristics: mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]).\n  * If kissat_reluctant_triggered(&solver->reluctant) is true (Luby step), restart immediately.\n  * Else, if (reward < 0.85 * mean_reward) AND (CONFLICTS >= solver->limits.restart.conflicts), restart early (reward underperformance).\n- If MAB is not enabled, use baseline: restart if (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n\nReturn true (restart) if any above mode's condition is satisfied; else false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Stable mode: use MAB-aware or reluctant trigger\\n  if (solver->stable) {\\n    if (solver->mab) {\\n      // MAB-enabled: adaptive reward-based early restart\\n      const double reward = solver->mab_reward[solver->heuristic];\\n      const double mean_reward =\\n        0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n      if (kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      if (reward < 0.85 * mean_reward &&\\n          CONFLICTS >= solver->limits.restart.conflicts)\\n        return true;\\n      return false;\\n    } else {\\n      // Baseline reluctant trigger for non-MAB\\n      if (CONFLICTS >= solver->limits.restart.conflicts &&\\n          kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      return false;\\n    }\\n  }\\n\\n  // Focused mode: adaptive glue and decision-rate trigger\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n  const double glue_limit = margin * slow;\\n  const double decision_rate = AVERAGE(decision_rate);\\n\\n  if (fast >= glue_limit) {\\n    // Tie-break: only restart if decision rate is also low (stagnation)\\n    if (decision_rate < 0.95 * slow)\\n      return true;\\n    else\\n      return false;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts must be enabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: no restart if at root level\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: glue margin and decision rate\\n  if (!solver->stable) {\\n    // Only trigger if conflict threshold reached\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    const double limit = margin * slow;\\n\\n    // Tie-break: low decision rate per conflict means little progress\\n    const double dec_rate = AVERAGE(decision_rate);\\n\\n    if (fast >= limit) {\\n      // If progress is ALSO low, force restart even if glue is ambiguous\\n      if (dec_rate < 0.95 * slow)\\n        return true;\\n      // Otherwise, restart if glue is bad\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  // Stable mode\\n  if (solver->mab) {\\n    // MAB is enabled\\n    double reward = solver->mab_reward[solver->heuristic];\\n    double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n\\n    // Always honor reluctant (Luby) trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // Early restart if current heuristic is underperforming (reward < 85% mean)\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        reward < 0.85 * mean_reward)\\n      return true;\\n\\n    return false;\\n  } else {\\n    // MAB not enabled: classic reluctant trigger, after conflict threshold\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 239.28329999999997,
    "par2_rejected": 244.85649999999995
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Trigger\n\nAlgorithm: First, check required guards: restarts enabled, unassigned > 0, level > 0. \n\nIn focused mode (solver->stable == false):\n- Compute the glue margin multiplier: margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n- Restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts)\n  AND (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n  AND (AVERAGE(decision_rate) < 0.95 * AVERAGE(slow_glue)  // low progress per conflict, for tie-break)\n\nIn stable mode (solver->stable == true):\n- If MAB is enabled (solver->mab):\n  * Monitor current heuristic's MAB reward since last restart: reward = solver->mab_reward[solver->heuristic].\n  * Compute mean reward across both heuristics: mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]).\n  * If kissat_reluctant_triggered(&solver->reluctant) is true (Luby step), restart immediately.\n  * Else, if (reward < 0.85 * mean_reward) AND (CONFLICTS >= solver->limits.restart.conflicts), restart early (reward underperformance).\n- If MAB is not enabled, use baseline: restart if (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n\nReturn true (restart) if any above mode's condition is satisfied; else false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Stable mode: use MAB-aware or reluctant trigger\\n  if (solver->stable) {\\n    if (solver->mab) {\\n      // MAB-enabled: adaptive reward-based early restart\\n      const double reward = solver->mab_reward[solver->heuristic];\\n      const double mean_reward =\\n        0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n      if (kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      if (reward < 0.85 * mean_reward &&\\n          CONFLICTS >= solver->limits.restart.conflicts)\\n        return true;\\n      return false;\\n    } else {\\n      // Baseline reluctant trigger for non-MAB\\n      if (CONFLICTS >= solver->limits.restart.conflicts &&\\n          kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      return false;\\n    }\\n  }\\n\\n  // Focused mode: adaptive glue and decision-rate trigger\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n  const double glue_limit = margin * slow;\\n  const double decision_rate = AVERAGE(decision_rate);\\n\\n  if (fast >= glue_limit) {\\n    // Tie-break: only restart if decision rate is also low (stagnation)\\n    if (decision_rate < 0.95 * slow)\\n      return true;\\n    else\\n      return false;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guards: restarts enabled, at decision level, not before threshold\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused: adaptive glue+rate trigger\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n    const double glue_limit = margin * slow;\\n    const double decision_rate = AVERAGE(decision_rate);\\n\\n    // Standard glue trigger\\n    if (fast >= glue_limit) {\\n      // Tie-break: only restart if also \\\"low progress\\\"\\n      if (decision_rate < 0.95 * slow)\\n        return true;\\n      // If not low progress, only restart if much worse glue\\n      if (fast >= glue_limit * 1.20)\\n        return true;\\n      // Otherwise, keep searching\\n      return false;\\n    }\\n    return false;\\n  }\\n\\n  // Stable: MAB-adaptive or reluctant/Luby\\n  if (solver->mab) {\\n    const double reward = solver->mab_reward[solver->heuristic];\\n    const double mean_reward =\\n      0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n\\n    // Luby/reluctant always triggers\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // Early restart if underperforming (but only after conflict threshold)\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        reward < 0.85 * mean_reward)\\n      return true;\\n\\n    return false;\\n  } else {\\n    // Baseline: stable = Luby/reluctant after threshold\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 239.28329999999997,
    "par2_rejected": 244.9578
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Trigger\n\nAlgorithm: First, check required guards: restarts enabled, unassigned > 0, level > 0. \n\nIn focused mode (solver->stable == false):\n- Compute the glue margin multiplier: margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n- Restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts)\n  AND (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n  AND (AVERAGE(decision_rate) < 0.95 * AVERAGE(slow_glue)  // low progress per conflict, for tie-break)\n\nIn stable mode (solver->stable == true):\n- If MAB is enabled (solver->mab):\n  * Monitor current heuristic's MAB reward since last restart: reward = solver->mab_reward[solver->heuristic].\n  * Compute mean reward across both heuristics: mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]).\n  * If kissat_reluctant_triggered(&solver->reluctant) is true (Luby step), restart immediately.\n  * Else, if (reward < 0.85 * mean_reward) AND (CONFLICTS >= solver->limits.restart.conflicts), restart early (reward underperformance).\n- If MAB is not enabled, use baseline: restart if (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n\nReturn true (restart) if any above mode's condition is satisfied; else false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Stable mode: use MAB-aware or reluctant trigger\\n  if (solver->stable) {\\n    if (solver->mab) {\\n      // MAB-enabled: adaptive reward-based early restart\\n      const double reward = solver->mab_reward[solver->heuristic];\\n      const double mean_reward =\\n        0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n      if (kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      if (reward < 0.85 * mean_reward &&\\n          CONFLICTS >= solver->limits.restart.conflicts)\\n        return true;\\n      return false;\\n    } else {\\n      // Baseline reluctant trigger for non-MAB\\n      if (CONFLICTS >= solver->limits.restart.conflicts &&\\n          kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      return false;\\n    }\\n  }\\n\\n  // Focused mode: adaptive glue and decision-rate trigger\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n  const double glue_limit = margin * slow;\\n  const double decision_rate = AVERAGE(decision_rate);\\n\\n  if (fast >= glue_limit) {\\n    // Tie-break: only restart if decision rate is also low (stagnation)\\n    if (decision_rate < 0.95 * slow)\\n      return true;\\n    else\\n      return false;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (solver->stable) {\\n    // Stable mode\\n    if (solver->mab) {\\n      // MAB is enabled\\n      double reward = solver->mab_reward[solver->heuristic];\\n      double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n      bool reluctant = kissat_reluctant_triggered(&solver->reluctant);\\n\\n      if (reluctant)\\n        return true;\\n\\n      if (CONFLICTS >= solver->limits.restart.conflicts &&\\n          reward < 0.85 * mean_reward)\\n        return true;\\n\\n      return false;\\n    } else {\\n      // MAB not enabled: baseline reluctant + conflict threshold\\n      if (CONFLICTS >= solver->limits.restart.conflicts &&\\n          kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      return false;\\n    }\\n  } else {\\n    // Focused mode\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n    const double limit = margin * slow;\\n    const double dec_rate = AVERAGE(decision_rate);\\n\\n    if (fast >= limit) {\\n      // Tie-break: also check for poor decision progress\\n      if (dec_rate < 0.95 * slow)\\n        return true;\\n      // Otherwise, glue signal alone is enough\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 239.28329999999997,
    "par2_rejected": 247.6183
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Trigger\n\nAlgorithm: First, check required guards: restarts enabled, unassigned > 0, level > 0. \n\nIn focused mode (solver->stable == false):\n- Compute the glue margin multiplier: margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n- Restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts)\n  AND (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n  AND (AVERAGE(decision_rate) < 0.95 * AVERAGE(slow_glue)  // low progress per conflict, for tie-break)\n\nIn stable mode (solver->stable == true):\n- If MAB is enabled (solver->mab):\n  * Monitor current heuristic's MAB reward since last restart: reward = solver->mab_reward[solver->heuristic].\n  * Compute mean reward across both heuristics: mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]).\n  * If kissat_reluctant_triggered(&solver->reluctant) is true (Luby step), restart immediately.\n  * Else, if (reward < 0.85 * mean_reward) AND (CONFLICTS >= solver->limits.restart.conflicts), restart early (reward underperformance).\n- If MAB is not enabled, use baseline: restart if (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n\nReturn true (restart) if any above mode's condition is satisfied; else false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Stable mode: use MAB-aware or reluctant trigger\\n  if (solver->stable) {\\n    if (solver->mab) {\\n      // MAB-enabled: adaptive reward-based early restart\\n      const double reward = solver->mab_reward[solver->heuristic];\\n      const double mean_reward =\\n        0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n      if (kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      if (reward < 0.85 * mean_reward &&\\n          CONFLICTS >= solver->limits.restart.conflicts)\\n        return true;\\n      return false;\\n    } else {\\n      // Baseline reluctant trigger for non-MAB\\n      if (CONFLICTS >= solver->limits.restart.conflicts &&\\n          kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      return false;\\n    }\\n  }\\n\\n  // Focused mode: adaptive glue and decision-rate trigger\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n  const double glue_limit = margin * slow;\\n  const double decision_rate = AVERAGE(decision_rate);\\n\\n  if (fast >= glue_limit) {\\n    // Tie-break: only restart if decision rate is also low (stagnation)\\n    if (decision_rate < 0.95 * slow)\\n      return true;\\n    else\\n      return false;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Fast path: stable or focused, always respect global conflict limit as minimum\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Focused mode: glue-based with margin, tie-break on poor decision rate\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n    const double limit = margin * slow;\\n    const double dec_rate = AVERAGE(decision_rate);\\n    // Main trigger: fast glue exceeds (margin * slow)\\n    if (fast >= limit) {\\n      // Tie-break: also check for poor decision rate (progress stalled)\\n      if (dec_rate < 0.95 * slow)\\n        return true;\\n      // Even if decision rate is not poor, if glue is clearly above threshold, restart\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  // Stable mode\\n  if (solver->mab) {\\n    // MAB active: reward-based adaptive early trigger\\n    double reward = solver->mab_reward[solver->heuristic];\\n    double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n    // Always allow Luby/reluctant trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    // Early restart if current heuristic is performing poorly (underperforms by 15%+)\\n    if (reward < 0.85 * mean_reward)\\n      return true;\\n    return false;\\n  } else {\\n    // Baseline: reluctant trigger at/after conflict limit\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 239.28329999999997,
    "par2_rejected": 247.62379999999996
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Trigger\n\nAlgorithm: First, check required guards: restarts enabled, unassigned > 0, level > 0. \n\nIn focused mode (solver->stable == false):\n- Compute the glue margin multiplier: margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n- Restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts)\n  AND (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n  AND (AVERAGE(decision_rate) < 0.95 * AVERAGE(slow_glue)  // low progress per conflict, for tie-break)\n\nIn stable mode (solver->stable == true):\n- If MAB is enabled (solver->mab):\n  * Monitor current heuristic's MAB reward since last restart: reward = solver->mab_reward[solver->heuristic].\n  * Compute mean reward across both heuristics: mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]).\n  * If kissat_reluctant_triggered(&solver->reluctant) is true (Luby step), restart immediately.\n  * Else, if (reward < 0.85 * mean_reward) AND (CONFLICTS >= solver->limits.restart.conflicts), restart early (reward underperformance).\n- If MAB is not enabled, use baseline: restart if (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n\nReturn true (restart) if any above mode's condition is satisfied; else false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guards: restarts enabled, in search, at non-root level\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (solver->unassigned == 0)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue margin + decision rate tie-break\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + ((double)GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast < limit)\\n      return false;\\n    // Tie-break: if we're not making good progress (decisions/conflict < 0.95*slow_glue)\\n    const double rate = AVERAGE(decision_rate);\\n    if (rate >= 0.95 * slow)\\n      return false;\\n    return true;\\n  } else {\\n    // Stable mode\\n    if (solver->mab) {\\n      // MAB-adaptive trigger\\n      const unsigned h = solver->heuristic;\\n      const double reward = solver->mab_reward[h];\\n      const double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n      if (kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      if ((CONFLICTS >= solver->limits.restart.conflicts) &&\\n          (reward < 0.85 * mean_reward))\\n        return true;\\n      return false;\\n    } else {\\n      // Baseline: Luby + conflict budget\\n      if ((CONFLICTS >= solver->limits.restart.conflicts) &&\\n          kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      return false;\\n    }\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Stable mode (phase saving, MAB possible)\\n  if (solver->stable) {\\n    // MAB-enabled adaptive restart logic\\n    if (solver->mab) {\\n      // Reluctant Luby trigger: always supersedes\\n      if (kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n\\n      // MAB reward-based early restart\\n      if (CONFLICTS >= solver->limits.restart.conflicts) {\\n        unsigned h = solver->heuristic;\\n        double reward = solver->mab_reward[h];\\n        double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n        // If current heuristic is underperforming significantly, restart early\\n        if (reward < 0.85 * mean_reward)\\n          return true;\\n      }\\n      return false;\\n    } else {\\n      // No MAB: classic reluctant restart after threshold\\n      if (CONFLICTS >= solver->limits.restart.conflicts &&\\n          kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      return false;\\n    }\\n  }\\n\\n  // Focused mode (glue-margined, decision-rate tie-break)\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n  const double limit = margin * slow;\\n\\n  if (fast >= limit) {\\n    // Tie-break: is decision rate poor? (low progress per conflict)\\n    const double drate = AVERAGE(decision_rate);\\n    if (drate < 0.95 * slow)\\n      return true;\\n    // If not, still allow restart for high glue (classic trigger)\\n    return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 239.2879,
    "par2_rejected": 244.85139999999998
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Trigger\n\nAlgorithm: First, check required guards: restarts enabled, unassigned > 0, level > 0. \n\nIn focused mode (solver->stable == false):\n- Compute the glue margin multiplier: margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n- Restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts)\n  AND (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n  AND (AVERAGE(decision_rate) < 0.95 * AVERAGE(slow_glue)  // low progress per conflict, for tie-break)\n\nIn stable mode (solver->stable == true):\n- If MAB is enabled (solver->mab):\n  * Monitor current heuristic's MAB reward since last restart: reward = solver->mab_reward[solver->heuristic].\n  * Compute mean reward across both heuristics: mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]).\n  * If kissat_reluctant_triggered(&solver->reluctant) is true (Luby step), restart immediately.\n  * Else, if (reward < 0.85 * mean_reward) AND (CONFLICTS >= solver->limits.restart.conflicts), restart early (reward underperformance).\n- If MAB is not enabled, use baseline: restart if (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n\nReturn true (restart) if any above mode's condition is satisfied; else false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guards: restarts enabled, in search, at non-root level\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (solver->unassigned == 0)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue margin + decision rate tie-break\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + ((double)GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast < limit)\\n      return false;\\n    // Tie-break: if we're not making good progress (decisions/conflict < 0.95*slow_glue)\\n    const double rate = AVERAGE(decision_rate);\\n    if (rate >= 0.95 * slow)\\n      return false;\\n    return true;\\n  } else {\\n    // Stable mode\\n    if (solver->mab) {\\n      // MAB-adaptive trigger\\n      const unsigned h = solver->heuristic;\\n      const double reward = solver->mab_reward[h];\\n      const double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n      if (kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      if ((CONFLICTS >= solver->limits.restart.conflicts) &&\\n          (reward < 0.85 * mean_reward))\\n        return true;\\n      return false;\\n    } else {\\n      // Baseline: Luby + conflict budget\\n      if ((CONFLICTS >= solver->limits.restart.conflicts) &&\\n          kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      return false;\\n    }\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts must be enabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: no restart if at root level\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: glue margin and decision rate\\n  if (!solver->stable) {\\n    // Only trigger if conflict threshold reached\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    const double limit = margin * slow;\\n\\n    // Tie-break: low decision rate per conflict means little progress\\n    const double dec_rate = AVERAGE(decision_rate);\\n\\n    if (fast >= limit) {\\n      // If progress is ALSO low, force restart even if glue is ambiguous\\n      if (dec_rate < 0.95 * slow)\\n        return true;\\n      // Otherwise, restart if glue is bad\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  // Stable mode\\n  if (solver->mab) {\\n    // MAB is enabled\\n    double reward = solver->mab_reward[solver->heuristic];\\n    double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n\\n    // Always honor reluctant (Luby) trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // Early restart if current heuristic is underperforming (reward < 85% mean)\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        reward < 0.85 * mean_reward)\\n      return true;\\n\\n    return false;\\n  } else {\\n    // MAB not enabled: classic reluctant trigger, after conflict threshold\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 239.2879,
    "par2_rejected": 244.85649999999995
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Trigger\n\nAlgorithm: First, check required guards: restarts enabled, unassigned > 0, level > 0. \n\nIn focused mode (solver->stable == false):\n- Compute the glue margin multiplier: margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n- Restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts)\n  AND (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n  AND (AVERAGE(decision_rate) < 0.95 * AVERAGE(slow_glue)  // low progress per conflict, for tie-break)\n\nIn stable mode (solver->stable == true):\n- If MAB is enabled (solver->mab):\n  * Monitor current heuristic's MAB reward since last restart: reward = solver->mab_reward[solver->heuristic].\n  * Compute mean reward across both heuristics: mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]).\n  * If kissat_reluctant_triggered(&solver->reluctant) is true (Luby step), restart immediately.\n  * Else, if (reward < 0.85 * mean_reward) AND (CONFLICTS >= solver->limits.restart.conflicts), restart early (reward underperformance).\n- If MAB is not enabled, use baseline: restart if (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n\nReturn true (restart) if any above mode's condition is satisfied; else false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guards: restarts enabled, in search, at non-root level\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (solver->unassigned == 0)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue margin + decision rate tie-break\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + ((double)GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast < limit)\\n      return false;\\n    // Tie-break: if we're not making good progress (decisions/conflict < 0.95*slow_glue)\\n    const double rate = AVERAGE(decision_rate);\\n    if (rate >= 0.95 * slow)\\n      return false;\\n    return true;\\n  } else {\\n    // Stable mode\\n    if (solver->mab) {\\n      // MAB-adaptive trigger\\n      const unsigned h = solver->heuristic;\\n      const double reward = solver->mab_reward[h];\\n      const double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n      if (kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      if ((CONFLICTS >= solver->limits.restart.conflicts) &&\\n          (reward < 0.85 * mean_reward))\\n        return true;\\n      return false;\\n    } else {\\n      // Baseline: Luby + conflict budget\\n      if ((CONFLICTS >= solver->limits.restart.conflicts) &&\\n          kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      return false;\\n    }\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guards: restarts enabled, at decision level, not before threshold\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused: adaptive glue+rate trigger\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n    const double glue_limit = margin * slow;\\n    const double decision_rate = AVERAGE(decision_rate);\\n\\n    // Standard glue trigger\\n    if (fast >= glue_limit) {\\n      // Tie-break: only restart if also \\\"low progress\\\"\\n      if (decision_rate < 0.95 * slow)\\n        return true;\\n      // If not low progress, only restart if much worse glue\\n      if (fast >= glue_limit * 1.20)\\n        return true;\\n      // Otherwise, keep searching\\n      return false;\\n    }\\n    return false;\\n  }\\n\\n  // Stable: MAB-adaptive or reluctant/Luby\\n  if (solver->mab) {\\n    const double reward = solver->mab_reward[solver->heuristic];\\n    const double mean_reward =\\n      0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n\\n    // Luby/reluctant always triggers\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // Early restart if underperforming (but only after conflict threshold)\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        reward < 0.85 * mean_reward)\\n      return true;\\n\\n    return false;\\n  } else {\\n    // Baseline: stable = Luby/reluctant after threshold\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 239.2879,
    "par2_rejected": 244.9578
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Trigger\n\nAlgorithm: First, check required guards: restarts enabled, unassigned > 0, level > 0. \n\nIn focused mode (solver->stable == false):\n- Compute the glue margin multiplier: margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n- Restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts)\n  AND (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n  AND (AVERAGE(decision_rate) < 0.95 * AVERAGE(slow_glue)  // low progress per conflict, for tie-break)\n\nIn stable mode (solver->stable == true):\n- If MAB is enabled (solver->mab):\n  * Monitor current heuristic's MAB reward since last restart: reward = solver->mab_reward[solver->heuristic].\n  * Compute mean reward across both heuristics: mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]).\n  * If kissat_reluctant_triggered(&solver->reluctant) is true (Luby step), restart immediately.\n  * Else, if (reward < 0.85 * mean_reward) AND (CONFLICTS >= solver->limits.restart.conflicts), restart early (reward underperformance).\n- If MAB is not enabled, use baseline: restart if (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n\nReturn true (restart) if any above mode's condition is satisfied; else false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guards: restarts enabled, in search, at non-root level\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (solver->unassigned == 0)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue margin + decision rate tie-break\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + ((double)GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast < limit)\\n      return false;\\n    // Tie-break: if we're not making good progress (decisions/conflict < 0.95*slow_glue)\\n    const double rate = AVERAGE(decision_rate);\\n    if (rate >= 0.95 * slow)\\n      return false;\\n    return true;\\n  } else {\\n    // Stable mode\\n    if (solver->mab) {\\n      // MAB-adaptive trigger\\n      const unsigned h = solver->heuristic;\\n      const double reward = solver->mab_reward[h];\\n      const double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n      if (kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      if ((CONFLICTS >= solver->limits.restart.conflicts) &&\\n          (reward < 0.85 * mean_reward))\\n        return true;\\n      return false;\\n    } else {\\n      // Baseline: Luby + conflict budget\\n      if ((CONFLICTS >= solver->limits.restart.conflicts) &&\\n          kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      return false;\\n    }\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (solver->stable) {\\n    // Stable mode\\n    if (solver->mab) {\\n      // MAB is enabled\\n      double reward = solver->mab_reward[solver->heuristic];\\n      double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n      bool reluctant = kissat_reluctant_triggered(&solver->reluctant);\\n\\n      if (reluctant)\\n        return true;\\n\\n      if (CONFLICTS >= solver->limits.restart.conflicts &&\\n          reward < 0.85 * mean_reward)\\n        return true;\\n\\n      return false;\\n    } else {\\n      // MAB not enabled: baseline reluctant + conflict threshold\\n      if (CONFLICTS >= solver->limits.restart.conflicts &&\\n          kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      return false;\\n    }\\n  } else {\\n    // Focused mode\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n    const double limit = margin * slow;\\n    const double dec_rate = AVERAGE(decision_rate);\\n\\n    if (fast >= limit) {\\n      // Tie-break: also check for poor decision progress\\n      if (dec_rate < 0.95 * slow)\\n        return true;\\n      // Otherwise, glue signal alone is enough\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 239.2879,
    "par2_rejected": 247.6183
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Trigger\n\nAlgorithm: First, check required guards: restarts enabled, unassigned > 0, level > 0. \n\nIn focused mode (solver->stable == false):\n- Compute the glue margin multiplier: margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n- Restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts)\n  AND (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n  AND (AVERAGE(decision_rate) < 0.95 * AVERAGE(slow_glue)  // low progress per conflict, for tie-break)\n\nIn stable mode (solver->stable == true):\n- If MAB is enabled (solver->mab):\n  * Monitor current heuristic's MAB reward since last restart: reward = solver->mab_reward[solver->heuristic].\n  * Compute mean reward across both heuristics: mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]).\n  * If kissat_reluctant_triggered(&solver->reluctant) is true (Luby step), restart immediately.\n  * Else, if (reward < 0.85 * mean_reward) AND (CONFLICTS >= solver->limits.restart.conflicts), restart early (reward underperformance).\n- If MAB is not enabled, use baseline: restart if (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n\nReturn true (restart) if any above mode's condition is satisfied; else false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guards: restarts enabled, in search, at non-root level\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (solver->unassigned == 0)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue margin + decision rate tie-break\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + ((double)GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    if (fast < limit)\\n      return false;\\n    // Tie-break: if we're not making good progress (decisions/conflict < 0.95*slow_glue)\\n    const double rate = AVERAGE(decision_rate);\\n    if (rate >= 0.95 * slow)\\n      return false;\\n    return true;\\n  } else {\\n    // Stable mode\\n    if (solver->mab) {\\n      // MAB-adaptive trigger\\n      const unsigned h = solver->heuristic;\\n      const double reward = solver->mab_reward[h];\\n      const double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n      if (kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      if ((CONFLICTS >= solver->limits.restart.conflicts) &&\\n          (reward < 0.85 * mean_reward))\\n        return true;\\n      return false;\\n    } else {\\n      // Baseline: Luby + conflict budget\\n      if ((CONFLICTS >= solver->limits.restart.conflicts) &&\\n          kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      return false;\\n    }\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Fast path: stable or focused, always respect global conflict limit as minimum\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Focused mode: glue-based with margin, tie-break on poor decision rate\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n    const double limit = margin * slow;\\n    const double dec_rate = AVERAGE(decision_rate);\\n    // Main trigger: fast glue exceeds (margin * slow)\\n    if (fast >= limit) {\\n      // Tie-break: also check for poor decision rate (progress stalled)\\n      if (dec_rate < 0.95 * slow)\\n        return true;\\n      // Even if decision rate is not poor, if glue is clearly above threshold, restart\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  // Stable mode\\n  if (solver->mab) {\\n    // MAB active: reward-based adaptive early trigger\\n    double reward = solver->mab_reward[solver->heuristic];\\n    double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n    // Always allow Luby/reluctant trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    // Early restart if current heuristic is performing poorly (underperforms by 15%+)\\n    if (reward < 0.85 * mean_reward)\\n      return true;\\n    return false;\\n  } else {\\n    // Baseline: reluctant trigger at/after conflict limit\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 239.2879,
    "par2_rejected": 247.62379999999996
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Trigger\n\nAlgorithm: First, check required guards: restarts enabled, unassigned > 0, level > 0. \n\nIn focused mode (solver->stable == false):\n- Compute the glue margin multiplier: margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n- Restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts)\n  AND (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n  AND (AVERAGE(decision_rate) < 0.95 * AVERAGE(slow_glue)  // low progress per conflict, for tie-break)\n\nIn stable mode (solver->stable == true):\n- If MAB is enabled (solver->mab):\n  * Monitor current heuristic's MAB reward since last restart: reward = solver->mab_reward[solver->heuristic].\n  * Compute mean reward across both heuristics: mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]).\n  * If kissat_reluctant_triggered(&solver->reluctant) is true (Luby step), restart immediately.\n  * Else, if (reward < 0.85 * mean_reward) AND (CONFLICTS >= solver->limits.restart.conflicts), restart early (reward underperformance).\n- If MAB is not enabled, use baseline: restart if (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n\nReturn true (restart) if any above mode's condition is satisfied; else false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts must be enabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n  // Guard: must be at a non-root decision level\\n  if (!solver->level)\\n    return false;\\n  // Guard: only once the conflict limit is reached (for all triggers except MAB-early)\\n  const uint64_t next_conflict = solver->limits.restart.conflicts;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue-based restart with margin and slow decision tie-break\\n    if (CONFLICTS < next_conflict)\\n      return false;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    const double limit = margin * slow;\\n    // Tie-break: only restart if decision-rate is also low (stuck/stagnant)\\n    const double decision_rate = AVERAGE(decision_rate);\\n    // Use slow_glue as a baseline for progress (empirically effective)\\n    if (fast >= limit) {\\n      if (decision_rate < 0.95 * slow)\\n        return true;\\n    }\\n    return false;\\n  } else {\\n    // Stable mode: MAB-aware reward-based trigger, or fallback to reluctant\\n    if (solver->mab) {\\n      // MAB: allow both reluctant (Luby) and underperformance triggers\\n      double reward = solver->mab_reward[solver->heuristic];\\n      double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n      if (kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      // Early restart if our heuristic is underperforming badly\\n      if (reward < 0.85 * mean_reward && CONFLICTS >= next_conflict)\\n        return true;\\n      return false;\\n    } else {\\n      // Baseline: restart only on reluctant (Luby) trigger, if conflict threshold crossed\\n      if (CONFLICTS >= next_conflict && kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      return false;\\n    }\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (solver->stable) {\\n    // Stable mode\\n    if (solver->mab) {\\n      // MAB is enabled\\n      double reward = solver->mab_reward[solver->heuristic];\\n      double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n      bool reluctant = kissat_reluctant_triggered(&solver->reluctant);\\n\\n      if (reluctant)\\n        return true;\\n\\n      if (CONFLICTS >= solver->limits.restart.conflicts &&\\n          reward < 0.85 * mean_reward)\\n        return true;\\n\\n      return false;\\n    } else {\\n      // MAB not enabled: baseline reluctant + conflict threshold\\n      if (CONFLICTS >= solver->limits.restart.conflicts &&\\n          kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      return false;\\n    }\\n  } else {\\n    // Focused mode\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n    const double limit = margin * slow;\\n    const double dec_rate = AVERAGE(decision_rate);\\n\\n    if (fast >= limit) {\\n      // Tie-break: also check for poor decision progress\\n      if (dec_rate < 0.95 * slow)\\n        return true;\\n      // Otherwise, glue signal alone is enough\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 242.0576,
    "par2_rejected": 247.6183
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Trigger\n\nAlgorithm: First, check required guards: restarts enabled, unassigned > 0, level > 0. \n\nIn focused mode (solver->stable == false):\n- Compute the glue margin multiplier: margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n- Restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts)\n  AND (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n  AND (AVERAGE(decision_rate) < 0.95 * AVERAGE(slow_glue)  // low progress per conflict, for tie-break)\n\nIn stable mode (solver->stable == true):\n- If MAB is enabled (solver->mab):\n  * Monitor current heuristic's MAB reward since last restart: reward = solver->mab_reward[solver->heuristic].\n  * Compute mean reward across both heuristics: mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]).\n  * If kissat_reluctant_triggered(&solver->reluctant) is true (Luby step), restart immediately.\n  * Else, if (reward < 0.85 * mean_reward) AND (CONFLICTS >= solver->limits.restart.conflicts), restart early (reward underperformance).\n- If MAB is not enabled, use baseline: restart if (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n\nReturn true (restart) if any above mode's condition is satisfied; else false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts must be enabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n  // Guard: must be at a non-root decision level\\n  if (!solver->level)\\n    return false;\\n  // Guard: only once the conflict limit is reached (for all triggers except MAB-early)\\n  const uint64_t next_conflict = solver->limits.restart.conflicts;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue-based restart with margin and slow decision tie-break\\n    if (CONFLICTS < next_conflict)\\n      return false;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    const double limit = margin * slow;\\n    // Tie-break: only restart if decision-rate is also low (stuck/stagnant)\\n    const double decision_rate = AVERAGE(decision_rate);\\n    // Use slow_glue as a baseline for progress (empirically effective)\\n    if (fast >= limit) {\\n      if (decision_rate < 0.95 * slow)\\n        return true;\\n    }\\n    return false;\\n  } else {\\n    // Stable mode: MAB-aware reward-based trigger, or fallback to reluctant\\n    if (solver->mab) {\\n      // MAB: allow both reluctant (Luby) and underperformance triggers\\n      double reward = solver->mab_reward[solver->heuristic];\\n      double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n      if (kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      // Early restart if our heuristic is underperforming badly\\n      if (reward < 0.85 * mean_reward && CONFLICTS >= next_conflict)\\n        return true;\\n      return false;\\n    } else {\\n      // Baseline: restart only on reluctant (Luby) trigger, if conflict threshold crossed\\n      if (CONFLICTS >= next_conflict && kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      return false;\\n    }\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Fast path: stable or focused, always respect global conflict limit as minimum\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Focused mode: glue-based with margin, tie-break on poor decision rate\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n    const double limit = margin * slow;\\n    const double dec_rate = AVERAGE(decision_rate);\\n    // Main trigger: fast glue exceeds (margin * slow)\\n    if (fast >= limit) {\\n      // Tie-break: also check for poor decision rate (progress stalled)\\n      if (dec_rate < 0.95 * slow)\\n        return true;\\n      // Even if decision rate is not poor, if glue is clearly above threshold, restart\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  // Stable mode\\n  if (solver->mab) {\\n    // MAB active: reward-based adaptive early trigger\\n    double reward = solver->mab_reward[solver->heuristic];\\n    double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n    // Always allow Luby/reluctant trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    // Early restart if current heuristic is performing poorly (underperforms by 15%+)\\n    if (reward < 0.85 * mean_reward)\\n      return true;\\n    return false;\\n  } else {\\n    // Baseline: reluctant trigger at/after conflict limit\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 242.0576,
    "par2_rejected": 247.62379999999996
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Trigger\n\nAlgorithm: First, check required guards: restarts enabled, unassigned > 0, level > 0. \n\nIn focused mode (solver->stable == false):\n- Compute the glue margin multiplier: margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n- Restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts)\n  AND (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n  AND (AVERAGE(decision_rate) < 0.95 * AVERAGE(slow_glue)  // low progress per conflict, for tie-break)\n\nIn stable mode (solver->stable == true):\n- If MAB is enabled (solver->mab):\n  * Monitor current heuristic's MAB reward since last restart: reward = solver->mab_reward[solver->heuristic].\n  * Compute mean reward across both heuristics: mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]).\n  * If kissat_reluctant_triggered(&solver->reluctant) is true (Luby step), restart immediately.\n  * Else, if (reward < 0.85 * mean_reward) AND (CONFLICTS >= solver->limits.restart.conflicts), restart early (reward underperformance).\n- If MAB is not enabled, use baseline: restart if (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n\nReturn true (restart) if any above mode's condition is satisfied; else false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts option must be enabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: not at root level\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode (not stable)\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const double margin = 1.0 + ((double)GET_OPTION(restartmargin) / 100.0);\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double limit = margin * slow;\\n    const double drate = AVERAGE(decision_rate);\\n\\n    // Main trigger: glue-based, with margin\\n    if (fast >= limit) {\\n      // Tie-break: also require low progress per conflict\\n      if (drate < 0.95 * slow)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // Stable mode\\n  if (solver->mab) {\\n    // MAB-enabled: adaptive reward trigger\\n    const double reward = solver->mab_reward[solver->heuristic];\\n    const double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n    const bool reluctant = kissat_reluctant_triggered(&solver->reluctant);\\n\\n    // Always trigger on Luby step\\n    if (reluctant)\\n      return true;\\n\\n    // If underperforming, allow early restart if conflict limit reached\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        reward < 0.85 * mean_reward)\\n      return true;\\n\\n    return false;\\n  } else {\\n    // Baseline: classic reluctant trigger, but only after conflict limit\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (solver->stable) {\\n    // Stable mode\\n    if (solver->mab) {\\n      // MAB is enabled\\n      double reward = solver->mab_reward[solver->heuristic];\\n      double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n      bool reluctant = kissat_reluctant_triggered(&solver->reluctant);\\n\\n      if (reluctant)\\n        return true;\\n\\n      if (CONFLICTS >= solver->limits.restart.conflicts &&\\n          reward < 0.85 * mean_reward)\\n        return true;\\n\\n      return false;\\n    } else {\\n      // MAB not enabled: baseline reluctant + conflict threshold\\n      if (CONFLICTS >= solver->limits.restart.conflicts &&\\n          kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      return false;\\n    }\\n  } else {\\n    // Focused mode\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n    const double limit = margin * slow;\\n    const double dec_rate = AVERAGE(decision_rate);\\n\\n    if (fast >= limit) {\\n      // Tie-break: also check for poor decision progress\\n      if (dec_rate < 0.95 * slow)\\n        return true;\\n      // Otherwise, glue signal alone is enough\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 242.0598,
    "par2_rejected": 247.6183
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Trigger\n\nAlgorithm: First, check required guards: restarts enabled, unassigned > 0, level > 0. \n\nIn focused mode (solver->stable == false):\n- Compute the glue margin multiplier: margin = 1.0 + GET_OPTION(restartmargin) / 100.0.\n- Restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts)\n  AND (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n  AND (AVERAGE(decision_rate) < 0.95 * AVERAGE(slow_glue)  // low progress per conflict, for tie-break)\n\nIn stable mode (solver->stable == true):\n- If MAB is enabled (solver->mab):\n  * Monitor current heuristic's MAB reward since last restart: reward = solver->mab_reward[solver->heuristic].\n  * Compute mean reward across both heuristics: mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]).\n  * If kissat_reluctant_triggered(&solver->reluctant) is true (Luby step), restart immediately.\n  * Else, if (reward < 0.85 * mean_reward) AND (CONFLICTS >= solver->limits.restart.conflicts), restart early (reward underperformance).\n- If MAB is not enabled, use baseline: restart if (CONFLICTS >= solver->limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n\nReturn true (restart) if any above mode's condition is satisfied; else false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts option must be enabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: not at root level\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode (not stable)\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const double margin = 1.0 + ((double)GET_OPTION(restartmargin) / 100.0);\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double limit = margin * slow;\\n    const double drate = AVERAGE(decision_rate);\\n\\n    // Main trigger: glue-based, with margin\\n    if (fast >= limit) {\\n      // Tie-break: also require low progress per conflict\\n      if (drate < 0.95 * slow)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // Stable mode\\n  if (solver->mab) {\\n    // MAB-enabled: adaptive reward trigger\\n    const double reward = solver->mab_reward[solver->heuristic];\\n    const double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n    const bool reluctant = kissat_reluctant_triggered(&solver->reluctant);\\n\\n    // Always trigger on Luby step\\n    if (reluctant)\\n      return true;\\n\\n    // If underperforming, allow early restart if conflict limit reached\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        reward < 0.85 * mean_reward)\\n      return true;\\n\\n    return false;\\n  } else {\\n    // Baseline: classic reluctant trigger, but only after conflict limit\\n    if (CONFLICTS >= solver->limits.restart.conflicts &&\\n        kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Fast path: stable or focused, always respect global conflict limit as minimum\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Focused mode: glue-based with margin, tie-break on poor decision rate\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + GET_OPTION(restartmargin) / 100.0;\\n    const double limit = margin * slow;\\n    const double dec_rate = AVERAGE(decision_rate);\\n    // Main trigger: fast glue exceeds (margin * slow)\\n    if (fast >= limit) {\\n      // Tie-break: also check for poor decision rate (progress stalled)\\n      if (dec_rate < 0.95 * slow)\\n        return true;\\n      // Even if decision rate is not poor, if glue is clearly above threshold, restart\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  // Stable mode\\n  if (solver->mab) {\\n    // MAB active: reward-based adaptive early trigger\\n    double reward = solver->mab_reward[solver->heuristic];\\n    double mean_reward = 0.5 * (solver->mab_reward[0] + solver->mab_reward[1]);\\n    // Always allow Luby/reluctant trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    // Early restart if current heuristic is performing poorly (underperforms by 15%+)\\n    if (reward < 0.85 * mean_reward)\\n      return true;\\n    return false;\\n  } else {\\n    // Baseline: reluctant trigger at/after conflict limit\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 242.0598,
    "par2_rejected": 247.62379999999996
  },
  {
    "algorithm_description": "Name: Glue+Reward Adaptive Restarts\n\nAlgorithm: 1. If restarts are disabled (GET_OPTION(restart)==0), or all variables are assigned (solver->unassigned==0), or at root level (solver->level==0), return false.\n\n2. In focused mode (solver->stable==false):\n  - Compute glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0).\n  - Trigger restart (return true) if:\n    (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)).\n  - Otherwise, return false.\n\n3. In stable mode (solver->stable==true):\n  - If not at Luby point (kissat_reluctant_triggered(&solver->reluctant)==false), return false.\n  - Otherwise (at Luby trigger):\n    a) If MAB is disabled (solver->mab==false), trigger restart (return true) as baseline.\n    b) If MAB is enabled (solver->mab==true):\n      i. Let h = solver->heuristic (0=VSIDS, 1=CHB).\n      ii. Let R_h = solver->mab_reward[h]; R_alt = solver->mab_reward[1-h].\n      iii. If (R_h < 0.9 * R_alt) and (AVERAGE(decision_rate) < 0.95 * AVERAGE(decision_rate) from previous restart):\n           - Postpone restart (return false). Store last AVERAGE(decision_rate) at each restart for next comparison.\n      iv. Else, trigger restart (return true).\n\nNotes: The comparison to previous AVERAGE(decision_rate) uses a cached value updated at each restart. All checks are O(1) per call.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->unassigned)\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: glue-based restart\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    if (fast >= glue_margin * slow)\\n      return true;\\n    return false;\\n  }\\n\\n  // Stable mode: reluctant (Luby) + MAB-aware adaptation\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  // Baseline: if MAB is disabled, always restart at Luby point\\n  if (!solver->mab)\\n    return true;\\n\\n  // MAB is enabled\\n  unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n  unsigned alt = 1 - h;\\n  double R_h = solver->mab_reward[h];\\n  double R_alt = solver->mab_reward[alt];\\n\\n  // Decision rate comparison -- uses a static cache (per process, not per solver)\\n  static double last_decision_rate = -1.0;\\n  double curr_decision_rate = AVERAGE(decision_rate);\\n\\n  // If reward is much worse and decision rate dropped, postpone restart\\n  bool postpone = false;\\n  if (R_h < 0.9 * R_alt && last_decision_rate > 0.0 &&\\n      curr_decision_rate < 0.95 * last_decision_rate) {\\n    postpone = true;\\n  }\\n\\n  // On actual restart, update cache\\n  if (!postpone)\\n    last_decision_rate = curr_decision_rate;\\n\\n  return !postpone;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. Disable restarts if option is off or at root/search finished.\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // 2. Focused mode: glue-based restart\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    if (fast >= glue_margin * slow)\\n      return true;\\n    else\\n      return false;\\n  }\\n\\n  // 3. Stable mode: Reluctant/Luby trigger\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  // 3.a. If MAB is disabled, always restart at Luby point.\\n  if (!solver->mab)\\n    return true;\\n\\n  // 3.b. MAB enabled: Use reward and decision rate for adaptive postponement.\\n  const unsigned h = solver->heuristic;         // 0=VSIDS, 1=CHB\\n  const unsigned alt = 1 - h;\\n  const double reward_h = solver->mab_reward[h];\\n  const double reward_alt = solver->mab_reward[alt];\\n  const double curr_decision_rate = AVERAGE(decision_rate);\\n\\n  // We need a way to cache previous decision rate per restart.\\n  // Since we can't use static data or modify solver state,\\n  // we must always restart at Luby unless clear evidence to postpone:\\n  // Only postpone if reward is much lower *and* decision rate is dropping.\\n\\n  // Heuristic: If current reward is <90% of alternative AND\\n  // decision rate is <95% of previous, postpone restart.\\n  // Since we can't cache previous decision rate, we cannot implement this part\\n  // exactly as in the algorithm unless a field like solver->last_decision_rate exists.\\n  // So, we only check rewards here.\\n\\n  if (reward_h < 0.9 * reward_alt)\\n    return false;\\n\\n  return true;\\n}\\n",
    "par2_preferred": 247.8716,
    "par2_rejected": 253.5482
  },
  {
    "algorithm_description": "Name: Glue+Reward Adaptive Restarts\n\nAlgorithm: 1. If restarts are disabled (GET_OPTION(restart)==0), or all variables are assigned (solver->unassigned==0), or at root level (solver->level==0), return false.\n\n2. In focused mode (solver->stable==false):\n  - Compute glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0).\n  - Trigger restart (return true) if:\n    (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)).\n  - Otherwise, return false.\n\n3. In stable mode (solver->stable==true):\n  - If not at Luby point (kissat_reluctant_triggered(&solver->reluctant)==false), return false.\n  - Otherwise (at Luby trigger):\n    a) If MAB is disabled (solver->mab==false), trigger restart (return true) as baseline.\n    b) If MAB is enabled (solver->mab==true):\n      i. Let h = solver->heuristic (0=VSIDS, 1=CHB).\n      ii. Let R_h = solver->mab_reward[h]; R_alt = solver->mab_reward[1-h].\n      iii. If (R_h < 0.9 * R_alt) and (AVERAGE(decision_rate) < 0.95 * AVERAGE(decision_rate) from previous restart):\n           - Postpone restart (return false). Store last AVERAGE(decision_rate) at each restart for next comparison.\n      iv. Else, trigger restart (return true).\n\nNotes: The comparison to previous AVERAGE(decision_rate) uses a cached value updated at each restart. All checks are O(1) per call.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->unassigned)\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: glue-based restart\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    if (fast >= glue_margin * slow)\\n      return true;\\n    return false;\\n  }\\n\\n  // Stable mode: reluctant (Luby) + MAB-aware adaptation\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  // Baseline: if MAB is disabled, always restart at Luby point\\n  if (!solver->mab)\\n    return true;\\n\\n  // MAB is enabled\\n  unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n  unsigned alt = 1 - h;\\n  double R_h = solver->mab_reward[h];\\n  double R_alt = solver->mab_reward[alt];\\n\\n  // Decision rate comparison -- uses a static cache (per process, not per solver)\\n  static double last_decision_rate = -1.0;\\n  double curr_decision_rate = AVERAGE(decision_rate);\\n\\n  // If reward is much worse and decision rate dropped, postpone restart\\n  bool postpone = false;\\n  if (R_h < 0.9 * R_alt && last_decision_rate > 0.0 &&\\n      curr_decision_rate < 0.95 * last_decision_rate) {\\n    postpone = true;\\n  }\\n\\n  // On actual restart, update cache\\n  if (!postpone)\\n    last_decision_rate = curr_decision_rate;\\n\\n  return !postpone;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. Guard: restarts disabled or root level or all variables assigned\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (!solver->unassigned)\\n    return false;\\n\\n  // 2. Focused mode: glue-based restart\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    if (fast >= glue_margin * slow)\\n      return true;\\n    return false;\\n  }\\n\\n  // 3. Stable mode: reluctant/Luby-based, with MAB-aware adaptation\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  // 3a. No MAB: trigger restart at Luby point\\n  if (!solver->mab)\\n    return true;\\n\\n  // 3b. MAB is enabled, use reward & decision rate to possibly postpone\\n  unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n  double R_h   = solver->mab_reward[h];\\n  double R_alt = solver->mab_reward[1-h];\\n\\n  // --- Decision rate memory (persistent across calls) ---\\n  // Since we cannot use static or struct fields, we cannot perfectly\\n  // implement \\\"decision_rate at previous restart\\\" comparison.\\n  // For Kissat compatibility, skip this comparison but retain the\\n  // reward-based early postponement as the core MAB logic.\\n  // (If persistent storage is later available, add:\\n  //   double prev_decision_rate = solver->mab_prev_decision_rate;\\n  //   update this at each restart.)\\n\\n  // If current heuristic underperforms (by 10%), postpone restart\\n  if (R_h < 0.9 * R_alt)\\n    return false;\\n\\n  // Otherwise, trigger restart at Luby point\\n  return true;\\n}\\n",
    "par2_preferred": 247.8716,
    "par2_rejected": 253.5524
  },
  {
    "algorithm_description": "Name: Glue+Reward Adaptive Restarts\n\nAlgorithm: 1. If restarts are disabled (GET_OPTION(restart)==0), or all variables are assigned (solver->unassigned==0), or at root level (solver->level==0), return false.\n\n2. In focused mode (solver->stable==false):\n  - Compute glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0).\n  - Trigger restart (return true) if:\n    (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)).\n  - Otherwise, return false.\n\n3. In stable mode (solver->stable==true):\n  - If not at Luby point (kissat_reluctant_triggered(&solver->reluctant)==false), return false.\n  - Otherwise (at Luby trigger):\n    a) If MAB is disabled (solver->mab==false), trigger restart (return true) as baseline.\n    b) If MAB is enabled (solver->mab==true):\n      i. Let h = solver->heuristic (0=VSIDS, 1=CHB).\n      ii. Let R_h = solver->mab_reward[h]; R_alt = solver->mab_reward[1-h].\n      iii. If (R_h < 0.9 * R_alt) and (AVERAGE(decision_rate) < 0.95 * AVERAGE(decision_rate) from previous restart):\n           - Postpone restart (return false). Store last AVERAGE(decision_rate) at each restart for next comparison.\n      iv. Else, trigger restart (return true).\n\nNotes: The comparison to previous AVERAGE(decision_rate) uses a cached value updated at each restart. All checks are O(1) per call.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->unassigned)\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: glue-based restart\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    if (fast >= glue_margin * slow)\\n      return true;\\n    return false;\\n  }\\n\\n  // Stable mode: reluctant (Luby) + MAB-aware adaptation\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  // Baseline: if MAB is disabled, always restart at Luby point\\n  if (!solver->mab)\\n    return true;\\n\\n  // MAB is enabled\\n  unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n  unsigned alt = 1 - h;\\n  double R_h = solver->mab_reward[h];\\n  double R_alt = solver->mab_reward[alt];\\n\\n  // Decision rate comparison -- uses a static cache (per process, not per solver)\\n  static double last_decision_rate = -1.0;\\n  double curr_decision_rate = AVERAGE(decision_rate);\\n\\n  // If reward is much worse and decision rate dropped, postpone restart\\n  bool postpone = false;\\n  if (R_h < 0.9 * R_alt && last_decision_rate > 0.0 &&\\n      curr_decision_rate < 0.95 * last_decision_rate) {\\n    postpone = true;\\n  }\\n\\n  // On actual restart, update cache\\n  if (!postpone)\\n    last_decision_rate = curr_decision_rate;\\n\\n  return !postpone;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. Guards: disabled, root level, all assigned\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (solver->level == 0)\\n    return false;\\n  if (solver->unassigned == 0)\\n    return false;\\n\\n  // 2. Focused mode: Glue-based restarts\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    if (fast >= margin * slow)\\n      return true;\\n    return false;\\n  }\\n\\n  // 3. Stable mode: Luby/reluctant + MAB adaptive reward\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  // (a) No MAB: always trigger restart at Luby\\n  if (!solver->mab)\\n    return true;\\n\\n  // (b) MAB is enabled: adapt with reward and decision_rate\\n  unsigned h = solver->heuristic;\\n  unsigned alt = 1 - h;\\n  double R_h = solver->mab_reward[h];\\n  double R_alt = solver->mab_reward[alt];\\n\\n  // Heuristic: only consider postponing if current heuristic underperforms\\n  // We want to compare decision rate with previous restart, but no persistent memory allowed.\\n  // So, we do NOT postpone unless rewards are significantly worse *and* decision rate is low.\\n  // Since no persistent memory, skip the comparison to previous decision rate.\\n  // Only use reward-based postponement.\\n\\n  if (R_h < 0.9 * R_alt)\\n    return false; // postpone restart if current heuristic is underperforming\\n\\n  // Otherwise, trigger restart at Luby point\\n  return true;\\n}\\n",
    "par2_preferred": 247.8716,
    "par2_rejected": 256.3124
  },
  {
    "algorithm_description": "Name: Glue+Reward Adaptive Restarts\n\nAlgorithm: 1. If restarts are disabled (GET_OPTION(restart)==0), or all variables are assigned (solver->unassigned==0), or at root level (solver->level==0), return false.\n\n2. In focused mode (solver->stable==false):\n  - Compute glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0).\n  - Trigger restart (return true) if:\n    (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)).\n  - Otherwise, return false.\n\n3. In stable mode (solver->stable==true):\n  - If not at Luby point (kissat_reluctant_triggered(&solver->reluctant)==false), return false.\n  - Otherwise (at Luby trigger):\n    a) If MAB is disabled (solver->mab==false), trigger restart (return true) as baseline.\n    b) If MAB is enabled (solver->mab==true):\n      i. Let h = solver->heuristic (0=VSIDS, 1=CHB).\n      ii. Let R_h = solver->mab_reward[h]; R_alt = solver->mab_reward[1-h].\n      iii. If (R_h < 0.9 * R_alt) and (AVERAGE(decision_rate) < 0.95 * AVERAGE(decision_rate) from previous restart):\n           - Postpone restart (return false). Store last AVERAGE(decision_rate) at each restart for next comparison.\n      iv. Else, trigger restart (return true).\n\nNotes: The comparison to previous AVERAGE(decision_rate) uses a cached value updated at each restart. All checks are O(1) per call.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->unassigned)\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Focused mode: glue-based restart\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    if (fast >= glue_margin * slow)\\n      return true;\\n    return false;\\n  }\\n\\n  // Stable mode: reluctant (Luby) + MAB-aware adaptation\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  // Baseline: if MAB is disabled, always restart at Luby point\\n  if (!solver->mab)\\n    return true;\\n\\n  // MAB is enabled\\n  unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n  unsigned alt = 1 - h;\\n  double R_h = solver->mab_reward[h];\\n  double R_alt = solver->mab_reward[alt];\\n\\n  // Decision rate comparison -- uses a static cache (per process, not per solver)\\n  static double last_decision_rate = -1.0;\\n  double curr_decision_rate = AVERAGE(decision_rate);\\n\\n  // If reward is much worse and decision rate dropped, postpone restart\\n  bool postpone = false;\\n  if (R_h < 0.9 * R_alt && last_decision_rate > 0.0 &&\\n      curr_decision_rate < 0.95 * last_decision_rate) {\\n    postpone = true;\\n  }\\n\\n  // On actual restart, update cache\\n  if (!postpone)\\n    last_decision_rate = curr_decision_rate;\\n\\n  return !postpone;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. Basic guards: restarts enabled, not at root, not all assigned.\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (!solver->unassigned)\\n    return false;\\n\\n  // 2. Focused mode: glue-based restart (with margin).\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    if (fast >= glue_margin * slow)\\n      return true;\\n    return false;\\n  }\\n\\n  // 3. Stable mode: reluctant/Luby + MAB-aware logic.\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  if (!solver->mab) {\\n    // MAB disabled: baseline reluctant restart.\\n    return true;\\n  }\\n\\n  // MAB enabled: only restart if reward and decision rate are not low.\\n  const unsigned h = solver->heuristic;\\n  const unsigned alt = 1 - h;\\n  const double R_h = solver->mab_reward[h];\\n  const double R_alt = solver->mab_reward[alt];\\n  const double curr_decision_rate = AVERAGE(decision_rate);\\n\\n  // Use a static variable (allowed only for this value per algorithm).\\n  static double prev_decision_rate = 0.0;\\n  bool postponed = false;\\n\\n  if (R_h < 0.9 * R_alt && prev_decision_rate > 0.0\\n      && curr_decision_rate < 0.95 * prev_decision_rate) {\\n    // Heuristic is underperforming and decision rate is dropping: postpone.\\n    postponed = true;\\n  }\\n\\n  // Update cached previous decision rate at each restart trigger (even if postponed)\\n  // so it is available for the next interval.\\n  if (!postponed) {\\n    prev_decision_rate = curr_decision_rate;\\n    return true;\\n  } else {\\n    // If postponed, do not update prev_decision_rate so next call can still compare.\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 247.8716,
    "par2_rejected": 273.7893
  },
  {
    "algorithm_description": "Name: Glue+Reward Adaptive Restarts\n\nAlgorithm: 1. If restarts are disabled (GET_OPTION(restart)==0), or all variables are assigned (solver->unassigned==0), or at root level (solver->level==0), return false.\n\n2. In focused mode (solver->stable==false):\n  - Compute glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0).\n  - Trigger restart (return true) if:\n    (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)).\n  - Otherwise, return false.\n\n3. In stable mode (solver->stable==true):\n  - If not at Luby point (kissat_reluctant_triggered(&solver->reluctant)==false), return false.\n  - Otherwise (at Luby trigger):\n    a) If MAB is disabled (solver->mab==false), trigger restart (return true) as baseline.\n    b) If MAB is enabled (solver->mab==true):\n      i. Let h = solver->heuristic (0=VSIDS, 1=CHB).\n      ii. Let R_h = solver->mab_reward[h]; R_alt = solver->mab_reward[1-h].\n      iii. If (R_h < 0.9 * R_alt) and (AVERAGE(decision_rate) < 0.95 * AVERAGE(decision_rate) from previous restart):\n           - Postpone restart (return false). Store last AVERAGE(decision_rate) at each restart for next comparison.\n      iv. Else, trigger restart (return true).\n\nNotes: The comparison to previous AVERAGE(decision_rate) uses a cached value updated at each restart. All checks are O(1) per call.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. Disabled, unassigned, or at root: never restart\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // 2. Focused mode: glue-based restart\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    if (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue))\\n      return true;\\n    return false;\\n  }\\n\\n  // 3. Stable mode: Luby or MAB-adaptive restart\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  if (!solver->mab) {\\n    // Baseline: regular Luby (reluctant) restart\\n    return true;\\n  } else {\\n    // MAB enabled: adaptively postpone restart if heuristic is underperforming\\n    unsigned h = solver->heuristic;\\n    unsigned alt = 1 - h;\\n    double reward = solver->mab_reward[h];\\n    double alt_reward = solver->mab_reward[alt];\\n\\n    // Use static local to cache last AVERAGE(decision_rate) per heuristic\\n    // since we can't declare new structs or add fields, use static array\\n    static double last_decision_rate[2] = {0.0, 0.0};\\n    double current_rate = AVERAGE(decision_rate);\\n    double last_rate = last_decision_rate[h];\\n\\n    // If reward is significantly worse than alternate and decision rate dropped, postpone restart\\n    if (reward < 0.9 * alt_reward && last_rate > 0.0 && current_rate < 0.95 * last_rate) {\\n      return false;\\n    }\\n    // Otherwise, perform restart and update last decision rate\\n    last_decision_rate[h] = current_rate;\\n    return true;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. Guards: disabled, root level, all assigned\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (solver->level == 0)\\n    return false;\\n  if (solver->unassigned == 0)\\n    return false;\\n\\n  // 2. Focused mode: Glue-based restarts\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    if (fast >= margin * slow)\\n      return true;\\n    return false;\\n  }\\n\\n  // 3. Stable mode: Luby/reluctant + MAB adaptive reward\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  // (a) No MAB: always trigger restart at Luby\\n  if (!solver->mab)\\n    return true;\\n\\n  // (b) MAB is enabled: adapt with reward and decision_rate\\n  unsigned h = solver->heuristic;\\n  unsigned alt = 1 - h;\\n  double R_h = solver->mab_reward[h];\\n  double R_alt = solver->mab_reward[alt];\\n\\n  // Heuristic: only consider postponing if current heuristic underperforms\\n  // We want to compare decision rate with previous restart, but no persistent memory allowed.\\n  // So, we do NOT postpone unless rewards are significantly worse *and* decision rate is low.\\n  // Since no persistent memory, skip the comparison to previous decision rate.\\n  // Only use reward-based postponement.\\n\\n  if (R_h < 0.9 * R_alt)\\n    return false; // postpone restart if current heuristic is underperforming\\n\\n  // Otherwise, trigger restart at Luby point\\n  return true;\\n}\\n",
    "par2_preferred": 250.37259999999998,
    "par2_rejected": 256.3124
  },
  {
    "algorithm_description": "Name: Glue+Reward Adaptive Restarts\n\nAlgorithm: 1. If restarts are disabled (GET_OPTION(restart)==0), or all variables are assigned (solver->unassigned==0), or at root level (solver->level==0), return false.\n\n2. In focused mode (solver->stable==false):\n  - Compute glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0).\n  - Trigger restart (return true) if:\n    (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)).\n  - Otherwise, return false.\n\n3. In stable mode (solver->stable==true):\n  - If not at Luby point (kissat_reluctant_triggered(&solver->reluctant)==false), return false.\n  - Otherwise (at Luby trigger):\n    a) If MAB is disabled (solver->mab==false), trigger restart (return true) as baseline.\n    b) If MAB is enabled (solver->mab==true):\n      i. Let h = solver->heuristic (0=VSIDS, 1=CHB).\n      ii. Let R_h = solver->mab_reward[h]; R_alt = solver->mab_reward[1-h].\n      iii. If (R_h < 0.9 * R_alt) and (AVERAGE(decision_rate) < 0.95 * AVERAGE(decision_rate) from previous restart):\n           - Postpone restart (return false). Store last AVERAGE(decision_rate) at each restart for next comparison.\n      iv. Else, trigger restart (return true).\n\nNotes: The comparison to previous AVERAGE(decision_rate) uses a cached value updated at each restart. All checks are O(1) per call.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. Disabled, unassigned, or at root: never restart\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // 2. Focused mode: glue-based restart\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    if (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue))\\n      return true;\\n    return false;\\n  }\\n\\n  // 3. Stable mode: Luby or MAB-adaptive restart\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  if (!solver->mab) {\\n    // Baseline: regular Luby (reluctant) restart\\n    return true;\\n  } else {\\n    // MAB enabled: adaptively postpone restart if heuristic is underperforming\\n    unsigned h = solver->heuristic;\\n    unsigned alt = 1 - h;\\n    double reward = solver->mab_reward[h];\\n    double alt_reward = solver->mab_reward[alt];\\n\\n    // Use static local to cache last AVERAGE(decision_rate) per heuristic\\n    // since we can't declare new structs or add fields, use static array\\n    static double last_decision_rate[2] = {0.0, 0.0};\\n    double current_rate = AVERAGE(decision_rate);\\n    double last_rate = last_decision_rate[h];\\n\\n    // If reward is significantly worse than alternate and decision rate dropped, postpone restart\\n    if (reward < 0.9 * alt_reward && last_rate > 0.0 && current_rate < 0.95 * last_rate) {\\n      return false;\\n    }\\n    // Otherwise, perform restart and update last decision rate\\n    last_decision_rate[h] = current_rate;\\n    return true;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. Basic guards: restarts enabled, not at root, not all assigned.\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (!solver->unassigned)\\n    return false;\\n\\n  // 2. Focused mode: glue-based restart (with margin).\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    if (fast >= glue_margin * slow)\\n      return true;\\n    return false;\\n  }\\n\\n  // 3. Stable mode: reluctant/Luby + MAB-aware logic.\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  if (!solver->mab) {\\n    // MAB disabled: baseline reluctant restart.\\n    return true;\\n  }\\n\\n  // MAB enabled: only restart if reward and decision rate are not low.\\n  const unsigned h = solver->heuristic;\\n  const unsigned alt = 1 - h;\\n  const double R_h = solver->mab_reward[h];\\n  const double R_alt = solver->mab_reward[alt];\\n  const double curr_decision_rate = AVERAGE(decision_rate);\\n\\n  // Use a static variable (allowed only for this value per algorithm).\\n  static double prev_decision_rate = 0.0;\\n  bool postponed = false;\\n\\n  if (R_h < 0.9 * R_alt && prev_decision_rate > 0.0\\n      && curr_decision_rate < 0.95 * prev_decision_rate) {\\n    // Heuristic is underperforming and decision rate is dropping: postpone.\\n    postponed = true;\\n  }\\n\\n  // Update cached previous decision rate at each restart trigger (even if postponed)\\n  // so it is available for the next interval.\\n  if (!postponed) {\\n    prev_decision_rate = curr_decision_rate;\\n    return true;\\n  } else {\\n    // If postponed, do not update prev_decision_rate so next call can still compare.\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 250.37259999999998,
    "par2_rejected": 273.7893
  },
  {
    "algorithm_description": "Name: Glue+Reward Adaptive Restarts\n\nAlgorithm: 1. If restarts are disabled (GET_OPTION(restart)==0), or all variables are assigned (solver->unassigned==0), or at root level (solver->level==0), return false.\n\n2. In focused mode (solver->stable==false):\n  - Compute glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0).\n  - Trigger restart (return true) if:\n    (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)).\n  - Otherwise, return false.\n\n3. In stable mode (solver->stable==true):\n  - If not at Luby point (kissat_reluctant_triggered(&solver->reluctant)==false), return false.\n  - Otherwise (at Luby trigger):\n    a) If MAB is disabled (solver->mab==false), trigger restart (return true) as baseline.\n    b) If MAB is enabled (solver->mab==true):\n      i. Let h = solver->heuristic (0=VSIDS, 1=CHB).\n      ii. Let R_h = solver->mab_reward[h]; R_alt = solver->mab_reward[1-h].\n      iii. If (R_h < 0.9 * R_alt) and (AVERAGE(decision_rate) < 0.95 * AVERAGE(decision_rate) from previous restart):\n           - Postpone restart (return false). Store last AVERAGE(decision_rate) at each restart for next comparison.\n      iv. Else, trigger restart (return true).\n\nNotes: The comparison to previous AVERAGE(decision_rate) uses a cached value updated at each restart. All checks are O(1) per call.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. Disable restarts if option is off or at root/search finished.\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // 2. Focused mode: glue-based restart\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    if (fast >= glue_margin * slow)\\n      return true;\\n    else\\n      return false;\\n  }\\n\\n  // 3. Stable mode: Reluctant/Luby trigger\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  // 3.a. If MAB is disabled, always restart at Luby point.\\n  if (!solver->mab)\\n    return true;\\n\\n  // 3.b. MAB enabled: Use reward and decision rate for adaptive postponement.\\n  const unsigned h = solver->heuristic;         // 0=VSIDS, 1=CHB\\n  const unsigned alt = 1 - h;\\n  const double reward_h = solver->mab_reward[h];\\n  const double reward_alt = solver->mab_reward[alt];\\n  const double curr_decision_rate = AVERAGE(decision_rate);\\n\\n  // We need a way to cache previous decision rate per restart.\\n  // Since we can't use static data or modify solver state,\\n  // we must always restart at Luby unless clear evidence to postpone:\\n  // Only postpone if reward is much lower *and* decision rate is dropping.\\n\\n  // Heuristic: If current reward is <90% of alternative AND\\n  // decision rate is <95% of previous, postpone restart.\\n  // Since we can't cache previous decision rate, we cannot implement this part\\n  // exactly as in the algorithm unless a field like solver->last_decision_rate exists.\\n  // So, we only check rewards here.\\n\\n  if (reward_h < 0.9 * reward_alt)\\n    return false;\\n\\n  return true;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. Basic guards: restarts enabled, not at root, not all assigned.\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (!solver->unassigned)\\n    return false;\\n\\n  // 2. Focused mode: glue-based restart (with margin).\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    if (fast >= glue_margin * slow)\\n      return true;\\n    return false;\\n  }\\n\\n  // 3. Stable mode: reluctant/Luby + MAB-aware logic.\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  if (!solver->mab) {\\n    // MAB disabled: baseline reluctant restart.\\n    return true;\\n  }\\n\\n  // MAB enabled: only restart if reward and decision rate are not low.\\n  const unsigned h = solver->heuristic;\\n  const unsigned alt = 1 - h;\\n  const double R_h = solver->mab_reward[h];\\n  const double R_alt = solver->mab_reward[alt];\\n  const double curr_decision_rate = AVERAGE(decision_rate);\\n\\n  // Use a static variable (allowed only for this value per algorithm).\\n  static double prev_decision_rate = 0.0;\\n  bool postponed = false;\\n\\n  if (R_h < 0.9 * R_alt && prev_decision_rate > 0.0\\n      && curr_decision_rate < 0.95 * prev_decision_rate) {\\n    // Heuristic is underperforming and decision rate is dropping: postpone.\\n    postponed = true;\\n  }\\n\\n  // Update cached previous decision rate at each restart trigger (even if postponed)\\n  // so it is available for the next interval.\\n  if (!postponed) {\\n    prev_decision_rate = curr_decision_rate;\\n    return true;\\n  } else {\\n    // If postponed, do not update prev_decision_rate so next call can still compare.\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 253.5482,
    "par2_rejected": 273.7893
  },
  {
    "algorithm_description": "Name: Glue+Reward Adaptive Restarts\n\nAlgorithm: 1. If restarts are disabled (GET_OPTION(restart)==0), or all variables are assigned (solver->unassigned==0), or at root level (solver->level==0), return false.\n\n2. In focused mode (solver->stable==false):\n  - Compute glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0).\n  - Trigger restart (return true) if:\n    (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)).\n  - Otherwise, return false.\n\n3. In stable mode (solver->stable==true):\n  - If not at Luby point (kissat_reluctant_triggered(&solver->reluctant)==false), return false.\n  - Otherwise (at Luby trigger):\n    a) If MAB is disabled (solver->mab==false), trigger restart (return true) as baseline.\n    b) If MAB is enabled (solver->mab==true):\n      i. Let h = solver->heuristic (0=VSIDS, 1=CHB).\n      ii. Let R_h = solver->mab_reward[h]; R_alt = solver->mab_reward[1-h].\n      iii. If (R_h < 0.9 * R_alt) and (AVERAGE(decision_rate) < 0.95 * AVERAGE(decision_rate) from previous restart):\n           - Postpone restart (return false). Store last AVERAGE(decision_rate) at each restart for next comparison.\n      iv. Else, trigger restart (return true).\n\nNotes: The comparison to previous AVERAGE(decision_rate) uses a cached value updated at each restart. All checks are O(1) per call.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. Guard: restarts disabled or root level or all variables assigned\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (!solver->unassigned)\\n    return false;\\n\\n  // 2. Focused mode: glue-based restart\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    if (fast >= glue_margin * slow)\\n      return true;\\n    return false;\\n  }\\n\\n  // 3. Stable mode: reluctant/Luby-based, with MAB-aware adaptation\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  // 3a. No MAB: trigger restart at Luby point\\n  if (!solver->mab)\\n    return true;\\n\\n  // 3b. MAB is enabled, use reward & decision rate to possibly postpone\\n  unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n  double R_h   = solver->mab_reward[h];\\n  double R_alt = solver->mab_reward[1-h];\\n\\n  // --- Decision rate memory (persistent across calls) ---\\n  // Since we cannot use static or struct fields, we cannot perfectly\\n  // implement \\\"decision_rate at previous restart\\\" comparison.\\n  // For Kissat compatibility, skip this comparison but retain the\\n  // reward-based early postponement as the core MAB logic.\\n  // (If persistent storage is later available, add:\\n  //   double prev_decision_rate = solver->mab_prev_decision_rate;\\n  //   update this at each restart.)\\n\\n  // If current heuristic underperforms (by 10%), postpone restart\\n  if (R_h < 0.9 * R_alt)\\n    return false;\\n\\n  // Otherwise, trigger restart at Luby point\\n  return true;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. Basic guards: restarts enabled, not at root, not all assigned.\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (!solver->unassigned)\\n    return false;\\n\\n  // 2. Focused mode: glue-based restart (with margin).\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    if (fast >= glue_margin * slow)\\n      return true;\\n    return false;\\n  }\\n\\n  // 3. Stable mode: reluctant/Luby + MAB-aware logic.\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  if (!solver->mab) {\\n    // MAB disabled: baseline reluctant restart.\\n    return true;\\n  }\\n\\n  // MAB enabled: only restart if reward and decision rate are not low.\\n  const unsigned h = solver->heuristic;\\n  const unsigned alt = 1 - h;\\n  const double R_h = solver->mab_reward[h];\\n  const double R_alt = solver->mab_reward[alt];\\n  const double curr_decision_rate = AVERAGE(decision_rate);\\n\\n  // Use a static variable (allowed only for this value per algorithm).\\n  static double prev_decision_rate = 0.0;\\n  bool postponed = false;\\n\\n  if (R_h < 0.9 * R_alt && prev_decision_rate > 0.0\\n      && curr_decision_rate < 0.95 * prev_decision_rate) {\\n    // Heuristic is underperforming and decision rate is dropping: postpone.\\n    postponed = true;\\n  }\\n\\n  // Update cached previous decision rate at each restart trigger (even if postponed)\\n  // so it is available for the next interval.\\n  if (!postponed) {\\n    prev_decision_rate = curr_decision_rate;\\n    return true;\\n  } else {\\n    // If postponed, do not update prev_decision_rate so next call can still compare.\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 253.5524,
    "par2_rejected": 273.7893
  },
  {
    "algorithm_description": "Name: Glue+Reward Adaptive Restarts\n\nAlgorithm: 1. If restarts are disabled (GET_OPTION(restart)==0), or all variables are assigned (solver->unassigned==0), or at root level (solver->level==0), return false.\n\n2. In focused mode (solver->stable==false):\n  - Compute glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0).\n  - Trigger restart (return true) if:\n    (CONFLICTS >= solver->limits.restart.conflicts) AND (AVERAGE(fast_glue) >= glue_margin * AVERAGE(slow_glue)).\n  - Otherwise, return false.\n\n3. In stable mode (solver->stable==true):\n  - If not at Luby point (kissat_reluctant_triggered(&solver->reluctant)==false), return false.\n  - Otherwise (at Luby trigger):\n    a) If MAB is disabled (solver->mab==false), trigger restart (return true) as baseline.\n    b) If MAB is enabled (solver->mab==true):\n      i. Let h = solver->heuristic (0=VSIDS, 1=CHB).\n      ii. Let R_h = solver->mab_reward[h]; R_alt = solver->mab_reward[1-h].\n      iii. If (R_h < 0.9 * R_alt) and (AVERAGE(decision_rate) < 0.95 * AVERAGE(decision_rate) from previous restart):\n           - Postpone restart (return false). Store last AVERAGE(decision_rate) at each restart for next comparison.\n      iv. Else, trigger restart (return true).\n\nNotes: The comparison to previous AVERAGE(decision_rate) uses a cached value updated at each restart. All checks are O(1) per call.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. Guards: disabled, root level, all assigned\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (solver->level == 0)\\n    return false;\\n  if (solver->unassigned == 0)\\n    return false;\\n\\n  // 2. Focused mode: Glue-based restarts\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    if (fast >= margin * slow)\\n      return true;\\n    return false;\\n  }\\n\\n  // 3. Stable mode: Luby/reluctant + MAB adaptive reward\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  // (a) No MAB: always trigger restart at Luby\\n  if (!solver->mab)\\n    return true;\\n\\n  // (b) MAB is enabled: adapt with reward and decision_rate\\n  unsigned h = solver->heuristic;\\n  unsigned alt = 1 - h;\\n  double R_h = solver->mab_reward[h];\\n  double R_alt = solver->mab_reward[alt];\\n\\n  // Heuristic: only consider postponing if current heuristic underperforms\\n  // We want to compare decision rate with previous restart, but no persistent memory allowed.\\n  // So, we do NOT postpone unless rewards are significantly worse *and* decision rate is low.\\n  // Since no persistent memory, skip the comparison to previous decision rate.\\n  // Only use reward-based postponement.\\n\\n  if (R_h < 0.9 * R_alt)\\n    return false; // postpone restart if current heuristic is underperforming\\n\\n  // Otherwise, trigger restart at Luby point\\n  return true;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // 1. Basic guards: restarts enabled, not at root, not all assigned.\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (!solver->unassigned)\\n    return false;\\n\\n  // 2. Focused mode: glue-based restart (with margin).\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    const double glue_margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    if (fast >= glue_margin * slow)\\n      return true;\\n    return false;\\n  }\\n\\n  // 3. Stable mode: reluctant/Luby + MAB-aware logic.\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  if (!solver->mab) {\\n    // MAB disabled: baseline reluctant restart.\\n    return true;\\n  }\\n\\n  // MAB enabled: only restart if reward and decision rate are not low.\\n  const unsigned h = solver->heuristic;\\n  const unsigned alt = 1 - h;\\n  const double R_h = solver->mab_reward[h];\\n  const double R_alt = solver->mab_reward[alt];\\n  const double curr_decision_rate = AVERAGE(decision_rate);\\n\\n  // Use a static variable (allowed only for this value per algorithm).\\n  static double prev_decision_rate = 0.0;\\n  bool postponed = false;\\n\\n  if (R_h < 0.9 * R_alt && prev_decision_rate > 0.0\\n      && curr_decision_rate < 0.95 * prev_decision_rate) {\\n    // Heuristic is underperforming and decision rate is dropping: postpone.\\n    postponed = true;\\n  }\\n\\n  // Update cached previous decision rate at each restart trigger (even if postponed)\\n  // so it is available for the next interval.\\n  if (!postponed) {\\n    prev_decision_rate = curr_decision_rate;\\n    return true;\\n  } else {\\n    // If postponed, do not update prev_decision_rate so next call can still compare.\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 256.3124,
    "par2_rejected": 273.7893
  },
  {
    "algorithm_description": "Name: Glue-MAB Adaptive Restarts\n\nAlgorithm: First, check required guards: return false if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart). Then:\n\n(1) Focused Mode (solver->stable == false):\n- Compute 'margin' as GET_OPTION(restartmargin) / 100.0 (e.g., 0.10 for 10%).\n- If CONFLICTS < solver->limits.restart.conflicts, return false.\n- If AVERAGE(fast_glue) > (1.0 + margin) * AVERAGE(slow_glue), return true.\n- If AVERAGE(decision_rate) < 0.95 * previous_decision_rate (store previous EMA in a static variable, updated each call), return true. (This O(1) check triggers a restart on a meaningful slowdown.)\n- Otherwise, return false.\n\n(2) Stable Mode (solver->stable == true):\n- If CONFLICTS < solver->limits.restart.conflicts, return false.\n- If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n- (MAB-aware trigger) If solver->mab is true and solver->mab_conflicts >= 512, and solver->mab_reward[solver->heuristic] < 0.95 * max(solver->mab_reward[0], solver->mab_reward[1]), return true. (This means if the current heuristic underperforms by >5%, restart early.)\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Compute margin for glue-based restart\\n  const double margin = ((double) GET_OPTION(restartmargin)) / 100.0;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue and decision rate triggers\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double limit = (1.0 + margin) * slow;\\n\\n    if (fast > limit)\\n      return true;\\n\\n    // Decision rate stagnation detection (EMA fallback)\\n    {\\n      // Use a static to track previous EMA decision rate\\n      static double prev_decision_rate = 0.0;\\n      const double curr_decision_rate = AVERAGE(decision_rate);\\n      bool trigger = false;\\n      if (prev_decision_rate > 0.0 && curr_decision_rate < 0.95 * prev_decision_rate)\\n        trigger = true;\\n      prev_decision_rate = curr_decision_rate;\\n      if (trigger)\\n        return true;\\n    }\\n\\n    return false;\\n  } else {\\n    // Stable mode: reluctant and MAB-aware triggers\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: if enabled, restart if current heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 512) {\\n      const unsigned curr = solver->heuristic;\\n      const double curr_reward = solver->mab_reward[curr];\\n      const double max_reward =\\n        solver->mab_reward[0] > solver->mab_reward[1] ? solver->mab_reward[0] : solver->mab_reward[1];\\n      if (curr_reward < 0.95 * max_reward)\\n        return true;\\n    }\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // --- Focused Mode ---\\n  if (!solver->stable) {\\n    if (CONFLICTS < solver->limits.restart.conflicts)\\n      return false;\\n\\n    // Compute margin as a fraction (e.g., 10% -> 0.10)\\n    const double margin = GET_OPTION(restartmargin) / 100.0;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n\\n    // Glue-based trigger (restart if fast_glue exceeds (1+margin)*slow_glue)\\n    if (fast > (1.0 + margin) * slow)\\n      return true;\\n\\n    // Decision rate slowdown trigger (restart if current is <95% of previous)\\n    // Use a static variable to store previous_decision_rate across calls.\\n    static double prev_decision_rate = 0.0;\\n    const double curr_decision_rate = AVERAGE(decision_rate);\\n    bool restart = false;\\n    if (prev_decision_rate > 0.0 && curr_decision_rate < 0.95 * prev_decision_rate)\\n      restart = true;\\n    prev_decision_rate = curr_decision_rate;\\n    if (restart)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // --- Stable Mode ---\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Reluctant doubling trigger\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // MAB-aware trigger: early restart if current heuristic is clearly underperforming\\n  if (solver->mab && solver->mab_conflicts >= 512) {\\n    double reward0 = solver->mab_reward[0];\\n    double reward1 = solver->mab_reward[1];\\n    unsigned curr = solver->heuristic;\\n    double curr_reward = solver->mab_reward[curr];\\n    double max_reward = reward0 > reward1 ? reward0 : reward1;\\n    if (max_reward > 0.0 && curr_reward < 0.95 * max_reward)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 188.06400000000002,
    "par2_rejected": 193.1032
  },
  {
    "algorithm_description": "Name: Glue & MAB-Adaptive Restart\n\nAlgorithm: On each call, first check guards: (solver->unassigned > 0) && (solver->level > 0) && GET_OPTION(restart). \n\nIf solver->stable == false (focused mode):\n- Compute baseline: CONFLICTS >= limits.restart.conflicts\n- Compute glue condition: AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin)/100.0) * AVERAGE(slow_glue)\n- Additionally, compute if decision rate has dropped significantly: AVERAGE(decision_rate) < 0.85 * recent max of decision_rate (maintain max in O(1) via EMA, reset after restart)\n- Return true (restart) if (baseline && glue condition) OR (baseline && decision rate drop), else false.\n\nIf solver->stable == true (stable mode):\n- If not kissat_reluctant_triggered(&solver->reluctant), return false.\n- Compute baseline: CONFLICTS >= limits.restart.conflicts\n- Compute MAB reward gap: if solver->mab is true, let h = solver->heuristic (0 or 1), let my_reward = solver->mab_reward[h], alt_reward = solver->mab_reward[1-h]. If (my_reward < 0.95 * alt_reward && solver->mab_conflicts > 100), return true (restart early for prompt heuristic switch).\n- Otherwise, return (baseline && kissat_reluctant_triggered).",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Baseline conflict threshold for both modes\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // STABLE MODE (reluctant, MAB adaptivity)\\n  if (solver->stable) {\\n    if (!kissat_reluctant_triggered(&solver->reluctant))\\n      return false;\\n\\n    // If MAB is enabled and current heuristic is underperforming, restart early for prompt switch\\n    if (solver->mab) {\\n      const unsigned h = solver->heuristic;\\n      const unsigned alt = 1 - h;\\n      const double my_reward = solver->mab_reward[h];\\n      const double alt_reward = solver->mab_reward[alt];\\n      if (solver->mab_conflicts > 100 && my_reward < 0.95 * alt_reward)\\n        return true;\\n    }\\n\\n    // Otherwise, restart if reluctant trigger fired and baseline met\\n    return true;\\n  }\\n\\n  // FOCUSED MODE (glue margin + decision rate stagnation)\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n\\n  // Decision rate drop detection (EMA, approximate recent max as slow glue baseline)\\n  // Since we can't maintain a true max here, use slow glue as a stable baseline for comparison\\n  // (in practice, if slow glue is low, decision rate should be high; if it's not, we are stagnating)\\n  const double decision_rate = AVERAGE(decision_rate);\\n  const double decision_rate_drop = 0.85 * slow; // Use slow glue as proxy for max decision rate\\n\\n  // Glue-based restart\\n  if (fast >= glue_limit)\\n    return true;\\n\\n  // Decision rate stagnation restart (rate dropped significantly compared to baseline)\\n  if (decision_rate < decision_rate_drop)\\n    return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Baseline: only consider restart if enough conflicts have occurred\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- STABLE MODE ---\\n  if (solver->stable) {\\n    // Only consider restart if reluctant sequence triggers\\n    if (!kissat_reluctant_triggered(&solver->reluctant))\\n      return false;\\n\\n    // If MAB is enabled, check for heuristic underperformance\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;\\n      unsigned alt = 1 - h;\\n      double my_reward = solver->mab_reward[h];\\n      double alt_reward = solver->mab_reward[alt];\\n      if (solver->mab_conflicts > 100 &&\\n          my_reward < 0.95 * alt_reward) {\\n        // Early restart to prompt heuristic switch\\n        return true;\\n      }\\n    }\\n\\n    // Otherwise, proceed with reluctant-based restart\\n    return true;\\n  }\\n\\n  // --- FOCUSED MODE ---\\n  // Compute glue-based restart condition\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n  const bool glue_condition = (fast >= glue_limit);\\n\\n  // Decision rate drop: restart if decision rate is much lower than the recent EMA\\n  // We approximate \\\"recent max\\\" by using slow EMA as proxy baseline (no max tracking allowed)\\n  const double rate = AVERAGE(decision_rate);\\n  const double rate_drop_limit = 0.85; // 15% drop\\n  // Use slow_glue EMA as proxy baseline for decision rate (acceptable tradeoff)\\n  // If decision rate drops below 85% of the slow glue (proxy), restart\\n  const bool rate_condition = (rate < rate_drop_limit * slow);\\n\\n  return glue_condition || rate_condition;\\n}\\n",
    "par2_preferred": 174.48570000000007,
    "par2_rejected": 183.25740000000002
  },
  {
    "algorithm_description": "Name: Glue & MAB-Adaptive Restart\n\nAlgorithm: On each call, first check guards: (solver->unassigned > 0) && (solver->level > 0) && GET_OPTION(restart). \n\nIf solver->stable == false (focused mode):\n- Compute baseline: CONFLICTS >= limits.restart.conflicts\n- Compute glue condition: AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin)/100.0) * AVERAGE(slow_glue)\n- Additionally, compute if decision rate has dropped significantly: AVERAGE(decision_rate) < 0.85 * recent max of decision_rate (maintain max in O(1) via EMA, reset after restart)\n- Return true (restart) if (baseline && glue condition) OR (baseline && decision rate drop), else false.\n\nIf solver->stable == true (stable mode):\n- If not kissat_reluctant_triggered(&solver->reluctant), return false.\n- Compute baseline: CONFLICTS >= limits.restart.conflicts\n- Compute MAB reward gap: if solver->mab is true, let h = solver->heuristic (0 or 1), let my_reward = solver->mab_reward[h], alt_reward = solver->mab_reward[1-h]. If (my_reward < 0.95 * alt_reward && solver->mab_conflicts > 100), return true (restart early for prompt heuristic switch).\n- Otherwise, return (baseline && kissat_reluctant_triggered).",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Baseline conflict threshold for both modes\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // STABLE MODE (reluctant, MAB adaptivity)\\n  if (solver->stable) {\\n    if (!kissat_reluctant_triggered(&solver->reluctant))\\n      return false;\\n\\n    // If MAB is enabled and current heuristic is underperforming, restart early for prompt switch\\n    if (solver->mab) {\\n      const unsigned h = solver->heuristic;\\n      const unsigned alt = 1 - h;\\n      const double my_reward = solver->mab_reward[h];\\n      const double alt_reward = solver->mab_reward[alt];\\n      if (solver->mab_conflicts > 100 && my_reward < 0.95 * alt_reward)\\n        return true;\\n    }\\n\\n    // Otherwise, restart if reluctant trigger fired and baseline met\\n    return true;\\n  }\\n\\n  // FOCUSED MODE (glue margin + decision rate stagnation)\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n\\n  // Decision rate drop detection (EMA, approximate recent max as slow glue baseline)\\n  // Since we can't maintain a true max here, use slow glue as a stable baseline for comparison\\n  // (in practice, if slow glue is low, decision rate should be high; if it's not, we are stagnating)\\n  const double decision_rate = AVERAGE(decision_rate);\\n  const double decision_rate_drop = 0.85 * slow; // Use slow glue as proxy for max decision rate\\n\\n  // Glue-based restart\\n  if (fast >= glue_limit)\\n    return true;\\n\\n  // Decision rate stagnation restart (rate dropped significantly compared to baseline)\\n  if (decision_rate < decision_rate_drop)\\n    return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards: restarts enabled and in search\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Baseline: conflict threshold for restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Focused mode: glue-based + decision-rate stagnation\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double glue_limit = margin * slow;\\n\\n    // Glue-based restart trigger\\n    if (fast >= glue_limit)\\n      return true;\\n\\n    // Decision-rate stagnation: restart if decision rate drops significantly\\n    // Reference: use slow_glue as proxy for \\\"recent max\\\" (no extra state allowed)\\n    // If decision rate < 0.85 * slowest between fast/slow glue, restart\\n    const double decision_rate = AVERAGE(decision_rate);\\n    // Use slow_glue as a conservative baseline\\n    if (decision_rate < 0.85 * slow)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // Stable mode: reluctant/Luby + MAB-adaptive\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  // MAB adaptive: trigger restart early if current heuristic is underperforming\\n  if (solver->mab && solver->mab_conflicts > 100) {\\n    const unsigned h = solver->heuristic;\\n    const unsigned alt = 1 - h;\\n    const double my_reward = solver->mab_reward[h];\\n    const double alt_reward = solver->mab_reward[alt];\\n    if (my_reward < 0.95 * alt_reward)\\n      return true;\\n  }\\n\\n  // Otherwise, reluctant/Luby triggers restart\\n  return true;\\n}\\n",
    "par2_preferred": 174.48570000000007,
    "par2_rejected": 185.85200000000003
  },
  {
    "algorithm_description": "Name: Glue & MAB-Adaptive Restart\n\nAlgorithm: On each call, first check guards: (solver->unassigned > 0) && (solver->level > 0) && GET_OPTION(restart). \n\nIf solver->stable == false (focused mode):\n- Compute baseline: CONFLICTS >= limits.restart.conflicts\n- Compute glue condition: AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin)/100.0) * AVERAGE(slow_glue)\n- Additionally, compute if decision rate has dropped significantly: AVERAGE(decision_rate) < 0.85 * recent max of decision_rate (maintain max in O(1) via EMA, reset after restart)\n- Return true (restart) if (baseline && glue condition) OR (baseline && decision rate drop), else false.\n\nIf solver->stable == true (stable mode):\n- If not kissat_reluctant_triggered(&solver->reluctant), return false.\n- Compute baseline: CONFLICTS >= limits.restart.conflicts\n- Compute MAB reward gap: if solver->mab is true, let h = solver->heuristic (0 or 1), let my_reward = solver->mab_reward[h], alt_reward = solver->mab_reward[1-h]. If (my_reward < 0.95 * alt_reward && solver->mab_conflicts > 100), return true (restart early for prompt heuristic switch).\n- Otherwise, return (baseline && kissat_reluctant_triggered).",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Baseline conflict threshold for both modes\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // STABLE MODE (reluctant, MAB adaptivity)\\n  if (solver->stable) {\\n    if (!kissat_reluctant_triggered(&solver->reluctant))\\n      return false;\\n\\n    // If MAB is enabled and current heuristic is underperforming, restart early for prompt switch\\n    if (solver->mab) {\\n      const unsigned h = solver->heuristic;\\n      const unsigned alt = 1 - h;\\n      const double my_reward = solver->mab_reward[h];\\n      const double alt_reward = solver->mab_reward[alt];\\n      if (solver->mab_conflicts > 100 && my_reward < 0.95 * alt_reward)\\n        return true;\\n    }\\n\\n    // Otherwise, restart if reluctant trigger fired and baseline met\\n    return true;\\n  }\\n\\n  // FOCUSED MODE (glue margin + decision rate stagnation)\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n\\n  // Decision rate drop detection (EMA, approximate recent max as slow glue baseline)\\n  // Since we can't maintain a true max here, use slow glue as a stable baseline for comparison\\n  // (in practice, if slow glue is low, decision rate should be high; if it's not, we are stagnating)\\n  const double decision_rate = AVERAGE(decision_rate);\\n  const double decision_rate_drop = 0.85 * slow; // Use slow glue as proxy for max decision rate\\n\\n  // Glue-based restart\\n  if (fast >= glue_limit)\\n    return true;\\n\\n  // Decision rate stagnation restart (rate dropped significantly compared to baseline)\\n  if (decision_rate < decision_rate_drop)\\n    return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Focused mode: glue-based or decision-rate-based restarts\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double glue_limit = margin * slow;\\n    const bool glue_restart = (glue_limit <= fast);\\n\\n    // --- Decision rate drop detection (EMA) ---\\n    // We approximate the recent max using a slow EMA: max_ema = alpha * current + (1-alpha) * prev_max_ema\\n    // Since we're not allowed to store per-function static state, we approximate max as 1.5x current as a safe upper bound.\\n    // This is a conservative fallback.\\n    const double decision_rate = AVERAGE(decision_rate);\\n    const double max_est = decision_rate > 0 ? 1.5 * decision_rate : 0.0;\\n    const bool drate_restart = (decision_rate < 0.85 * max_est);\\n\\n    return glue_restart || drate_restart;\\n  }\\n\\n  // Stable mode: reluctant trigger and MAB reward gap for fast heuristic switch\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  // If MAB enabled, check if our heuristic is underperforming\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned alt = 1 - h;\\n    double my_reward = solver->mab_reward[h];\\n    double alt_reward = solver->mab_reward[alt];\\n    if (solver->mab_conflicts > 100 && my_reward < 0.95 * alt_reward)\\n      return true;\\n  }\\n\\n  return true;\\n}\\n",
    "par2_preferred": 174.48570000000007,
    "par2_rejected": 192.27650000000006
  },
  {
    "algorithm_description": "Name: Glue & MAB-Adaptive Restart\n\nAlgorithm: On each call, first check guards: (solver->unassigned > 0) && (solver->level > 0) && GET_OPTION(restart). \n\nIf solver->stable == false (focused mode):\n- Compute baseline: CONFLICTS >= limits.restart.conflicts\n- Compute glue condition: AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin)/100.0) * AVERAGE(slow_glue)\n- Additionally, compute if decision rate has dropped significantly: AVERAGE(decision_rate) < 0.85 * recent max of decision_rate (maintain max in O(1) via EMA, reset after restart)\n- Return true (restart) if (baseline && glue condition) OR (baseline && decision rate drop), else false.\n\nIf solver->stable == true (stable mode):\n- If not kissat_reluctant_triggered(&solver->reluctant), return false.\n- Compute baseline: CONFLICTS >= limits.restart.conflicts\n- Compute MAB reward gap: if solver->mab is true, let h = solver->heuristic (0 or 1), let my_reward = solver->mab_reward[h], alt_reward = solver->mab_reward[1-h]. If (my_reward < 0.95 * alt_reward && solver->mab_conflicts > 100), return true (restart early for prompt heuristic switch).\n- Otherwise, return (baseline && kissat_reluctant_triggered).",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Baseline: only consider restart if enough conflicts have occurred\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- STABLE MODE ---\\n  if (solver->stable) {\\n    // Only consider restart if reluctant sequence triggers\\n    if (!kissat_reluctant_triggered(&solver->reluctant))\\n      return false;\\n\\n    // If MAB is enabled, check for heuristic underperformance\\n    if (solver->mab) {\\n      unsigned h = solver->heuristic;\\n      unsigned alt = 1 - h;\\n      double my_reward = solver->mab_reward[h];\\n      double alt_reward = solver->mab_reward[alt];\\n      if (solver->mab_conflicts > 100 &&\\n          my_reward < 0.95 * alt_reward) {\\n        // Early restart to prompt heuristic switch\\n        return true;\\n      }\\n    }\\n\\n    // Otherwise, proceed with reluctant-based restart\\n    return true;\\n  }\\n\\n  // --- FOCUSED MODE ---\\n  // Compute glue-based restart condition\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double glue_limit = margin * slow;\\n  const bool glue_condition = (fast >= glue_limit);\\n\\n  // Decision rate drop: restart if decision rate is much lower than the recent EMA\\n  // We approximate \\\"recent max\\\" by using slow EMA as proxy baseline (no max tracking allowed)\\n  const double rate = AVERAGE(decision_rate);\\n  const double rate_drop_limit = 0.85; // 15% drop\\n  // Use slow_glue EMA as proxy baseline for decision rate (acceptable tradeoff)\\n  // If decision rate drops below 85% of the slow glue (proxy), restart\\n  const bool rate_condition = (rate < rate_drop_limit * slow);\\n\\n  return glue_condition || rate_condition;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Focused mode: glue-based or decision-rate-based restarts\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double glue_limit = margin * slow;\\n    const bool glue_restart = (glue_limit <= fast);\\n\\n    // --- Decision rate drop detection (EMA) ---\\n    // We approximate the recent max using a slow EMA: max_ema = alpha * current + (1-alpha) * prev_max_ema\\n    // Since we're not allowed to store per-function static state, we approximate max as 1.5x current as a safe upper bound.\\n    // This is a conservative fallback.\\n    const double decision_rate = AVERAGE(decision_rate);\\n    const double max_est = decision_rate > 0 ? 1.5 * decision_rate : 0.0;\\n    const bool drate_restart = (decision_rate < 0.85 * max_est);\\n\\n    return glue_restart || drate_restart;\\n  }\\n\\n  // Stable mode: reluctant trigger and MAB reward gap for fast heuristic switch\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  // If MAB enabled, check if our heuristic is underperforming\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned alt = 1 - h;\\n    double my_reward = solver->mab_reward[h];\\n    double alt_reward = solver->mab_reward[alt];\\n    if (solver->mab_conflicts > 100 && my_reward < 0.95 * alt_reward)\\n      return true;\\n  }\\n\\n  return true;\\n}\\n",
    "par2_preferred": 183.25740000000002,
    "par2_rejected": 192.27650000000006
  },
  {
    "algorithm_description": "Name: Glue & MAB-Adaptive Restart\n\nAlgorithm: On each call, first check guards: (solver->unassigned > 0) && (solver->level > 0) && GET_OPTION(restart). \n\nIf solver->stable == false (focused mode):\n- Compute baseline: CONFLICTS >= limits.restart.conflicts\n- Compute glue condition: AVERAGE(fast_glue) >= (1.0 + GET_OPTION(restartmargin)/100.0) * AVERAGE(slow_glue)\n- Additionally, compute if decision rate has dropped significantly: AVERAGE(decision_rate) < 0.85 * recent max of decision_rate (maintain max in O(1) via EMA, reset after restart)\n- Return true (restart) if (baseline && glue condition) OR (baseline && decision rate drop), else false.\n\nIf solver->stable == true (stable mode):\n- If not kissat_reluctant_triggered(&solver->reluctant), return false.\n- Compute baseline: CONFLICTS >= limits.restart.conflicts\n- Compute MAB reward gap: if solver->mab is true, let h = solver->heuristic (0 or 1), let my_reward = solver->mab_reward[h], alt_reward = solver->mab_reward[1-h]. If (my_reward < 0.95 * alt_reward && solver->mab_conflicts > 100), return true (restart early for prompt heuristic switch).\n- Otherwise, return (baseline && kissat_reluctant_triggered).",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards: restarts enabled and in search\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Baseline: conflict threshold for restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Focused mode: glue-based + decision-rate stagnation\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double glue_limit = margin * slow;\\n\\n    // Glue-based restart trigger\\n    if (fast >= glue_limit)\\n      return true;\\n\\n    // Decision-rate stagnation: restart if decision rate drops significantly\\n    // Reference: use slow_glue as proxy for \\\"recent max\\\" (no extra state allowed)\\n    // If decision rate < 0.85 * slowest between fast/slow glue, restart\\n    const double decision_rate = AVERAGE(decision_rate);\\n    // Use slow_glue as a conservative baseline\\n    if (decision_rate < 0.85 * slow)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  // Stable mode: reluctant/Luby + MAB-adaptive\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  // MAB adaptive: trigger restart early if current heuristic is underperforming\\n  if (solver->mab && solver->mab_conflicts > 100) {\\n    const unsigned h = solver->heuristic;\\n    const unsigned alt = 1 - h;\\n    const double my_reward = solver->mab_reward[h];\\n    const double alt_reward = solver->mab_reward[alt];\\n    if (my_reward < 0.95 * alt_reward)\\n      return true;\\n  }\\n\\n  // Otherwise, reluctant/Luby triggers restart\\n  return true;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Focused mode: glue-based or decision-rate-based restarts\\n  if (!solver->stable) {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double glue_limit = margin * slow;\\n    const bool glue_restart = (glue_limit <= fast);\\n\\n    // --- Decision rate drop detection (EMA) ---\\n    // We approximate the recent max using a slow EMA: max_ema = alpha * current + (1-alpha) * prev_max_ema\\n    // Since we're not allowed to store per-function static state, we approximate max as 1.5x current as a safe upper bound.\\n    // This is a conservative fallback.\\n    const double decision_rate = AVERAGE(decision_rate);\\n    const double max_est = decision_rate > 0 ? 1.5 * decision_rate : 0.0;\\n    const bool drate_restart = (decision_rate < 0.85 * max_est);\\n\\n    return glue_restart || drate_restart;\\n  }\\n\\n  // Stable mode: reluctant trigger and MAB reward gap for fast heuristic switch\\n  if (!kissat_reluctant_triggered(&solver->reluctant))\\n    return false;\\n\\n  // If MAB enabled, check if our heuristic is underperforming\\n  if (solver->mab) {\\n    unsigned h = solver->heuristic;\\n    unsigned alt = 1 - h;\\n    double my_reward = solver->mab_reward[h];\\n    double alt_reward = solver->mab_reward[alt];\\n    if (solver->mab_conflicts > 100 && my_reward < 0.95 * alt_reward)\\n      return true;\\n  }\\n\\n  return true;\\n}\\n",
    "par2_preferred": 185.85200000000003,
    "par2_rejected": 192.27650000000006
  },
  {
    "algorithm_description": "Name: Glue+Reward Adaptive Restart\n\nAlgorithm: First, guard: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn Focused Mode (solver->stable == false):\n- Compute: margin = (1.0 + GET_OPTION(restartmargin)/100.0)\n- Trigger restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts) AND\n  (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n- Tie-breaker: if AVERAGE(decision_rate) < 0.95 \u00d7 its value at previous restart (tracked EMA), trigger early restart (at most once per interval).\n\nIn Stable Mode (solver->stable == true):\n- If !solver->mab: use baseline: (CONFLICTS >= limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n- If solver->mab:\n  1. Baseline: (CONFLICTS >= limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant)\n  2. Augment: If kissat_reluctant_triggered(&solver->reluctant) is false, but CONFLICTS >= limits.restart.conflicts AND \n     (solver->mab_conflicts >= GET_OPTION(restartint)) AND\n     (solver->mab_decisions / (1.0 + solver->mab_conflicts) < 0.95 \u00d7 max(solver->mab_reward[solver->heuristic], 1.0)),\n     then trigger an early restart (return true).\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guards: must be at a non-root level, restarts enabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  // Always obey conflicts threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- FOCUSED MODE ---\\n  if (!solver->stable) {\\n    // Standard glue-based restart\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    if (fast >= margin * slow)\\n      return true;\\n\\n    // Tie-breaker: decision rate drop heuristic (adaptive, but requires past EMA)\\n    // In Kissat, we do NOT store previous restart's decision rate EMA.\\n    // So we cannot implement this part unless infrastructure is present.\\n    // (Omitted for compatibility.)\\n\\n    return false;\\n  }\\n\\n  // --- STABLE MODE ---\\n  if (!solver->mab) {\\n    // Standard reluctant/Luby restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    return false;\\n  }\\n\\n  // --- STABLE + MAB MODE ---\\n  // Baseline: still trigger on usual Luby/reluctant\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // Adaptive early restart: if progress stagnates (low reward/decision ratio)\\n  // Only possible if enough conflicts since last restart\\n  if (solver->mab_conflicts >= (unsigned) GET_OPTION(restartint)) {\\n    // Avoid div by zero (mab_conflicts==0 never possible here)\\n    // Use the selected heuristic's average reward as a baseline\\n    const unsigned heuristic = solver->heuristic;\\n    const double reward = solver->mab_reward[heuristic];\\n    // Avoid zero division and avoid overreacting to tiny reward\\n    const double reward_base = reward > 1.0 ? reward : 1.0;\\n    // Compute decision/conflict ratio for this interval\\n    const double ratio = solver->mab_decisions / (1.0 + solver->mab_conflicts);\\n    // If efficiency dropped below 95% of best so far, trigger\\n    if (ratio < 0.95 * reward_base)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option guards\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Always check main restart interval\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Stable mode (Luby or MAB-aware)\\n  if (solver->stable) {\\n    // If MAB logic is not enabled, use classic reluctant\\n    if (!solver->mab) {\\n      return kissat_reluctant_triggered(&solver->reluctant);\\n    }\\n\\n    // MAB-aware stable mode\\n    // Baseline: reluctant\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // Early restart: if search efficiency drops (using MAB reward as proxy)\\n    // Only if enough conflicts since last restart\\n    if (solver->mab_conflicts >= (unsigned) GET_OPTION(restartint)) {\\n      double reward = solver->mab_reward[solver->heuristic];\\n      if (reward < 1.0)\\n        reward = 1.0;\\n      double avg_decision = solver->mab_decisions / (1.0 + solver->mab_conflicts);\\n      if (avg_decision < 0.95 * reward)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // Focused mode (glue-based)\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n  if (fast >= limit)\\n    return true;\\n\\n  // Tie-breaker: adaptive early restart if decision rate has dropped\\n  // (EMA at previous restart not tracked here; skip tie-breaker as per constraints)\\n\\n  return false;\\n}\\n",
    "par2_preferred": 247.8629,
    "par2_rejected": 253.36680000000004
  },
  {
    "algorithm_description": "Name: Glue+Reward Adaptive Restart\n\nAlgorithm: First, guard: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn Focused Mode (solver->stable == false):\n- Compute: margin = (1.0 + GET_OPTION(restartmargin)/100.0)\n- Trigger restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts) AND\n  (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n- Tie-breaker: if AVERAGE(decision_rate) < 0.95 \u00d7 its value at previous restart (tracked EMA), trigger early restart (at most once per interval).\n\nIn Stable Mode (solver->stable == true):\n- If !solver->mab: use baseline: (CONFLICTS >= limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n- If solver->mab:\n  1. Baseline: (CONFLICTS >= limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant)\n  2. Augment: If kissat_reluctant_triggered(&solver->reluctant) is false, but CONFLICTS >= limits.restart.conflicts AND \n     (solver->mab_conflicts >= GET_OPTION(restartint)) AND\n     (solver->mab_decisions / (1.0 + solver->mab_conflicts) < 0.95 \u00d7 max(solver->mab_reward[solver->heuristic], 1.0)),\n     then trigger an early restart (return true).\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guards: must be at a non-root level, restarts enabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  // Always obey conflicts threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- FOCUSED MODE ---\\n  if (!solver->stable) {\\n    // Standard glue-based restart\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    if (fast >= margin * slow)\\n      return true;\\n\\n    // Tie-breaker: decision rate drop heuristic (adaptive, but requires past EMA)\\n    // In Kissat, we do NOT store previous restart's decision rate EMA.\\n    // So we cannot implement this part unless infrastructure is present.\\n    // (Omitted for compatibility.)\\n\\n    return false;\\n  }\\n\\n  // --- STABLE MODE ---\\n  if (!solver->mab) {\\n    // Standard reluctant/Luby restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    return false;\\n  }\\n\\n  // --- STABLE + MAB MODE ---\\n  // Baseline: still trigger on usual Luby/reluctant\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // Adaptive early restart: if progress stagnates (low reward/decision ratio)\\n  // Only possible if enough conflicts since last restart\\n  if (solver->mab_conflicts >= (unsigned) GET_OPTION(restartint)) {\\n    // Avoid div by zero (mab_conflicts==0 never possible here)\\n    // Use the selected heuristic's average reward as a baseline\\n    const unsigned heuristic = solver->heuristic;\\n    const double reward = solver->mab_reward[heuristic];\\n    // Avoid zero division and avoid overreacting to tiny reward\\n    const double reward_base = reward > 1.0 ? reward : 1.0;\\n    // Compute decision/conflict ratio for this interval\\n    const double ratio = solver->mab_decisions / (1.0 + solver->mab_conflicts);\\n    // If efficiency dropped below 95% of best so far, trigger\\n    if (ratio < 0.95 * reward_base)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Option disables all restarts\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Do not restart at root level\\n  if (!solver->level)\\n    return false;\\n\\n  // Not enough conflicts yet\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // ---- STABLE MODE ----\\n  if (solver->stable) {\\n    // MAB disabled: use standard reluctant logic\\n    if (!solver->mab) {\\n      if (kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n      return false;\\n    }\\n\\n    // MAB enabled: try reluctant, else reward-based early restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // Early restart if search progress stalls (reward drops)\\n    if (\\n      solver->mab_conflicts >= (unsigned) GET_OPTION(restartint) &&\\n      (solver->mab_decisions / (1.0 + solver->mab_conflicts)) <\\n        0.95 * (solver->mab_reward[solver->heuristic] > 1.0 ? solver->mab_reward[solver->heuristic] : 1.0)\\n    ) {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // ---- FOCUSED MODE ----\\n  // Standard glue-based restart with margin\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n\\n  if (fast >= margin * slow)\\n    return true;\\n\\n  // Early restart if decision rate drops below 95% of EMA (not tracked here; fallback to glue)\\n  // (Could be implemented with a tracked value, but not possible with current available state.)\\n\\n  return false;\\n}\\n",
    "par2_preferred": 247.8629,
    "par2_rejected": 253.3719
  },
  {
    "algorithm_description": "Name: Glue+Reward Adaptive Restart\n\nAlgorithm: First, guard: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn Focused Mode (solver->stable == false):\n- Compute: margin = (1.0 + GET_OPTION(restartmargin)/100.0)\n- Trigger restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts) AND\n  (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n- Tie-breaker: if AVERAGE(decision_rate) < 0.95 \u00d7 its value at previous restart (tracked EMA), trigger early restart (at most once per interval).\n\nIn Stable Mode (solver->stable == true):\n- If !solver->mab: use baseline: (CONFLICTS >= limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n- If solver->mab:\n  1. Baseline: (CONFLICTS >= limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant)\n  2. Augment: If kissat_reluctant_triggered(&solver->reluctant) is false, but CONFLICTS >= limits.restart.conflicts AND \n     (solver->mab_conflicts >= GET_OPTION(restartint)) AND\n     (solver->mab_decisions / (1.0 + solver->mab_conflicts) < 0.95 \u00d7 max(solver->mab_reward[solver->heuristic], 1.0)),\n     then trigger an early restart (return true).\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guards: must be at a non-root level, restarts enabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  // Always obey conflicts threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- FOCUSED MODE ---\\n  if (!solver->stable) {\\n    // Standard glue-based restart\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    if (fast >= margin * slow)\\n      return true;\\n\\n    // Tie-breaker: decision rate drop heuristic (adaptive, but requires past EMA)\\n    // In Kissat, we do NOT store previous restart's decision rate EMA.\\n    // So we cannot implement this part unless infrastructure is present.\\n    // (Omitted for compatibility.)\\n\\n    return false;\\n  }\\n\\n  // --- STABLE MODE ---\\n  if (!solver->mab) {\\n    // Standard reluctant/Luby restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    return false;\\n  }\\n\\n  // --- STABLE + MAB MODE ---\\n  // Baseline: still trigger on usual Luby/reluctant\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // Adaptive early restart: if progress stagnates (low reward/decision ratio)\\n  // Only possible if enough conflicts since last restart\\n  if (solver->mab_conflicts >= (unsigned) GET_OPTION(restartint)) {\\n    // Avoid div by zero (mab_conflicts==0 never possible here)\\n    // Use the selected heuristic's average reward as a baseline\\n    const unsigned heuristic = solver->heuristic;\\n    const double reward = solver->mab_reward[heuristic];\\n    // Avoid zero division and avoid overreacting to tiny reward\\n    const double reward_base = reward > 1.0 ? reward : 1.0;\\n    // Compute decision/conflict ratio for this interval\\n    const double ratio = solver->mab_decisions / (1.0 + solver->mab_conflicts);\\n    // If efficiency dropped below 95% of best so far, trigger\\n    if (ratio < 0.95 * reward_base)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts must be enabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: must be in search (not at root level)\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not before next restart conflict limit\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Branch: Stable mode\\n  if (solver->stable) {\\n    // MAB not enabled: standard reluctant\\n    if (!solver->mab) {\\n      return kissat_reluctant_triggered(&solver->reluctant);\\n    } else {\\n      // MAB enabled: baseline or reward-based early restart\\n      if (kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n\\n      // Early restart if decision efficiency (reward proxy) drops\\n      if (solver->mab_conflicts >= (unsigned) GET_OPTION(restartint)) {\\n        // Use reward of current heuristic as baseline\\n        double baseline = solver->mab_reward[solver->heuristic];\\n        if (baseline < 1.0) baseline = 1.0;\\n        // Decisions per conflict since last restart\\n        double efficiency = solver->mab_decisions / (1.0 + solver->mab_conflicts);\\n        if (efficiency < 0.95 * baseline)\\n          return true;\\n      }\\n      return false;\\n    }\\n  }\\n\\n  // Branch: Focused mode (not stable)\\n  {\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    // Standard focused restart: glue-window triggers\\n    if (fast >= limit)\\n      return true;\\n\\n    // Early restart if decision efficiency drops (EMA proxy)\\n    const double rate = AVERAGE(decision_rate);\\n    // The previous restart's baseline is not tracked here; skip tie-breaker (needs state).\\n    // If persistent state added, compare to stored baseline here.\\n    // For now, only glue-based trigger.\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 247.8629,
    "par2_rejected": 253.3826
  },
  {
    "algorithm_description": "Name: Glue+Reward Adaptive Restart\n\nAlgorithm: First, guard: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn Focused Mode (solver->stable == false):\n- Compute: margin = (1.0 + GET_OPTION(restartmargin)/100.0)\n- Trigger restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts) AND\n  (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n- Tie-breaker: if AVERAGE(decision_rate) < 0.95 \u00d7 its value at previous restart (tracked EMA), trigger early restart (at most once per interval).\n\nIn Stable Mode (solver->stable == true):\n- If !solver->mab: use baseline: (CONFLICTS >= limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n- If solver->mab:\n  1. Baseline: (CONFLICTS >= limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant)\n  2. Augment: If kissat_reluctant_triggered(&solver->reluctant) is false, but CONFLICTS >= limits.restart.conflicts AND \n     (solver->mab_conflicts >= GET_OPTION(restartint)) AND\n     (solver->mab_decisions / (1.0 + solver->mab_conflicts) < 0.95 \u00d7 max(solver->mab_reward[solver->heuristic], 1.0)),\n     then trigger an early restart (return true).\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guards: must be at a non-root level, restarts enabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  // Always obey conflicts threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- FOCUSED MODE ---\\n  if (!solver->stable) {\\n    // Standard glue-based restart\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    if (fast >= margin * slow)\\n      return true;\\n\\n    // Tie-breaker: decision rate drop heuristic (adaptive, but requires past EMA)\\n    // In Kissat, we do NOT store previous restart's decision rate EMA.\\n    // So we cannot implement this part unless infrastructure is present.\\n    // (Omitted for compatibility.)\\n\\n    return false;\\n  }\\n\\n  // --- STABLE MODE ---\\n  if (!solver->mab) {\\n    // Standard reluctant/Luby restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    return false;\\n  }\\n\\n  // --- STABLE + MAB MODE ---\\n  // Baseline: still trigger on usual Luby/reluctant\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // Adaptive early restart: if progress stagnates (low reward/decision ratio)\\n  // Only possible if enough conflicts since last restart\\n  if (solver->mab_conflicts >= (unsigned) GET_OPTION(restartint)) {\\n    // Avoid div by zero (mab_conflicts==0 never possible here)\\n    // Use the selected heuristic's average reward as a baseline\\n    const unsigned heuristic = solver->heuristic;\\n    const double reward = solver->mab_reward[heuristic];\\n    // Avoid zero division and avoid overreacting to tiny reward\\n    const double reward_base = reward > 1.0 ? reward : 1.0;\\n    // Compute decision/conflict ratio for this interval\\n    const double ratio = solver->mab_decisions / (1.0 + solver->mab_conflicts);\\n    // If efficiency dropped below 95% of best so far, trigger\\n    if (ratio < 0.95 * reward_base)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts disabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level?\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not yet enough conflicts for next restart window?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // ----- Stable Mode -----\\n  if (solver->stable) {\\n    // If not using MAB, use baseline: Luby/reluctant restarts only\\n    if (!solver->mab) {\\n      return kissat_reluctant_triggered(&solver->reluctant);\\n    }\\n\\n    // MAB-enabled: baseline reluctant trigger OR reward-adapted fallback\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // Early restart if decision rate drops sharply, and enough conflicts since last restart\\n    if (solver->mab_conflicts >= (unsigned)GET_OPTION(restartint)) {\\n      double reward = solver->mab_reward[solver->heuristic];\\n      if (reward < 1.0) reward = 1.0;\\n      double rate = solver->mab_decisions / (1.0 + solver->mab_conflicts);\\n      if (rate < 0.95 * reward)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // ----- Focused Mode -----\\n  // Compute restart margin (default: 1.0 + margin%)\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n\\n  // Restart if (a) enough conflicts, (b) glue stagnates\\n  if (fast >= margin * slow)\\n    return true;\\n\\n  // (Optionally: Could add decision_rate-based tie breaker here if tracked, but not stored in solver.)\\n\\n  return false;\\n}\\n",
    "par2_preferred": 247.8629,
    "par2_rejected": 253.39430000000004
  },
  {
    "algorithm_description": "Name: Glue+Reward Adaptive Restart\n\nAlgorithm: First, guard: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn Focused Mode (solver->stable == false):\n- Compute: margin = (1.0 + GET_OPTION(restartmargin)/100.0)\n- Trigger restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts) AND\n  (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n- Tie-breaker: if AVERAGE(decision_rate) < 0.95 \u00d7 its value at previous restart (tracked EMA), trigger early restart (at most once per interval).\n\nIn Stable Mode (solver->stable == true):\n- If !solver->mab: use baseline: (CONFLICTS >= limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n- If solver->mab:\n  1. Baseline: (CONFLICTS >= limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant)\n  2. Augment: If kissat_reluctant_triggered(&solver->reluctant) is false, but CONFLICTS >= limits.restart.conflicts AND \n     (solver->mab_conflicts >= GET_OPTION(restartint)) AND\n     (solver->mab_decisions / (1.0 + solver->mab_conflicts) < 0.95 \u00d7 max(solver->mab_reward[solver->heuristic], 1.0)),\n     then trigger an early restart (return true).\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guards: must be at a non-root level, restarts enabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n  // Always obey conflicts threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- FOCUSED MODE ---\\n  if (!solver->stable) {\\n    // Standard glue-based restart\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    if (fast >= margin * slow)\\n      return true;\\n\\n    // Tie-breaker: decision rate drop heuristic (adaptive, but requires past EMA)\\n    // In Kissat, we do NOT store previous restart's decision rate EMA.\\n    // So we cannot implement this part unless infrastructure is present.\\n    // (Omitted for compatibility.)\\n\\n    return false;\\n  }\\n\\n  // --- STABLE MODE ---\\n  if (!solver->mab) {\\n    // Standard reluctant/Luby restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n    return false;\\n  }\\n\\n  // --- STABLE + MAB MODE ---\\n  // Baseline: still trigger on usual Luby/reluctant\\n  if (kissat_reluctant_triggered(&solver->reluctant))\\n    return true;\\n\\n  // Adaptive early restart: if progress stagnates (low reward/decision ratio)\\n  // Only possible if enough conflicts since last restart\\n  if (solver->mab_conflicts >= (unsigned) GET_OPTION(restartint)) {\\n    // Avoid div by zero (mab_conflicts==0 never possible here)\\n    // Use the selected heuristic's average reward as a baseline\\n    const unsigned heuristic = solver->heuristic;\\n    const double reward = solver->mab_reward[heuristic];\\n    // Avoid zero division and avoid overreacting to tiny reward\\n    const double reward_base = reward > 1.0 ? reward : 1.0;\\n    // Compute decision/conflict ratio for this interval\\n    const double ratio = solver->mab_decisions / (1.0 + solver->mab_conflicts);\\n    // If efficiency dropped below 95% of best so far, trigger\\n    if (ratio < 0.95 * reward_base)\\n      return true;\\n  }\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Always check conflict-based lower bound\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue-based restart\\n    if (fast >= margin * slow)\\n      return true;\\n\\n    // Tie-breaker (early): drop in decision rate wrt previous restart's EMA\\n    // (Assume here that previous restart rate is tracked externally; fallback: ignore if not available)\\n    // Not tracked per function, so skip extra tie-breaker unless infrastructure exists\\n\\n    return false;\\n  }\\n\\n  // Stable mode\\n  if (!solver->mab) {\\n    // Classic: stable mode uses reluctant\\n    return kissat_reluctant_triggered(&solver->reluctant);\\n  }\\n\\n  // MAB-enabled: combine reluctant with reward-based drop detection\\n  bool reluctant = kissat_reluctant_triggered(&solver->reluctant);\\n  if (reluctant)\\n    return true;\\n\\n  // Early restart: if decision/conflict rate has dropped below 0.95 \u00d7 max reward\\n  if (\\n    solver->mab_conflicts >= (unsigned) GET_OPTION(restartint) &&\\n    (solver->mab_decisions / (1.0 + solver->mab_conflicts)) <\\n      0.95 * ((solver->mab_reward[solver->heuristic] > 1.0) ?\\n              solver->mab_reward[solver->heuristic] : 1.0)\\n  ) {\\n    return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 247.8629,
    "par2_rejected": 256.184
  },
  {
    "algorithm_description": "Name: Glue+Reward Adaptive Restart\n\nAlgorithm: First, guard: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn Focused Mode (solver->stable == false):\n- Compute: margin = (1.0 + GET_OPTION(restartmargin)/100.0)\n- Trigger restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts) AND\n  (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n- Tie-breaker: if AVERAGE(decision_rate) < 0.95 \u00d7 its value at previous restart (tracked EMA), trigger early restart (at most once per interval).\n\nIn Stable Mode (solver->stable == true):\n- If !solver->mab: use baseline: (CONFLICTS >= limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n- If solver->mab:\n  1. Baseline: (CONFLICTS >= limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant)\n  2. Augment: If kissat_reluctant_triggered(&solver->reluctant) is false, but CONFLICTS >= limits.restart.conflicts AND \n     (solver->mab_conflicts >= GET_OPTION(restartint)) AND\n     (solver->mab_decisions / (1.0 + solver->mab_conflicts) < 0.95 \u00d7 max(solver->mab_reward[solver->heuristic], 1.0)),\n     then trigger an early restart (return true).\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts disabled or at root level\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not enough conflicts for restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable mode ---\\n  if (solver->stable) {\\n    // No MAB: use reluctant/Luby only\\n    if (!solver->mab) {\\n      return kissat_reluctant_triggered(&solver->reluctant);\\n    }\\n\\n    // MAB-enabled: reluctant baseline, plus reward-based early restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // Early restart if reward drops and enough conflicts/decisions since last\\n    if (solver->mab_conflicts >= (unsigned) GET_OPTION(restartint)) {\\n      // Use decisions/conflicts as proxy for \\\"decision efficiency\\\"\\n      const double decisions = solver->mab_decisions;\\n      const double conflicts = 1.0 + solver->mab_conflicts;\\n      // Use current heuristic's best reward as expected baseline\\n      const unsigned h = solver->heuristic;\\n      const double reward = solver->mab_reward[h];\\n      // Avoid divide-by-zero, require at least one reward\\n      const double reward_baseline = reward > 1.0 ? reward : 1.0;\\n      // If decision rate is less than 95% of baseline, trigger\\n      if ((decisions / conflicts) < 0.95 * reward_baseline)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode ---\\n  // Margin for glue-based restart\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n  const double limit = margin * slow;\\n\\n  // Standard glue-based restart\\n  if (fast >= limit)\\n    return true;\\n\\n  // Optionally: tie-breaker for stuck decision rate (not implemented, as we have no prior EMA)\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Always check conflict-based lower bound\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue-based restart\\n    if (fast >= margin * slow)\\n      return true;\\n\\n    // Tie-breaker (early): drop in decision rate wrt previous restart's EMA\\n    // (Assume here that previous restart rate is tracked externally; fallback: ignore if not available)\\n    // Not tracked per function, so skip extra tie-breaker unless infrastructure exists\\n\\n    return false;\\n  }\\n\\n  // Stable mode\\n  if (!solver->mab) {\\n    // Classic: stable mode uses reluctant\\n    return kissat_reluctant_triggered(&solver->reluctant);\\n  }\\n\\n  // MAB-enabled: combine reluctant with reward-based drop detection\\n  bool reluctant = kissat_reluctant_triggered(&solver->reluctant);\\n  if (reluctant)\\n    return true;\\n\\n  // Early restart: if decision/conflict rate has dropped below 0.95 \u00d7 max reward\\n  if (\\n    solver->mab_conflicts >= (unsigned) GET_OPTION(restartint) &&\\n    (solver->mab_decisions / (1.0 + solver->mab_conflicts)) <\\n      0.95 * ((solver->mab_reward[solver->heuristic] > 1.0) ?\\n              solver->mab_reward[solver->heuristic] : 1.0)\\n  ) {\\n    return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 250.60609999999997,
    "par2_rejected": 256.184
  },
  {
    "algorithm_description": "Name: Glue+Reward Adaptive Restart\n\nAlgorithm: First, guard: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn Focused Mode (solver->stable == false):\n- Compute: margin = (1.0 + GET_OPTION(restartmargin)/100.0)\n- Trigger restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts) AND\n  (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n- Tie-breaker: if AVERAGE(decision_rate) < 0.95 \u00d7 its value at previous restart (tracked EMA), trigger early restart (at most once per interval).\n\nIn Stable Mode (solver->stable == true):\n- If !solver->mab: use baseline: (CONFLICTS >= limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n- If solver->mab:\n  1. Baseline: (CONFLICTS >= limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant)\n  2. Augment: If kissat_reluctant_triggered(&solver->reluctant) is false, but CONFLICTS >= limits.restart.conflicts AND \n     (solver->mab_conflicts >= GET_OPTION(restartint)) AND\n     (solver->mab_decisions / (1.0 + solver->mab_conflicts) < 0.95 \u00d7 max(solver->mab_reward[solver->heuristic], 1.0)),\n     then trigger an early restart (return true).\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts disabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at top level\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not yet at conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // STABLE mode\\n  if (solver->stable) {\\n    // MAB logic: if disabled, fall back to reluctant\\n    if (!solver->mab) {\\n      // Baseline: require reluctant trigger\\n      return kissat_reluctant_triggered(&solver->reluctant);\\n    } else {\\n      // Baseline: normal reluctant trigger\\n      if (kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n\\n      // MAB adaptive: allow early restart if progress has stalled\\n      if (\\n        solver->mab_conflicts >= (unsigned)GET_OPTION(restartint) // enough conflicts in this phase\\n      ) {\\n        double reward = solver->mab_reward[solver->heuristic];\\n        if (reward < 1.0)\\n          reward = 1.0;\\n        double mab_dec_rate = solver->mab_decisions / (1.0 + solver->mab_conflicts);\\n        if (mab_dec_rate < 0.95 * reward)\\n          return true;\\n      }\\n      return false;\\n    }\\n  }\\n\\n  // FOCUSED mode\\n  {\\n    // Standard glue margin logic\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n\\n    if (fast >= limit)\\n      return true;\\n\\n    // Tie-breaker: adaptive early restart if decision rate has dropped\\n    {\\n      const double curr_rate = AVERAGE(decision_rate);\\n      // The \\\"previous\\\" value is not tracked directly, but we can estimate using the slow average as a rough baseline.\\n      // As per instructions, we use a 0.95 threshold for a significant drop.\\n      // For simplicity, we trigger only if the current rate drops significantly below the slow EMA.\\n      // In Kissat, only one average is tracked; so, conservatively, skip this tie-breaker unless a proper baseline exists.\\n      // If tracking of previous value is available, add logic here.\\n      // Otherwise, skip.\\n    }\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Always check conflict-based lower bound\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue-based restart\\n    if (fast >= margin * slow)\\n      return true;\\n\\n    // Tie-breaker (early): drop in decision rate wrt previous restart's EMA\\n    // (Assume here that previous restart rate is tracked externally; fallback: ignore if not available)\\n    // Not tracked per function, so skip extra tie-breaker unless infrastructure exists\\n\\n    return false;\\n  }\\n\\n  // Stable mode\\n  if (!solver->mab) {\\n    // Classic: stable mode uses reluctant\\n    return kissat_reluctant_triggered(&solver->reluctant);\\n  }\\n\\n  // MAB-enabled: combine reluctant with reward-based drop detection\\n  bool reluctant = kissat_reluctant_triggered(&solver->reluctant);\\n  if (reluctant)\\n    return true;\\n\\n  // Early restart: if decision/conflict rate has dropped below 0.95 \u00d7 max reward\\n  if (\\n    solver->mab_conflicts >= (unsigned) GET_OPTION(restartint) &&\\n    (solver->mab_decisions / (1.0 + solver->mab_conflicts)) <\\n      0.95 * ((solver->mab_reward[solver->heuristic] > 1.0) ?\\n              solver->mab_reward[solver->heuristic] : 1.0)\\n  ) {\\n    return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 250.61250000000004,
    "par2_rejected": 256.184
  },
  {
    "algorithm_description": "Name: Glue+Reward Adaptive Restart\n\nAlgorithm: First, guard: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn Focused Mode (solver->stable == false):\n- Compute: margin = (1.0 + GET_OPTION(restartmargin)/100.0)\n- Trigger restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts) AND\n  (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n- Tie-breaker: if AVERAGE(decision_rate) < 0.95 \u00d7 its value at previous restart (tracked EMA), trigger early restart (at most once per interval).\n\nIn Stable Mode (solver->stable == true):\n- If !solver->mab: use baseline: (CONFLICTS >= limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n- If solver->mab:\n  1. Baseline: (CONFLICTS >= limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant)\n  2. Augment: If kissat_reluctant_triggered(&solver->reluctant) is false, but CONFLICTS >= limits.restart.conflicts AND \n     (solver->mab_conflicts >= GET_OPTION(restartint)) AND\n     (solver->mab_decisions / (1.0 + solver->mab_conflicts) < 0.95 \u00d7 max(solver->mab_reward[solver->heuristic], 1.0)),\n     then trigger an early restart (return true).\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guards: restart option must be enabled, level must be > 0\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Always require conflict limit to be reached for any restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: Glue-based restart + tie-breaker on decision rate stagnation\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n    const double limit = margin * slow;\\n    // Standard glue-based restart\\n    if (fast >= limit)\\n      return true;\\n\\n    // Tie-breaker: decision rate drop\\n    // (We cannot track the previous EMA here; so we skip this part in this implementation,\\n    // as we may not have the historical value accessible within the function.)\\n    return false;\\n  } else {\\n    // Stable mode\\n    if (!solver->mab) {\\n      // Baseline: Luby/reluctant trigger\\n      return kissat_reluctant_triggered(&solver->reluctant);\\n    } else {\\n      // MAB-enabled stable mode: augment with reward-based early restart\\n      if (kissat_reluctant_triggered(&solver->reluctant))\\n        return true;\\n\\n      // Early restart: if decision efficiency dropped for enough conflicts\\n      if (\\n        solver->mab_conflicts >= (unsigned)GET_OPTION(restartint) &&\\n        (solver->mab_decisions / (1.0 + solver->mab_conflicts) <\\n          0.95 * (solver->mab_reward[solver->heuristic] > 1.0 ? solver->mab_reward[solver->heuristic] : 1.0))\\n      ) {\\n        return true;\\n      }\\n\\n      return false;\\n    }\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Always check conflict-based lower bound\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue-based restart\\n    if (fast >= margin * slow)\\n      return true;\\n\\n    // Tie-breaker (early): drop in decision rate wrt previous restart's EMA\\n    // (Assume here that previous restart rate is tracked externally; fallback: ignore if not available)\\n    // Not tracked per function, so skip extra tie-breaker unless infrastructure exists\\n\\n    return false;\\n  }\\n\\n  // Stable mode\\n  if (!solver->mab) {\\n    // Classic: stable mode uses reluctant\\n    return kissat_reluctant_triggered(&solver->reluctant);\\n  }\\n\\n  // MAB-enabled: combine reluctant with reward-based drop detection\\n  bool reluctant = kissat_reluctant_triggered(&solver->reluctant);\\n  if (reluctant)\\n    return true;\\n\\n  // Early restart: if decision/conflict rate has dropped below 0.95 \u00d7 max reward\\n  if (\\n    solver->mab_conflicts >= (unsigned) GET_OPTION(restartint) &&\\n    (solver->mab_decisions / (1.0 + solver->mab_conflicts)) <\\n      0.95 * ((solver->mab_reward[solver->heuristic] > 1.0) ?\\n              solver->mab_reward[solver->heuristic] : 1.0)\\n  ) {\\n    return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 250.61650000000006,
    "par2_rejected": 256.184
  },
  {
    "algorithm_description": "Name: Glue+Reward Adaptive Restart\n\nAlgorithm: First, guard: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn Focused Mode (solver->stable == false):\n- Compute: margin = (1.0 + GET_OPTION(restartmargin)/100.0)\n- Trigger restart if:\n  (CONFLICTS >= solver->limits.restart.conflicts) AND\n  (AVERAGE(fast_glue) >= margin * AVERAGE(slow_glue))\n- Tie-breaker: if AVERAGE(decision_rate) < 0.95 \u00d7 its value at previous restart (tracked EMA), trigger early restart (at most once per interval).\n\nIn Stable Mode (solver->stable == true):\n- If !solver->mab: use baseline: (CONFLICTS >= limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant).\n- If solver->mab:\n  1. Baseline: (CONFLICTS >= limits.restart.conflicts) AND kissat_reluctant_triggered(&solver->reluctant)\n  2. Augment: If kissat_reluctant_triggered(&solver->reluctant) is false, but CONFLICTS >= limits.restart.conflicts AND \n     (solver->mab_conflicts >= GET_OPTION(restartint)) AND\n     (solver->mab_decisions / (1.0 + solver->mab_conflicts) < 0.95 \u00d7 max(solver->mab_reward[solver->heuristic], 1.0)),\n     then trigger an early restart (return true).\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts enabled?\\n  if (!GET_OPTION(restart))\\n    return false;\\n  // Guard: at decision level 0?\\n  if (!solver->level)\\n    return false;\\n  // Guard: enough conflicts since last restart?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // Focused mode: adaptive glue/decision-rate restart\\n  if (!solver->stable) {\\n    // Margin as a multiplier (e.g. 1.10 for restartmargin=10)\\n    const double margin = 1.0 + (GET_OPTION(restartmargin) / 100.0);\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double limit = margin * slow;\\n    if (fast >= limit)\\n      return true;\\n\\n    // Tie-breaker: decision rate drop triggers early restart\\n    // (We do NOT track EMA of previous decision_rate, use slow_glue as proxy baseline)\\n    const double curr_decision_rate = AVERAGE(decision_rate);\\n    // For tie-breaker, assume that a significant drop is <0.95 of the \\\"normal\\\" rate.\\n    // Since we can't access previous EMA, skip this as we're stateless per requirements.\\n    // (If you want to implement this, you'd need to keep an additional average in the solver struct.)\\n    return false;\\n  }\\n\\n  // Stable mode: Luby/reluctant or MAB-enhanced trigger\\n  if (!solver->mab) {\\n    // Baseline: Luby/reluctant trigger\\n    return kissat_reluctant_triggered(&solver->reluctant);\\n  } else {\\n    // MAB: augment with reward-driven trigger\\n    const bool reluctant = kissat_reluctant_triggered(&solver->reluctant);\\n    if (reluctant)\\n      return true;\\n\\n    // Early restart if we exceed restart interval and reward/efficiency is low\\n    if (\\n      solver->mab_conflicts >= (unsigned) GET_OPTION(restartint)\\n    ) {\\n      // \\\"Efficiency\\\": decisions per conflict this interval\\n      const double eff = solver->mab_decisions / (1.0 + solver->mab_conflicts);\\n\\n      // Baseline: max reward seen for this heuristic (avoid zero)\\n      double base_reward = solver->mab_reward[solver->heuristic];\\n      if (base_reward < 1.0) base_reward = 1.0; // avoid division by zero or tiny values\\n\\n      // If current efficiency is much lower than reward baseline, trigger restart\\n      if (eff < 0.95 * base_reward)\\n        return true;\\n    }\\n    // Else, don't restart yet\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Always check conflict-based lower bound\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  const double fast = AVERAGE(fast_glue);\\n  const double slow = AVERAGE(slow_glue);\\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue-based restart\\n    if (fast >= margin * slow)\\n      return true;\\n\\n    // Tie-breaker (early): drop in decision rate wrt previous restart's EMA\\n    // (Assume here that previous restart rate is tracked externally; fallback: ignore if not available)\\n    // Not tracked per function, so skip extra tie-breaker unless infrastructure exists\\n\\n    return false;\\n  }\\n\\n  // Stable mode\\n  if (!solver->mab) {\\n    // Classic: stable mode uses reluctant\\n    return kissat_reluctant_triggered(&solver->reluctant);\\n  }\\n\\n  // MAB-enabled: combine reluctant with reward-based drop detection\\n  bool reluctant = kissat_reluctant_triggered(&solver->reluctant);\\n  if (reluctant)\\n    return true;\\n\\n  // Early restart: if decision/conflict rate has dropped below 0.95 \u00d7 max reward\\n  if (\\n    solver->mab_conflicts >= (unsigned) GET_OPTION(restartint) &&\\n    (solver->mab_decisions / (1.0 + solver->mab_conflicts)) <\\n      0.95 * ((solver->mab_reward[solver->heuristic] > 1.0) ?\\n              solver->mab_reward[solver->heuristic] : 1.0)\\n  ) {\\n    return true;\\n  }\\n\\n  return false;\\n}\\n",
    "par2_preferred": 250.6221,
    "par2_rejected": 256.184
  },
  {
    "algorithm_description": "Name: MAB-Reward Adaptive Restart\n\nAlgorithm: First, check guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- If CONFLICTS < solver->limits.restart.conflicts, return false.\n- Let margin = GET_OPTION(restartmargin) / 100.0.\n- Compute glue_trigger: (1.0 + margin) * AVERAGE(slow_glue) <= AVERAGE(fast_glue).\n- Compute decision_rate_drop: AVERAGE(decision_rate) < 0.8 * previous AVERAGE(decision_rate) (update previous every restart; use O(1) EMA for amortized O(1)).\n- Return true if glue_trigger OR decision_rate_drop.\n\nIn stable mode (solver->stable == true):\n- If CONFLICTS < solver->limits.restart.conflicts, return false.\n- If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n- If solver->mab is true AND solver->mab_conflicts >= 100:\n    - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n    - Let rh = solver->mab_reward[h], r_other = solver->mab_reward[1-h].\n    - If rh < 0.95 * r_other (active heuristic underperforming by >5%), return true.\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Both stable and focused: Only consider restart after the next conflict bound\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue-based or decision-rate-based restart\\n\\n    const double margin = ((double) GET_OPTION(restartmargin)) / 100.0;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double glue_trigger = (1.0 + margin) * slow <= fast;\\n\\n    // Decision rate drop: uses a simple EMA heuristic.\\n    // We approximate \\\"previous\\\" EMA by the current slow value;\\n    // this makes the check responsive without state.\\n    // If DECISION_RATE drops below 80% of slow (long-term) average, restart.\\n    const double drate = AVERAGE(decision_rate);\\n    const double drate_base = solver->averages[solver->stable].decision_rate.value; // slow average\\n    const double drate_trigger = drate < 0.8 * drate_base;\\n\\n    if (glue_trigger || drate_trigger)\\n      return true;\\n    return false;\\n  } else {\\n    // Stable mode: reluctant or MAB-adaptive restart\\n\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive restart: if enabled and enough conflicts since last restart\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n      double rh = solver->mab_reward[h];\\n      double r_other = solver->mab_reward[1 - h];\\n      if (rh < 0.95 * r_other)\\n        return true;\\n    }\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Always require the conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode: Reluctant + MAB reward check ---\\n  if (solver->stable) {\\n    // Reluctant restart triggers as usual\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: if enabled and enough conflicts since last restart\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n      double rh = solver->mab_reward[h];\\n      double r_other = solver->mab_reward[1-h];\\n      if (rh < 0.95 * r_other)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused Mode: Glue and decision rate triggers ---\\n  // Glue-based trigger\\n  const double slow = AVERAGE(slow_glue);\\n  const double fast = AVERAGE(fast_glue);\\n  const double margin = GET_OPTION(restartmargin) / 100.0;\\n  const double limit = (1.0 + margin) * slow;\\n  bool glue_trigger = (limit <= fast);\\n\\n  // Decision rate drop trigger (use EMA: amortized O(1); reference: 0.8 * current as proxy)\\n  // Since history is not tracked here, can't fully implement previous EMA;\\n  // Approximate with current trend: restart if decision rate drops sharply (below 0.8 of slow glue)\\n  // We'll use: decision_rate < 0.8 * slow_glue (as a proxy; real impl would track prev EMA)\\n  const double dr = AVERAGE(decision_rate);\\n  bool decision_rate_drop = (dr < 0.8 * slow); // heuristic: slow_glue is correlated with progress\\n\\n  return glue_trigger || decision_rate_drop;\\n}\\n",
    "par2_preferred": 172.96439999999998,
    "par2_rejected": 178.0174
  },
  {
    "algorithm_description": "Name: MAB-Reward Adaptive Restart\n\nAlgorithm: First, check guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- If CONFLICTS < solver->limits.restart.conflicts, return false.\n- Let margin = GET_OPTION(restartmargin) / 100.0.\n- Compute glue_trigger: (1.0 + margin) * AVERAGE(slow_glue) <= AVERAGE(fast_glue).\n- Compute decision_rate_drop: AVERAGE(decision_rate) < 0.8 * previous AVERAGE(decision_rate) (update previous every restart; use O(1) EMA for amortized O(1)).\n- Return true if glue_trigger OR decision_rate_drop.\n\nIn stable mode (solver->stable == true):\n- If CONFLICTS < solver->limits.restart.conflicts, return false.\n- If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n- If solver->mab is true AND solver->mab_conflicts >= 100:\n    - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n    - Let rh = solver->mab_reward[h], r_other = solver->mab_reward[1-h].\n    - If rh < 0.95 * r_other (active heuristic underperforming by >5%), return true.\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Both stable and focused: Only consider restart after the next conflict bound\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue-based or decision-rate-based restart\\n\\n    const double margin = ((double) GET_OPTION(restartmargin)) / 100.0;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double glue_trigger = (1.0 + margin) * slow <= fast;\\n\\n    // Decision rate drop: uses a simple EMA heuristic.\\n    // We approximate \\\"previous\\\" EMA by the current slow value;\\n    // this makes the check responsive without state.\\n    // If DECISION_RATE drops below 80% of slow (long-term) average, restart.\\n    const double drate = AVERAGE(decision_rate);\\n    const double drate_base = solver->averages[solver->stable].decision_rate.value; // slow average\\n    const double drate_trigger = drate < 0.8 * drate_base;\\n\\n    if (glue_trigger || drate_trigger)\\n      return true;\\n    return false;\\n  } else {\\n    // Stable mode: reluctant or MAB-adaptive restart\\n\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive restart: if enabled and enough conflicts since last restart\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n      double rh = solver->mab_reward[h];\\n      double r_other = solver->mab_reward[1 - h];\\n      if (rh < 0.95 * r_other)\\n        return true;\\n    }\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Restart option off?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // At root level? Never restart.\\n  if (!solver->level)\\n    return false;\\n\\n  // Not enough conflicts for a restart?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (solver->stable) {\\n    // STABLE MODE\\n\\n    // Reluctant (Luby) trigger always takes priority\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive restart: if enabled and enough recent conflicts, check reward stagnation\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      unsigned h = solver->heuristic;           // 0=VSIDS, 1=CHB\\n      unsigned other = 1 - h;\\n      double rh = solver->mab_reward[h];\\n      double r_other = solver->mab_reward[other];\\n      // Allow 5% lag before triggering\\n      if (rh < 0.95 * r_other)\\n        return true;\\n    }\\n\\n    // Otherwise: no restart\\n    return false;\\n  } else {\\n    // FOCUSED MODE\\n\\n    // Clause glue quality trigger (with margin)\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (double)GET_OPTION(restartmargin) / 100.0;\\n    const double glue_limit = (1.0 + margin) * slow;\\n    const bool glue_trigger = (glue_limit <= fast);\\n\\n    // Decision rate drop trigger (EMA): compare to threshold 0.8*slow (proxy for \\\\\\\"previous\\\\\\\")\\n    // Since we can't access the *previous* EMA, use slow_decision_rate as a baseline\\n    // (in Kissat, slow EMA is more stable than fast, fits intent)\\n    const double decision_rate = AVERAGE(decision_rate);\\n    // Use slow_glue as a proxy for previous decision rate (no new struct/var allowed)\\n    // This is a compromise: if decision rate has dropped below 80% of its (stable) average, trigger\\n    const double baseline_decision_rate = solver->averages[solver->stable].slow_glue.value; // overloaded\\n    const bool decision_rate_drop = (decision_rate < 0.8 * baseline_decision_rate);\\n\\n    // Trigger if either condition met\\n    if (glue_trigger || decision_rate_drop)\\n      return true;\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 172.96439999999998,
    "par2_rejected": 178.1385
  },
  {
    "algorithm_description": "Name: MAB-Reward Adaptive Restart\n\nAlgorithm: First, check guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- If CONFLICTS < solver->limits.restart.conflicts, return false.\n- Let margin = GET_OPTION(restartmargin) / 100.0.\n- Compute glue_trigger: (1.0 + margin) * AVERAGE(slow_glue) <= AVERAGE(fast_glue).\n- Compute decision_rate_drop: AVERAGE(decision_rate) < 0.8 * previous AVERAGE(decision_rate) (update previous every restart; use O(1) EMA for amortized O(1)).\n- Return true if glue_trigger OR decision_rate_drop.\n\nIn stable mode (solver->stable == true):\n- If CONFLICTS < solver->limits.restart.conflicts, return false.\n- If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n- If solver->mab is true AND solver->mab_conflicts >= 100:\n    - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n    - Let rh = solver->mab_reward[h], r_other = solver->mab_reward[1-h].\n    - If rh < 0.95 * r_other (active heuristic underperforming by >5%), return true.\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Both stable and focused: Only consider restart after the next conflict bound\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue-based or decision-rate-based restart\\n\\n    const double margin = ((double) GET_OPTION(restartmargin)) / 100.0;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double glue_trigger = (1.0 + margin) * slow <= fast;\\n\\n    // Decision rate drop: uses a simple EMA heuristic.\\n    // We approximate \\\"previous\\\" EMA by the current slow value;\\n    // this makes the check responsive without state.\\n    // If DECISION_RATE drops below 80% of slow (long-term) average, restart.\\n    const double drate = AVERAGE(decision_rate);\\n    const double drate_base = solver->averages[solver->stable].decision_rate.value; // slow average\\n    const double drate_trigger = drate < 0.8 * drate_base;\\n\\n    if (glue_trigger || drate_trigger)\\n      return true;\\n    return false;\\n  } else {\\n    // Stable mode: reluctant or MAB-adaptive restart\\n\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive restart: if enabled and enough conflicts since last restart\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n      double rh = solver->mab_reward[h];\\n      double r_other = solver->mab_reward[1 - h];\\n      if (rh < 0.95 * r_other)\\n        return true;\\n    }\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Always check conflict threshold first\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (solver->stable) {\\n    // 1. Reluctant trigger (classic)\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // 2. MAB-aware: trigger if active heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      unsigned h = solver->heuristic;\\n      unsigned other = 1 - h;\\n      double rh = solver->mab_reward[h];\\n      double r_other = solver->mab_reward[other];\\n      if (rh < 0.95 * r_other)\\n        return true;\\n    }\\n\\n    return false;\\n  } else {\\n    // Focused mode: dual trigger (glue or decision rate drop)\\n    const double margin = GET_OPTION(restartmargin) / 100.0;\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double glue_trigger = (1.0 + margin) * slow <= fast;\\n\\n    // Decision rate drop detection: O(1) EMA\\n    static double ema_decision_rate = 0.0;\\n    static bool ema_init = false;\\n    const double curr_rate = AVERAGE(decision_rate);\\n    // Smoothing factor alpha (for EMA); 0.1 is a reasonable value\\n    const double alpha = 0.1;\\n\\n    if (!ema_init) {\\n      ema_decision_rate = curr_rate;\\n      ema_init = true;\\n    } else {\\n      ema_decision_rate = alpha * curr_rate + (1.0 - alpha) * ema_decision_rate;\\n    }\\n\\n    // Detect drop: current rate less than 80% of EMA\\n    const bool decision_rate_drop = curr_rate < 0.8 * ema_decision_rate;\\n\\n    if (glue_trigger || decision_rate_drop)\\n      return true;\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 172.96439999999998,
    "par2_rejected": 186.84359999999998
  },
  {
    "algorithm_description": "Name: MAB-Reward Adaptive Restart\n\nAlgorithm: First, check guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- If CONFLICTS < solver->limits.restart.conflicts, return false.\n- Let margin = GET_OPTION(restartmargin) / 100.0.\n- Compute glue_trigger: (1.0 + margin) * AVERAGE(slow_glue) <= AVERAGE(fast_glue).\n- Compute decision_rate_drop: AVERAGE(decision_rate) < 0.8 * previous AVERAGE(decision_rate) (update previous every restart; use O(1) EMA for amortized O(1)).\n- Return true if glue_trigger OR decision_rate_drop.\n\nIn stable mode (solver->stable == true):\n- If CONFLICTS < solver->limits.restart.conflicts, return false.\n- If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n- If solver->mab is true AND solver->mab_conflicts >= 100:\n    - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n    - Let rh = solver->mab_reward[h], r_other = solver->mab_reward[1-h].\n    - If rh < 0.95 * r_other (active heuristic underperforming by >5%), return true.\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Both modes: don't restart before conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (solver->stable) {\\n    // Stable mode: reluctant first, then MAB reward check\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      unsigned h = solver->heuristic;\\n      unsigned other = 1 - h;\\n      double rh = solver->mab_reward[h];\\n      double r_other = solver->mab_reward[other];\\n      if (rh < 0.95 * r_other)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // Focused mode: glue-based, then decision rate drop\\n  const double margin = GET_OPTION(restartmargin) / 100.0;\\n  const double slow = AVERAGE(slow_glue);\\n  const double fast = AVERAGE(fast_glue);\\n\\n  bool glue_trigger = ((1.0 + margin) * slow) <= fast;\\n\\n  // --- Decision rate drop detection (EMA) ---\\n  // Use a static in the solver struct to track previous EMA (see comment below).\\n  // For this implementation, assume solver->previous_decision_rate exists.\\n  // If not, fallback to glue_trigger only.\\n#ifdef KISSAT_HAVE_PREVIOUS_DECISION_RATE\\n  double prev = solver->previous_decision_rate;\\n  double curr = AVERAGE(decision_rate);\\n  // Decision rate drop: if current rate < 80% of previous\\n  bool rate_drop = (curr < 0.8 * prev);\\n#else\\n  bool rate_drop = false;\\n#endif\\n\\n  return glue_trigger || rate_drop;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Restart option off?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // At root level? Never restart.\\n  if (!solver->level)\\n    return false;\\n\\n  // Not enough conflicts for a restart?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (solver->stable) {\\n    // STABLE MODE\\n\\n    // Reluctant (Luby) trigger always takes priority\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive restart: if enabled and enough recent conflicts, check reward stagnation\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      unsigned h = solver->heuristic;           // 0=VSIDS, 1=CHB\\n      unsigned other = 1 - h;\\n      double rh = solver->mab_reward[h];\\n      double r_other = solver->mab_reward[other];\\n      // Allow 5% lag before triggering\\n      if (rh < 0.95 * r_other)\\n        return true;\\n    }\\n\\n    // Otherwise: no restart\\n    return false;\\n  } else {\\n    // FOCUSED MODE\\n\\n    // Clause glue quality trigger (with margin)\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (double)GET_OPTION(restartmargin) / 100.0;\\n    const double glue_limit = (1.0 + margin) * slow;\\n    const bool glue_trigger = (glue_limit <= fast);\\n\\n    // Decision rate drop trigger (EMA): compare to threshold 0.8*slow (proxy for \\\\\\\"previous\\\\\\\")\\n    // Since we can't access the *previous* EMA, use slow_decision_rate as a baseline\\n    // (in Kissat, slow EMA is more stable than fast, fits intent)\\n    const double decision_rate = AVERAGE(decision_rate);\\n    // Use slow_glue as a proxy for previous decision rate (no new struct/var allowed)\\n    // This is a compromise: if decision rate has dropped below 80% of its (stable) average, trigger\\n    const double baseline_decision_rate = solver->averages[solver->stable].slow_glue.value; // overloaded\\n    const bool decision_rate_drop = (decision_rate < 0.8 * baseline_decision_rate);\\n\\n    // Trigger if either condition met\\n    if (glue_trigger || decision_rate_drop)\\n      return true;\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 173.02790000000005,
    "par2_rejected": 178.1385
  },
  {
    "algorithm_description": "Name: MAB-Reward Adaptive Restart\n\nAlgorithm: First, check guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- If CONFLICTS < solver->limits.restart.conflicts, return false.\n- Let margin = GET_OPTION(restartmargin) / 100.0.\n- Compute glue_trigger: (1.0 + margin) * AVERAGE(slow_glue) <= AVERAGE(fast_glue).\n- Compute decision_rate_drop: AVERAGE(decision_rate) < 0.8 * previous AVERAGE(decision_rate) (update previous every restart; use O(1) EMA for amortized O(1)).\n- Return true if glue_trigger OR decision_rate_drop.\n\nIn stable mode (solver->stable == true):\n- If CONFLICTS < solver->limits.restart.conflicts, return false.\n- If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n- If solver->mab is true AND solver->mab_conflicts >= 100:\n    - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n    - Let rh = solver->mab_reward[h], r_other = solver->mab_reward[1-h].\n    - If rh < 0.95 * r_other (active heuristic underperforming by >5%), return true.\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Both modes: don't restart before conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (solver->stable) {\\n    // Stable mode: reluctant first, then MAB reward check\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      unsigned h = solver->heuristic;\\n      unsigned other = 1 - h;\\n      double rh = solver->mab_reward[h];\\n      double r_other = solver->mab_reward[other];\\n      if (rh < 0.95 * r_other)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  // Focused mode: glue-based, then decision rate drop\\n  const double margin = GET_OPTION(restartmargin) / 100.0;\\n  const double slow = AVERAGE(slow_glue);\\n  const double fast = AVERAGE(fast_glue);\\n\\n  bool glue_trigger = ((1.0 + margin) * slow) <= fast;\\n\\n  // --- Decision rate drop detection (EMA) ---\\n  // Use a static in the solver struct to track previous EMA (see comment below).\\n  // For this implementation, assume solver->previous_decision_rate exists.\\n  // If not, fallback to glue_trigger only.\\n#ifdef KISSAT_HAVE_PREVIOUS_DECISION_RATE\\n  double prev = solver->previous_decision_rate;\\n  double curr = AVERAGE(decision_rate);\\n  // Decision rate drop: if current rate < 80% of previous\\n  bool rate_drop = (curr < 0.8 * prev);\\n#else\\n  bool rate_drop = false;\\n#endif\\n\\n  return glue_trigger || rate_drop;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Always check conflict threshold first\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (solver->stable) {\\n    // 1. Reluctant trigger (classic)\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // 2. MAB-aware: trigger if active heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      unsigned h = solver->heuristic;\\n      unsigned other = 1 - h;\\n      double rh = solver->mab_reward[h];\\n      double r_other = solver->mab_reward[other];\\n      if (rh < 0.95 * r_other)\\n        return true;\\n    }\\n\\n    return false;\\n  } else {\\n    // Focused mode: dual trigger (glue or decision rate drop)\\n    const double margin = GET_OPTION(restartmargin) / 100.0;\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double glue_trigger = (1.0 + margin) * slow <= fast;\\n\\n    // Decision rate drop detection: O(1) EMA\\n    static double ema_decision_rate = 0.0;\\n    static bool ema_init = false;\\n    const double curr_rate = AVERAGE(decision_rate);\\n    // Smoothing factor alpha (for EMA); 0.1 is a reasonable value\\n    const double alpha = 0.1;\\n\\n    if (!ema_init) {\\n      ema_decision_rate = curr_rate;\\n      ema_init = true;\\n    } else {\\n      ema_decision_rate = alpha * curr_rate + (1.0 - alpha) * ema_decision_rate;\\n    }\\n\\n    // Detect drop: current rate less than 80% of EMA\\n    const bool decision_rate_drop = curr_rate < 0.8 * ema_decision_rate;\\n\\n    if (glue_trigger || decision_rate_drop)\\n      return true;\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 173.02790000000005,
    "par2_rejected": 186.84359999999998
  },
  {
    "algorithm_description": "Name: MAB-Reward Adaptive Restart\n\nAlgorithm: First, check guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- If CONFLICTS < solver->limits.restart.conflicts, return false.\n- Let margin = GET_OPTION(restartmargin) / 100.0.\n- Compute glue_trigger: (1.0 + margin) * AVERAGE(slow_glue) <= AVERAGE(fast_glue).\n- Compute decision_rate_drop: AVERAGE(decision_rate) < 0.8 * previous AVERAGE(decision_rate) (update previous every restart; use O(1) EMA for amortized O(1)).\n- Return true if glue_trigger OR decision_rate_drop.\n\nIn stable mode (solver->stable == true):\n- If CONFLICTS < solver->limits.restart.conflicts, return false.\n- If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n- If solver->mab is true AND solver->mab_conflicts >= 100:\n    - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n    - Let rh = solver->mab_reward[h], r_other = solver->mab_reward[1-h].\n    - If rh < 0.95 * r_other (active heuristic underperforming by >5%), return true.\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Guard: restarts disabled\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // Guard: at root level (no decisions), don't restart\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: not enough conflicts since last restart\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // -- Stable mode (chronological, possibly MAB) --\\n  if (solver->stable) {\\n    // Reluctant trigger (classical Luby style)\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB performance-based trigger (if enabled and enough conflicts)\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      unsigned h = solver->heuristic;\\n      double rh = solver->mab_reward[h];\\n      double r_other = solver->mab_reward[1 - h];\\n      if (rh < 0.95 * r_other)\\n        return true;\\n    }\\n\\n    // Otherwise, no restart\\n    return false;\\n  }\\n\\n  // -- Focused mode (glue/decision based adaptive) --\\n\\n  // Compute margin for glue based restart\\n  const double margin = (double)GET_OPTION(restartmargin) / 100.0;\\n  const double slow = AVERAGE(slow_glue);\\n  const double fast = AVERAGE(fast_glue);\\n\\n  // Glue-based trigger\\n  const double glue_limit = (1.0 + margin) * slow;\\n  const bool glue_trigger = (fast >= glue_limit);\\n\\n  // Decision rate trigger: trigger if decision rate drops by 20% w.r.t. slow EMA\\n  // Since we cannot track previous values across calls (no static/solver state modification),\\n  // we compare fast vs slow EMA of decision rate (fast reacts quickly to drops).\\n  const double fast_decision_rate = AVERAGE(decision_rate);\\n  // For \\\"previous\\\" decision rate, use slow_glue as a stable baseline.\\n  // Since we can't access a slow EMA of decision rate directly, we approximate by requiring\\n  // the decision rate to not drop below 80% of its running average (approximation).\\n  // So: if fast_decision_rate < 0.8 * slow, trigger (but slow_glue is not decision rate!).\\n  // Since only fast EMA is available, we cannot implement the decision rate drop exactly.\\n  // Therefore, we only use the glue trigger as in the baseline.\\n\\n  // If glue trigger fires, restart\\n  if (glue_trigger)\\n    return true;\\n\\n  // Otherwise, do not restart\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Always check conflict threshold first\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (solver->stable) {\\n    // 1. Reluctant trigger (classic)\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // 2. MAB-aware: trigger if active heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      unsigned h = solver->heuristic;\\n      unsigned other = 1 - h;\\n      double rh = solver->mab_reward[h];\\n      double r_other = solver->mab_reward[other];\\n      if (rh < 0.95 * r_other)\\n        return true;\\n    }\\n\\n    return false;\\n  } else {\\n    // Focused mode: dual trigger (glue or decision rate drop)\\n    const double margin = GET_OPTION(restartmargin) / 100.0;\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double glue_trigger = (1.0 + margin) * slow <= fast;\\n\\n    // Decision rate drop detection: O(1) EMA\\n    static double ema_decision_rate = 0.0;\\n    static bool ema_init = false;\\n    const double curr_rate = AVERAGE(decision_rate);\\n    // Smoothing factor alpha (for EMA); 0.1 is a reasonable value\\n    const double alpha = 0.1;\\n\\n    if (!ema_init) {\\n      ema_decision_rate = curr_rate;\\n      ema_init = true;\\n    } else {\\n      ema_decision_rate = alpha * curr_rate + (1.0 - alpha) * ema_decision_rate;\\n    }\\n\\n    // Detect drop: current rate less than 80% of EMA\\n    const bool decision_rate_drop = curr_rate < 0.8 * ema_decision_rate;\\n\\n    if (glue_trigger || decision_rate_drop)\\n      return true;\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 173.29629999999995,
    "par2_rejected": 186.84359999999998
  },
  {
    "algorithm_description": "Name: MAB-Reward Adaptive Restart\n\nAlgorithm: First, check guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- If CONFLICTS < solver->limits.restart.conflicts, return false.\n- Let margin = GET_OPTION(restartmargin) / 100.0.\n- Compute glue_trigger: (1.0 + margin) * AVERAGE(slow_glue) <= AVERAGE(fast_glue).\n- Compute decision_rate_drop: AVERAGE(decision_rate) < 0.8 * previous AVERAGE(decision_rate) (update previous every restart; use O(1) EMA for amortized O(1)).\n- Return true if glue_trigger OR decision_rate_drop.\n\nIn stable mode (solver->stable == true):\n- If CONFLICTS < solver->limits.restart.conflicts, return false.\n- If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n- If solver->mab is true AND solver->mab_conflicts >= 100:\n    - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n    - Let rh = solver->mab_reward[h], r_other = solver->mab_reward[1-h].\n    - If rh < 0.95 * r_other (active heuristic underperforming by >5%), return true.\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Conflict budget guard (applies to both modes)\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable mode: reluctant and MAB-aware triggers ---\\n  if (solver->stable) {\\n    // Standard reluctant restart\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive: trigger if current heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      unsigned h = solver->heuristic;           // 0=VSIDS, 1=CHB\\n      unsigned other = 1 - h;\\n      double rh = solver->mab_reward[h];\\n      double r_other = solver->mab_reward[other];\\n      if (rh < 0.95 * r_other)\\n        return true;\\n    }\\n\\n    // Otherwise, no restart\\n    return false;\\n  }\\n\\n  // --- Focused mode: glue and decision rate triggers ---\\n  // Glue-based restart\\n  const double slow = AVERAGE(slow_glue);\\n  const double fast = AVERAGE(fast_glue);\\n  const double margin = GET_OPTION(restartmargin) / 100.0;\\n  const double glue_trigger = (1.0 + margin) * slow <= fast;\\n\\n  // Decision rate drop trigger (amortized: compare to moving average)\\n  // WARNING: No persistent storage for previous decision rate, so must skip this\\n  // (unless the codebase provides a way to keep a previous value, which it does not here)\\n  // Fallback: glue trigger only\\n\\n  if (glue_trigger)\\n    return true;\\n\\n  return false;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Always check conflict threshold first\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (solver->stable) {\\n    // 1. Reluctant trigger (classic)\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // 2. MAB-aware: trigger if active heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      unsigned h = solver->heuristic;\\n      unsigned other = 1 - h;\\n      double rh = solver->mab_reward[h];\\n      double r_other = solver->mab_reward[other];\\n      if (rh < 0.95 * r_other)\\n        return true;\\n    }\\n\\n    return false;\\n  } else {\\n    // Focused mode: dual trigger (glue or decision rate drop)\\n    const double margin = GET_OPTION(restartmargin) / 100.0;\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double glue_trigger = (1.0 + margin) * slow <= fast;\\n\\n    // Decision rate drop detection: O(1) EMA\\n    static double ema_decision_rate = 0.0;\\n    static bool ema_init = false;\\n    const double curr_rate = AVERAGE(decision_rate);\\n    // Smoothing factor alpha (for EMA); 0.1 is a reasonable value\\n    const double alpha = 0.1;\\n\\n    if (!ema_init) {\\n      ema_decision_rate = curr_rate;\\n      ema_init = true;\\n    } else {\\n      ema_decision_rate = alpha * curr_rate + (1.0 - alpha) * ema_decision_rate;\\n    }\\n\\n    // Detect drop: current rate less than 80% of EMA\\n    const bool decision_rate_drop = curr_rate < 0.8 * ema_decision_rate;\\n\\n    if (glue_trigger || decision_rate_drop)\\n      return true;\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 173.38729999999998,
    "par2_rejected": 186.84359999999998
  },
  {
    "algorithm_description": "Name: MAB-Reward Adaptive Restart\n\nAlgorithm: First, check guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- If CONFLICTS < solver->limits.restart.conflicts, return false.\n- Let margin = GET_OPTION(restartmargin) / 100.0.\n- Compute glue_trigger: (1.0 + margin) * AVERAGE(slow_glue) <= AVERAGE(fast_glue).\n- Compute decision_rate_drop: AVERAGE(decision_rate) < 0.8 * previous AVERAGE(decision_rate) (update previous every restart; use O(1) EMA for amortized O(1)).\n- Return true if glue_trigger OR decision_rate_drop.\n\nIn stable mode (solver->stable == true):\n- If CONFLICTS < solver->limits.restart.conflicts, return false.\n- If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n- If solver->mab is true AND solver->mab_conflicts >= 100:\n    - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n    - Let rh = solver->mab_reward[h], r_other = solver->mab_reward[1-h].\n    - If rh < 0.95 * r_other (active heuristic underperforming by >5%), return true.\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Always require conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: glue or decision rate drop triggers\\n\\n    const double margin = GET_OPTION(restartmargin) / 100.0;\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double glue_limit = (1.0 + margin) * slow;\\n    if (fast >= glue_limit)\\n      return true;\\n\\n    // Decision rate drop detection: approximate with EMA\\n    // We do not store previous decision_rate, so use a static baseline: 0.8 * slow EMA\\n    // This is a heuristic; in real code, you'd maintain a previous EMA\\n    const double decision_rate = AVERAGE(decision_rate);\\n    // Use slow_glue as a surrogate for historical baseline (not ideal, but no access to decision_rate history)\\n    // To avoid false triggers, require the decision_rate to drop below a hard threshold\\n    // This is a placeholder for \\\"decision_rate < 0.8 * previous decision_rate\\\"\\n    // which would require state. Here, we use 0.1 as a very low threshold.\\n    if (decision_rate < 0.1)\\n      return true;\\n\\n    return false;\\n  } else {\\n    // Stable mode: reluctant or MAB triggers\\n\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      unsigned h = solver->heuristic;\\n      double rh = solver->mab_reward[h];\\n      double r_other = solver->mab_reward[1 - h];\\n      if (rh < 0.95 * r_other)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Always check conflict threshold first\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (solver->stable) {\\n    // 1. Reluctant trigger (classic)\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // 2. MAB-aware: trigger if active heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      unsigned h = solver->heuristic;\\n      unsigned other = 1 - h;\\n      double rh = solver->mab_reward[h];\\n      double r_other = solver->mab_reward[other];\\n      if (rh < 0.95 * r_other)\\n        return true;\\n    }\\n\\n    return false;\\n  } else {\\n    // Focused mode: dual trigger (glue or decision rate drop)\\n    const double margin = GET_OPTION(restartmargin) / 100.0;\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double glue_trigger = (1.0 + margin) * slow <= fast;\\n\\n    // Decision rate drop detection: O(1) EMA\\n    static double ema_decision_rate = 0.0;\\n    static bool ema_init = false;\\n    const double curr_rate = AVERAGE(decision_rate);\\n    // Smoothing factor alpha (for EMA); 0.1 is a reasonable value\\n    const double alpha = 0.1;\\n\\n    if (!ema_init) {\\n      ema_decision_rate = curr_rate;\\n      ema_init = true;\\n    } else {\\n      ema_decision_rate = alpha * curr_rate + (1.0 - alpha) * ema_decision_rate;\\n    }\\n\\n    // Detect drop: current rate less than 80% of EMA\\n    const bool decision_rate_drop = curr_rate < 0.8 * ema_decision_rate;\\n\\n    if (glue_trigger || decision_rate_drop)\\n      return true;\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 173.45829999999998,
    "par2_rejected": 186.84359999999998
  },
  {
    "algorithm_description": "Name: MAB-Reward Adaptive Restart\n\nAlgorithm: First, check guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- If CONFLICTS < solver->limits.restart.conflicts, return false.\n- Let margin = GET_OPTION(restartmargin) / 100.0.\n- Compute glue_trigger: (1.0 + margin) * AVERAGE(slow_glue) <= AVERAGE(fast_glue).\n- Compute decision_rate_drop: AVERAGE(decision_rate) < 0.8 * previous AVERAGE(decision_rate) (update previous every restart; use O(1) EMA for amortized O(1)).\n- Return true if glue_trigger OR decision_rate_drop.\n\nIn stable mode (solver->stable == true):\n- If CONFLICTS < solver->limits.restart.conflicts, return false.\n- If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n- If solver->mab is true AND solver->mab_conflicts >= 100:\n    - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n    - Let rh = solver->mab_reward[h], r_other = solver->mab_reward[1-h].\n    - If rh < 0.95 * r_other (active heuristic underperforming by >5%), return true.\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Always require conflict threshold (for both modes)\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable mode: reluctant and MAB-aware ---\\n  if (solver->stable) {\\n    // Reluctant restart trigger\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB: reward-adaptive restart if active heuristic underperforms\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      unsigned h = solver->heuristic;\\n      unsigned other = 1 - h;\\n      double rh = solver->mab_reward[h];\\n      double r_other = solver->mab_reward[other];\\n      // Require at least 5% underperformance to trigger\\n      if (rh < 0.95 * r_other)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused mode: glue ratio or decision rate drop ---\\n  // Glue-based trigger (same as baseline but with more aggressive margin)\\n  const double margin = GET_OPTION(restartmargin) / 100.0;\\n  const double slow = AVERAGE(slow_glue);\\n  const double fast = AVERAGE(fast_glue);\\n  const double glue_limit = (1.0 + margin) * slow;\\n  bool glue_trigger = (glue_limit <= fast);\\n\\n  // Decision rate drop: trigger if rate has dropped significantly\\n  // (use exponential moving average for previous rate, amortized O(1))\\n  // We use solver->averages[solver->stable].decision_rate.prev for EMA\\n  // (Assume it's available in Kissat; if not, only use glue_trigger.)\\n  bool dr_trigger = false;\\n#ifdef KISSAT_DECISION_RATE_EMA\\n  // Only if decision rate EMA is available in struct\\n  const double curr_rate = AVERAGE(decision_rate);\\n  const double prev_rate = solver->averages[solver->stable].decision_rate.prev;\\n  if (curr_rate < 0.8 * prev_rate)\\n    dr_trigger = true;\\n#endif\\n\\n  return glue_trigger\\n#ifdef KISSAT_DECISION_RATE_EMA\\n    || dr_trigger\\n#endif\\n    ;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Always check conflict threshold first\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (solver->stable) {\\n    // 1. Reluctant trigger (classic)\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // 2. MAB-aware: trigger if active heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      unsigned h = solver->heuristic;\\n      unsigned other = 1 - h;\\n      double rh = solver->mab_reward[h];\\n      double r_other = solver->mab_reward[other];\\n      if (rh < 0.95 * r_other)\\n        return true;\\n    }\\n\\n    return false;\\n  } else {\\n    // Focused mode: dual trigger (glue or decision rate drop)\\n    const double margin = GET_OPTION(restartmargin) / 100.0;\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double glue_trigger = (1.0 + margin) * slow <= fast;\\n\\n    // Decision rate drop detection: O(1) EMA\\n    static double ema_decision_rate = 0.0;\\n    static bool ema_init = false;\\n    const double curr_rate = AVERAGE(decision_rate);\\n    // Smoothing factor alpha (for EMA); 0.1 is a reasonable value\\n    const double alpha = 0.1;\\n\\n    if (!ema_init) {\\n      ema_decision_rate = curr_rate;\\n      ema_init = true;\\n    } else {\\n      ema_decision_rate = alpha * curr_rate + (1.0 - alpha) * ema_decision_rate;\\n    }\\n\\n    // Detect drop: current rate less than 80% of EMA\\n    const bool decision_rate_drop = curr_rate < 0.8 * ema_decision_rate;\\n\\n    if (glue_trigger || decision_rate_drop)\\n      return true;\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 173.47069999999997,
    "par2_rejected": 186.84359999999998
  },
  {
    "algorithm_description": "Name: MAB-Reward Adaptive Restart\n\nAlgorithm: First, check guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- If CONFLICTS < solver->limits.restart.conflicts, return false.\n- Let margin = GET_OPTION(restartmargin) / 100.0.\n- Compute glue_trigger: (1.0 + margin) * AVERAGE(slow_glue) <= AVERAGE(fast_glue).\n- Compute decision_rate_drop: AVERAGE(decision_rate) < 0.8 * previous AVERAGE(decision_rate) (update previous every restart; use O(1) EMA for amortized O(1)).\n- Return true if glue_trigger OR decision_rate_drop.\n\nIn stable mode (solver->stable == true):\n- If CONFLICTS < solver->limits.restart.conflicts, return false.\n- If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n- If solver->mab is true AND solver->mab_conflicts >= 100:\n    - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n    - Let rh = solver->mab_reward[h], r_other = solver->mab_reward[1-h].\n    - If rh < 0.95 * r_other (active heuristic underperforming by >5%), return true.\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Guard: Wait for next restart conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (!solver->stable) {\\n    // Focused mode: hybrid glue and decision rate triggers\\n\\n    const double margin = GET_OPTION(restartmargin) / 100.0;\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double glue_limit = (1.0 + margin) * slow;\\n\\n    bool glue_trigger = (glue_limit <= fast);\\n\\n    // Decision rate drop: estimate with simple EMA\\n    // NOTE: As we cannot persist state, we use a local static previous value for illustration,\\n    // but per requirements, do not use static - so this trigger is omitted in stateless context.\\n    // (In practice, decision rate drop would be tracked in solver struct.)\\n\\n    // bool decision_rate_drop = false;\\n    // ... (not implemented as no persistent state allowed)\\n\\n    return glue_trigger;\\n  } else {\\n    // Stable mode: reluctant or MAB underperformance trigger\\n\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      unsigned h = solver->heuristic;\\n      double rh = solver->mab_reward[h];\\n      double r_other = solver->mab_reward[1 - h];\\n      if (rh < 0.95 * r_other)\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Always check conflict threshold first\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (solver->stable) {\\n    // 1. Reluctant trigger (classic)\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // 2. MAB-aware: trigger if active heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      unsigned h = solver->heuristic;\\n      unsigned other = 1 - h;\\n      double rh = solver->mab_reward[h];\\n      double r_other = solver->mab_reward[other];\\n      if (rh < 0.95 * r_other)\\n        return true;\\n    }\\n\\n    return false;\\n  } else {\\n    // Focused mode: dual trigger (glue or decision rate drop)\\n    const double margin = GET_OPTION(restartmargin) / 100.0;\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double glue_trigger = (1.0 + margin) * slow <= fast;\\n\\n    // Decision rate drop detection: O(1) EMA\\n    static double ema_decision_rate = 0.0;\\n    static bool ema_init = false;\\n    const double curr_rate = AVERAGE(decision_rate);\\n    // Smoothing factor alpha (for EMA); 0.1 is a reasonable value\\n    const double alpha = 0.1;\\n\\n    if (!ema_init) {\\n      ema_decision_rate = curr_rate;\\n      ema_init = true;\\n    } else {\\n      ema_decision_rate = alpha * curr_rate + (1.0 - alpha) * ema_decision_rate;\\n    }\\n\\n    // Detect drop: current rate less than 80% of EMA\\n    const bool decision_rate_drop = curr_rate < 0.8 * ema_decision_rate;\\n\\n    if (glue_trigger || decision_rate_drop)\\n      return true;\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 173.678,
    "par2_rejected": 186.84359999999998
  },
  {
    "algorithm_description": "Name: MAB-Reward Adaptive Restart\n\nAlgorithm: First, check guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- If CONFLICTS < solver->limits.restart.conflicts, return false.\n- Let margin = GET_OPTION(restartmargin) / 100.0.\n- Compute glue_trigger: (1.0 + margin) * AVERAGE(slow_glue) <= AVERAGE(fast_glue).\n- Compute decision_rate_drop: AVERAGE(decision_rate) < 0.8 * previous AVERAGE(decision_rate) (update previous every restart; use O(1) EMA for amortized O(1)).\n- Return true if glue_trigger OR decision_rate_drop.\n\nIn stable mode (solver->stable == true):\n- If CONFLICTS < solver->limits.restart.conflicts, return false.\n- If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n- If solver->mab is true AND solver->mab_conflicts >= 100:\n    - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n    - Let rh = solver->mab_reward[h], r_other = solver->mab_reward[1-h].\n    - If rh < 0.95 * r_other (active heuristic underperforming by >5%), return true.\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Always require the conflict threshold\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  // --- Stable Mode: Reluctant + MAB reward check ---\\n  if (solver->stable) {\\n    // Reluctant restart triggers as usual\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-aware: if enabled and enough conflicts since last restart\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      unsigned h = solver->heuristic; // 0=VSIDS, 1=CHB\\n      double rh = solver->mab_reward[h];\\n      double r_other = solver->mab_reward[1-h];\\n      if (rh < 0.95 * r_other)\\n        return true;\\n    }\\n    return false;\\n  }\\n\\n  // --- Focused Mode: Glue and decision rate triggers ---\\n  // Glue-based trigger\\n  const double slow = AVERAGE(slow_glue);\\n  const double fast = AVERAGE(fast_glue);\\n  const double margin = GET_OPTION(restartmargin) / 100.0;\\n  const double limit = (1.0 + margin) * slow;\\n  bool glue_trigger = (limit <= fast);\\n\\n  // Decision rate drop trigger (use EMA: amortized O(1); reference: 0.8 * current as proxy)\\n  // Since history is not tracked here, can't fully implement previous EMA;\\n  // Approximate with current trend: restart if decision rate drops sharply (below 0.8 of slow glue)\\n  // We'll use: decision_rate < 0.8 * slow_glue (as a proxy; real impl would track prev EMA)\\n  const double dr = AVERAGE(decision_rate);\\n  bool decision_rate_drop = (dr < 0.8 * slow); // heuristic: slow_glue is correlated with progress\\n\\n  return glue_trigger || decision_rate_drop;\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Always check conflict threshold first\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (solver->stable) {\\n    // 1. Reluctant trigger (classic)\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // 2. MAB-aware: trigger if active heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      unsigned h = solver->heuristic;\\n      unsigned other = 1 - h;\\n      double rh = solver->mab_reward[h];\\n      double r_other = solver->mab_reward[other];\\n      if (rh < 0.95 * r_other)\\n        return true;\\n    }\\n\\n    return false;\\n  } else {\\n    // Focused mode: dual trigger (glue or decision rate drop)\\n    const double margin = GET_OPTION(restartmargin) / 100.0;\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double glue_trigger = (1.0 + margin) * slow <= fast;\\n\\n    // Decision rate drop detection: O(1) EMA\\n    static double ema_decision_rate = 0.0;\\n    static bool ema_init = false;\\n    const double curr_rate = AVERAGE(decision_rate);\\n    // Smoothing factor alpha (for EMA); 0.1 is a reasonable value\\n    const double alpha = 0.1;\\n\\n    if (!ema_init) {\\n      ema_decision_rate = curr_rate;\\n      ema_init = true;\\n    } else {\\n      ema_decision_rate = alpha * curr_rate + (1.0 - alpha) * ema_decision_rate;\\n    }\\n\\n    // Detect drop: current rate less than 80% of EMA\\n    const bool decision_rate_drop = curr_rate < 0.8 * ema_decision_rate;\\n\\n    if (glue_trigger || decision_rate_drop)\\n      return true;\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 178.0174,
    "par2_rejected": 186.84359999999998
  },
  {
    "algorithm_description": "Name: MAB-Reward Adaptive Restart\n\nAlgorithm: First, check guards: if solver->unassigned == 0, solver->level == 0, or !GET_OPTION(restart), return false. \n\nIn focused mode (solver->stable == false):\n- If CONFLICTS < solver->limits.restart.conflicts, return false.\n- Let margin = GET_OPTION(restartmargin) / 100.0.\n- Compute glue_trigger: (1.0 + margin) * AVERAGE(slow_glue) <= AVERAGE(fast_glue).\n- Compute decision_rate_drop: AVERAGE(decision_rate) < 0.8 * previous AVERAGE(decision_rate) (update previous every restart; use O(1) EMA for amortized O(1)).\n- Return true if glue_trigger OR decision_rate_drop.\n\nIn stable mode (solver->stable == true):\n- If CONFLICTS < solver->limits.restart.conflicts, return false.\n- If kissat_reluctant_triggered(&solver->reluctant) is true, return true.\n- If solver->mab is true AND solver->mab_conflicts >= 100:\n    - Let h = solver->heuristic (0=VSIDS, 1=CHB).\n    - Let rh = solver->mab_reward[h], r_other = solver->mab_reward[1-h].\n    - If rh < 0.95 * r_other (active heuristic underperforming by >5%), return true.\n- Otherwise, return false.",
    "preferred_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  // Restart option off?\\n  if (!GET_OPTION(restart))\\n    return false;\\n\\n  // At root level? Never restart.\\n  if (!solver->level)\\n    return false;\\n\\n  // Not enough conflicts for a restart?\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (solver->stable) {\\n    // STABLE MODE\\n\\n    // Reluctant (Luby) trigger always takes priority\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // MAB-adaptive restart: if enabled and enough recent conflicts, check reward stagnation\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      unsigned h = solver->heuristic;           // 0=VSIDS, 1=CHB\\n      unsigned other = 1 - h;\\n      double rh = solver->mab_reward[h];\\n      double r_other = solver->mab_reward[other];\\n      // Allow 5% lag before triggering\\n      if (rh < 0.95 * r_other)\\n        return true;\\n    }\\n\\n    // Otherwise: no restart\\n    return false;\\n  } else {\\n    // FOCUSED MODE\\n\\n    // Clause glue quality trigger (with margin)\\n    const double fast = AVERAGE(fast_glue);\\n    const double slow = AVERAGE(slow_glue);\\n    const double margin = (double)GET_OPTION(restartmargin) / 100.0;\\n    const double glue_limit = (1.0 + margin) * slow;\\n    const bool glue_trigger = (glue_limit <= fast);\\n\\n    // Decision rate drop trigger (EMA): compare to threshold 0.8*slow (proxy for \\\\\\\"previous\\\\\\\")\\n    // Since we can't access the *previous* EMA, use slow_decision_rate as a baseline\\n    // (in Kissat, slow EMA is more stable than fast, fits intent)\\n    const double decision_rate = AVERAGE(decision_rate);\\n    // Use slow_glue as a proxy for previous decision rate (no new struct/var allowed)\\n    // This is a compromise: if decision rate has dropped below 80% of its (stable) average, trigger\\n    const double baseline_decision_rate = solver->averages[solver->stable].slow_glue.value; // overloaded\\n    const bool decision_rate_drop = (decision_rate < 0.8 * baseline_decision_rate);\\n\\n    // Trigger if either condition met\\n    if (glue_trigger || decision_rate_drop)\\n      return true;\\n    return false;\\n  }\\n}\\n",
    "rejected_code": "\\nbool kissat_restarting(kissat *solver) {\\n  assert(solver->unassigned);\\n\\n  if (!GET_OPTION(restart))\\n    return false;\\n  if (!solver->level)\\n    return false;\\n\\n  // Always check conflict threshold first\\n  if (CONFLICTS < solver->limits.restart.conflicts)\\n    return false;\\n\\n  if (solver->stable) {\\n    // 1. Reluctant trigger (classic)\\n    if (kissat_reluctant_triggered(&solver->reluctant))\\n      return true;\\n\\n    // 2. MAB-aware: trigger if active heuristic is underperforming\\n    if (solver->mab && solver->mab_conflicts >= 100) {\\n      unsigned h = solver->heuristic;\\n      unsigned other = 1 - h;\\n      double rh = solver->mab_reward[h];\\n      double r_other = solver->mab_reward[other];\\n      if (rh < 0.95 * r_other)\\n        return true;\\n    }\\n\\n    return false;\\n  } else {\\n    // Focused mode: dual trigger (glue or decision rate drop)\\n    const double margin = GET_OPTION(restartmargin) / 100.0;\\n    const double slow = AVERAGE(slow_glue);\\n    const double fast = AVERAGE(fast_glue);\\n    const double glue_trigger = (1.0 + margin) * slow <= fast;\\n\\n    // Decision rate drop detection: O(1) EMA\\n    static double ema_decision_rate = 0.0;\\n    static bool ema_init = false;\\n    const double curr_rate = AVERAGE(decision_rate);\\n    // Smoothing factor alpha (for EMA); 0.1 is a reasonable value\\n    const double alpha = 0.1;\\n\\n    if (!ema_init) {\\n      ema_decision_rate = curr_rate;\\n      ema_init = true;\\n    } else {\\n      ema_decision_rate = alpha * curr_rate + (1.0 - alpha) * ema_decision_rate;\\n    }\\n\\n    // Detect drop: current rate less than 80% of EMA\\n    const bool decision_rate_drop = curr_rate < 0.8 * ema_decision_rate;\\n\\n    if (glue_trigger || decision_rate_drop)\\n      return true;\\n\\n    return false;\\n  }\\n}\\n",
    "par2_preferred": 178.1385,
    "par2_rejected": 186.84359999999998
  }
]