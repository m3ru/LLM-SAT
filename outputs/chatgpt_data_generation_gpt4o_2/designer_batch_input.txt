{"custom_id": "req-0001", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are an AI researcher specializing in CDCL restart policies. Propose a new restart policy algorithm for the Kissat SAT solver.\n\nA SAT solver’s restart policy controls when the solver abandons its current search path and begins a fresh search. The idea is that, instead of staying too long in an unproductive part of the search space, the solver resets to a clean state while keeping learned clauses. Restarts are triggered according to predefined rules—such as fixed intervals, geometric growth, or activity-based signals—so the solver can explore new regions more effectively and avoid getting stuck.\n\nYou should start by thinking what defines a good restart policy, and how to make a good restart policy.\n\n### Task\nDesign a restart policy (conceptual, not code) to maximize solver performance (solved instances, PAR-2). Your policy must:\n- Define a restart trigger/score and when a restart fires.\n- Provide quantitative rules and tie-breakers.\n- Run in O(1) or O(log n) per conflict.\n- Use only the signals listed below.\n- Include a brief rationale for expected gains.\n\n### Available Internal Signals\n- is stable stage — source: solver->stable\n- level — source: solver->level\n- number of conflicts — source: solver->statistics.conflicts\n- number of decisions — source: solver->statistics.decisions\n- limit of conflicts — source: solver->limits.restart.conflicts\n- fast averge of glue — source: solver->averages[solver->stable].fast_glue.value\n- slow averge of glue — source: solver->averages[solver->stable].slow_glue.value\n- decision rate moving average — source: solver->averages[solver->stable].decision_rate.value\n\n### Output Format (JSON only)\n1. Algorithm Name – concise title\n2. Algorithm\n3. Reason – argue why this is a good restart policy, keet this short\n\n### Constraints\n- Use only the listed signals.\n- Keep explanations formal, concise, algorithmic.\n\n### Final Instruction\nAct as a SAT-solver algorithm designer. Produce a single, self-contained restart policy description implementable inside Kissat’s restart logic.\n"}], "temperature": 0.7}}
{"custom_id": "req-0002", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are an AI researcher specializing in CDCL restart policies. Propose a new restart policy algorithm for the Kissat SAT solver.\n\nA SAT solver’s restart policy controls when the solver abandons its current search path and begins a fresh search. The idea is that, instead of staying too long in an unproductive part of the search space, the solver resets to a clean state while keeping learned clauses. Restarts are triggered according to predefined rules—such as fixed intervals, geometric growth, or activity-based signals—so the solver can explore new regions more effectively and avoid getting stuck.\n\nYou should start by thinking what defines a good restart policy, and how to make a good restart policy.\n\n### Task\nDesign a restart policy (conceptual, not code) to maximize solver performance (solved instances, PAR-2). Your policy must:\n- Define a restart trigger/score and when a restart fires.\n- Provide quantitative rules and tie-breakers.\n- Run in O(1) or O(log n) per conflict.\n- Use only the signals listed below.\n- Include a brief rationale for expected gains.\n\n### Available Internal Signals\n- is stable stage — source: solver->stable\n- level — source: solver->level\n- number of conflicts — source: solver->statistics.conflicts\n- number of decisions — source: solver->statistics.decisions\n- limit of conflicts — source: solver->limits.restart.conflicts\n- fast averge of glue — source: solver->averages[solver->stable].fast_glue.value\n- slow averge of glue — source: solver->averages[solver->stable].slow_glue.value\n- decision rate moving average — source: solver->averages[solver->stable].decision_rate.value\n\n### Output Format (JSON only)\n1. Algorithm Name – concise title\n2. Algorithm\n3. Reason – argue why this is a good restart policy, keet this short\n\n### Constraints\n- Use only the listed signals.\n- Keep explanations formal, concise, algorithmic.\n\n### Final Instruction\nAct as a SAT-solver algorithm designer. Produce a single, self-contained restart policy description implementable inside Kissat’s restart logic.\n"}], "temperature": 0.7}}
{"custom_id": "req-0003", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are an AI researcher specializing in CDCL restart policies. Propose a new restart policy algorithm for the Kissat SAT solver.\n\nA SAT solver’s restart policy controls when the solver abandons its current search path and begins a fresh search. The idea is that, instead of staying too long in an unproductive part of the search space, the solver resets to a clean state while keeping learned clauses. Restarts are triggered according to predefined rules—such as fixed intervals, geometric growth, or activity-based signals—so the solver can explore new regions more effectively and avoid getting stuck.\n\nYou should start by thinking what defines a good restart policy, and how to make a good restart policy.\n\n### Task\nDesign a restart policy (conceptual, not code) to maximize solver performance (solved instances, PAR-2). Your policy must:\n- Define a restart trigger/score and when a restart fires.\n- Provide quantitative rules and tie-breakers.\n- Run in O(1) or O(log n) per conflict.\n- Use only the signals listed below.\n- Include a brief rationale for expected gains.\n\n### Available Internal Signals\n- is stable stage — source: solver->stable\n- level — source: solver->level\n- number of conflicts — source: solver->statistics.conflicts\n- number of decisions — source: solver->statistics.decisions\n- limit of conflicts — source: solver->limits.restart.conflicts\n- fast averge of glue — source: solver->averages[solver->stable].fast_glue.value\n- slow averge of glue — source: solver->averages[solver->stable].slow_glue.value\n- decision rate moving average — source: solver->averages[solver->stable].decision_rate.value\n\n### Output Format (JSON only)\n1. Algorithm Name – concise title\n2. Algorithm\n3. Reason – argue why this is a good restart policy, keet this short\n\n### Constraints\n- Use only the listed signals.\n- Keep explanations formal, concise, algorithmic.\n\n### Final Instruction\nAct as a SAT-solver algorithm designer. Produce a single, self-contained restart policy description implementable inside Kissat’s restart logic.\n"}], "temperature": 0.7}}
{"custom_id": "req-0004", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are an AI researcher specializing in CDCL restart policies. Propose a new restart policy algorithm for the Kissat SAT solver.\n\nA SAT solver’s restart policy controls when the solver abandons its current search path and begins a fresh search. The idea is that, instead of staying too long in an unproductive part of the search space, the solver resets to a clean state while keeping learned clauses. Restarts are triggered according to predefined rules—such as fixed intervals, geometric growth, or activity-based signals—so the solver can explore new regions more effectively and avoid getting stuck.\n\nYou should start by thinking what defines a good restart policy, and how to make a good restart policy.\n\n### Task\nDesign a restart policy (conceptual, not code) to maximize solver performance (solved instances, PAR-2). Your policy must:\n- Define a restart trigger/score and when a restart fires.\n- Provide quantitative rules and tie-breakers.\n- Run in O(1) or O(log n) per conflict.\n- Use only the signals listed below.\n- Include a brief rationale for expected gains.\n\n### Available Internal Signals\n- is stable stage — source: solver->stable\n- level — source: solver->level\n- number of conflicts — source: solver->statistics.conflicts\n- number of decisions — source: solver->statistics.decisions\n- limit of conflicts — source: solver->limits.restart.conflicts\n- fast averge of glue — source: solver->averages[solver->stable].fast_glue.value\n- slow averge of glue — source: solver->averages[solver->stable].slow_glue.value\n- decision rate moving average — source: solver->averages[solver->stable].decision_rate.value\n\n### Output Format (JSON only)\n1. Algorithm Name – concise title\n2. Algorithm\n3. Reason – argue why this is a good restart policy, keet this short\n\n### Constraints\n- Use only the listed signals.\n- Keep explanations formal, concise, algorithmic.\n\n### Final Instruction\nAct as a SAT-solver algorithm designer. Produce a single, self-contained restart policy description implementable inside Kissat’s restart logic.\n"}], "temperature": 0.7}}
{"custom_id": "req-0005", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are an AI researcher specializing in CDCL restart policies. Propose a new restart policy algorithm for the Kissat SAT solver.\n\nA SAT solver’s restart policy controls when the solver abandons its current search path and begins a fresh search. The idea is that, instead of staying too long in an unproductive part of the search space, the solver resets to a clean state while keeping learned clauses. Restarts are triggered according to predefined rules—such as fixed intervals, geometric growth, or activity-based signals—so the solver can explore new regions more effectively and avoid getting stuck.\n\nYou should start by thinking what defines a good restart policy, and how to make a good restart policy.\n\n### Task\nDesign a restart policy (conceptual, not code) to maximize solver performance (solved instances, PAR-2). Your policy must:\n- Define a restart trigger/score and when a restart fires.\n- Provide quantitative rules and tie-breakers.\n- Run in O(1) or O(log n) per conflict.\n- Use only the signals listed below.\n- Include a brief rationale for expected gains.\n\n### Available Internal Signals\n- is stable stage — source: solver->stable\n- level — source: solver->level\n- number of conflicts — source: solver->statistics.conflicts\n- number of decisions — source: solver->statistics.decisions\n- limit of conflicts — source: solver->limits.restart.conflicts\n- fast averge of glue — source: solver->averages[solver->stable].fast_glue.value\n- slow averge of glue — source: solver->averages[solver->stable].slow_glue.value\n- decision rate moving average — source: solver->averages[solver->stable].decision_rate.value\n\n### Output Format (JSON only)\n1. Algorithm Name – concise title\n2. Algorithm\n3. Reason – argue why this is a good restart policy, keet this short\n\n### Constraints\n- Use only the listed signals.\n- Keep explanations formal, concise, algorithmic.\n\n### Final Instruction\nAct as a SAT-solver algorithm designer. Produce a single, self-contained restart policy description implementable inside Kissat’s restart logic.\n"}], "temperature": 0.7}}
