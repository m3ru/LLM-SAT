{"id": "batch_req_6922258f2bfc81908f1799aacbc0291e", "custom_id": "req-0001", "response": {"status_code": 200, "request_id": "dc35ae2979fabf1d3d1d2fa1f22e2a8b", "body": {"id": "resp_068063fb8dbdf3df006922257a69148196a307230c18ba13a7", "object": "response", "created_at": 1763845498, "status": "completed", "background": false, "billing": {"payer": "developer"}, "error": null, "incomplete_details": null, "instructions": null, "max_output_tokens": null, "max_tool_calls": null, "model": "gpt-4.1-2025-04-14", "output": [{"id": "msg_068063fb8dbdf3df006922257aa10081968e6829aa0281021b", "type": "message", "status": "completed", "content": [{"type": "output_text", "annotations": [], "logprobs": [], "text": "<code>\nbool kissat_restarting (kissat *solver) {\n  assert (solver->unassigned);\n  if (!GET_OPTION (restart))\n    return false;\n  if (!solver->level)\n    return false;\n\n  // Use the usual conflict counter and conflict limit\n  const uint64_t conflicts = solver->statistics.conflicts;\n  uint64_t *limitp = &solver->limits.restart.conflicts;\n\n  // Only apply the DGAR policy if in stable stage\n  if (solver->stable) {\n    // Retrieve fast/slow glue averages\n    const double fast = AVERAGE (fast_glue);\n    const double slow = AVERAGE (slow_glue);\n    const double ratio = slow ? (fast / slow) : 0.0;\n\n    // Decision rate: moving average for current stage\n    const double curr_decision_rate = AVERAGE (decision_rate);\n\n    // For D_prev, we need to store it somewhere persistent between calls and resets.\n    // Use the solver struct, as the restart.c code does for similar persistent values.\n    // We'll add a static variable here, but ideally this would be inside 'kissat' struct.\n    static double prev_decision_rate = 0.0;\n    static uint64_t prev_restart_conflicts = 0;\n\n    // On first call after initialization (or after a reset), initialize prev_decision_rate\n    // This is safe as a heuristic: only update after an actual restart\n    if (prev_restart_conflicts != *limitp) {\n      prev_restart_conflicts = *limitp;\n      prev_decision_rate = curr_decision_rate;\n    }\n\n    // Restart triggers:\n    bool glue_stagnation = (ratio > 1.05);\n    bool decision_slow = (curr_decision_rate < 0.95 * prev_decision_rate);\n\n    if ((glue_stagnation || decision_slow) && (conflicts >= *limitp)) {\n      // On restart: update prev_decision_rate and increase conflict limit geometrically\n      prev_decision_rate = curr_decision_rate;\n      prev_restart_conflicts = *limitp;\n      // Increase conflict limit by geometric factor (e.g. 1.2)\n      uint64_t new_limit = *limitp + (uint64_t)((double)(*limitp) * 0.2) + 1;\n      // Avoid overflow or zero\n      if (new_limit <= *limitp) new_limit = *limitp + 1;\n      *limitp = new_limit;\n\n      kissat_extremely_verbose(solver,\n        \"DGAR restart: glue ratio=%.3f (%.3f/%.3f), dec_rate=%.3f prev=%.3f, next_limit=%\" PRIu64,\n        ratio, fast, slow, curr_decision_rate, prev_decision_rate, *limitp);\n\n      return true;\n    }\n    return false;\n  }\n\n  // If not stable, fallback to fixed conflict-limited restart (classic Kissat policy)\n  if (conflicts < *limitp)\n    return false;\n  return kissat_reluctant_triggered (&solver->reluctant);\n}\n</code>"}], "role": "assistant"}], "parallel_tool_calls": true, "previous_response_id": null, "prompt_cache_key": null, "prompt_cache_retention": null, "reasoning": {"effort": null, "summary": null}, "safety_identifier": null, "service_tier": "default", "store": true, "temperature": 0.7, "text": {"format": {"type": "text"}, "verbosity": "medium"}, "tool_choice": "auto", "tools": [], "top_logprobs": 0, "top_p": 1.0, "truncation": "disabled", "usage": {"input_tokens": 1421, "input_tokens_details": {"cached_tokens": 0}, "output_tokens": 664, "output_tokens_details": {"reasoning_tokens": 0}, "total_tokens": 2085}, "user": null, "metadata": {}}}, "error": null}
{"id": "batch_req_6922258f3d288190ac168e546adb5a7a", "custom_id": "req-0002", "response": {"status_code": 200, "request_id": "969856b46684c61281ed5b88eb3e3d1d", "body": {"id": "resp_090312c878a1907f006922253aaa4c8195a24f07239f883efc", "object": "response", "created_at": 1763845434, "status": "completed", "background": false, "billing": {"payer": "developer"}, "error": null, "incomplete_details": null, "instructions": null, "max_output_tokens": null, "max_tool_calls": null, "model": "gpt-4.1-2025-04-14", "output": [{"id": "msg_090312c878a1907f006922253afa448195a7bf51415852afbd", "type": "message", "status": "completed", "content": [{"type": "output_text", "annotations": [], "logprobs": [], "text": "<code>\nbool kissat_restarting (kissat *solver)\n{\n  assert (solver->unassigned);\n  if (!GET_OPTION (restart))\n    return false;\n  if (!solver->level)\n    return false;\n\n  const uint64_t conflicts = solver->statistics.conflicts;\n  uint64_t *conflict_limit = &solver->limits.restart.conflicts;\n\n  if (solver->stable)\n  {\n    // --- Dynamic Glue-Decision Adaptive Restart (DGAR) ---\n\n    // 1. Compute the glue ratio: R = fast_glue / slow_glue.\n    const double fast_glue = solver->averages[solver->stable].fast_glue.value;\n    const double slow_glue = solver->averages[solver->stable].slow_glue.value;\n    const double glue_ratio = slow_glue > 0.0 ? (fast_glue / slow_glue) : 1.0;\n\n    // 2. Get current decision rate D.\n    const double curr_decision_rate = solver->averages[solver->stable].decision_rate.value;\n\n    // 3. Retrieve previous decision rate D_prev (at last restart).\n    double *prev_decision_rate_ptr = &solver->averages[solver->stable].decision_rate_prev;\n    double prev_decision_rate = *prev_decision_rate_ptr;\n\n    // 4. Compute decision rate drop.\n    const double decision_rate_threshold = 0.95 * prev_decision_rate;\n    const bool decision_rate_stagnant = curr_decision_rate < decision_rate_threshold;\n\n    // 5. Stagnation signals.\n    const bool glue_stagnant = glue_ratio > 1.05;\n\n    // 6. Restart trigger logic.\n    if ((glue_stagnant || decision_rate_stagnant) && conflicts >= *conflict_limit)\n    {\n      // 7. On restart: update prev_decision_rate and conflict limit (geometric factor).\n      *prev_decision_rate_ptr = curr_decision_rate;\n      *conflict_limit = conflicts + (uint64_t) (GET_OPTION (restartint) * 1.2);\n      kissat_extremely_verbose (solver,\n        \"DGAR restart: glue_ratio=%.3f (%.3f/%.3f), decision_rate=%.3f prev=%.3f, new conflict_limit=%\" PRIu64,\n        glue_ratio, fast_glue, slow_glue, curr_decision_rate, prev_decision_rate, *conflict_limit\n      );\n      return true;\n    }\n    // Not restarting.\n    return false;\n  }\n  else\n  {\n    // Non-stable: fallback to fixed conflict limit restart.\n    if (conflicts < *conflict_limit)\n      return false;\n    // After triggering, increase limit for next time (classic geometric update).\n    *conflict_limit = conflicts + (uint64_t) (GET_OPTION (restartint) * 1.2);\n    kissat_extremely_verbose (solver,\n      \"non-stable restart at conflicts=%\" PRIu64 \", new conflict_limit=%\" PRIu64,\n      conflicts, *conflict_limit\n    );\n    return true;\n  }\n}\n</code>"}], "role": "assistant"}], "parallel_tool_calls": true, "previous_response_id": null, "prompt_cache_key": null, "prompt_cache_retention": null, "reasoning": {"effort": null, "summary": null}, "safety_identifier": null, "service_tier": "default", "store": true, "temperature": 0.7, "text": {"format": {"type": "text"}, "verbosity": "medium"}, "tool_choice": "auto", "tools": [], "top_logprobs": 0, "top_p": 1.0, "truncation": "disabled", "usage": {"input_tokens": 1421, "input_tokens_details": {"cached_tokens": 0}, "output_tokens": 666, "output_tokens_details": {"reasoning_tokens": 0}, "total_tokens": 2087}, "user": null, "metadata": {}}}, "error": null}
{"id": "batch_req_6922258f3c688190a145a22c4e41cdbf", "custom_id": "req-0003", "response": {"status_code": 200, "request_id": "213c25a1e5fa15b0b45ce55b88ed642f", "body": {"id": "resp_052b1b815770d04b006922258047a4819089275d538aea2c28", "object": "response", "created_at": 1763845504, "status": "completed", "background": false, "billing": {"payer": "developer"}, "error": null, "incomplete_details": null, "instructions": null, "max_output_tokens": null, "max_tool_calls": null, "model": "gpt-4.1-2025-04-14", "output": [{"id": "msg_052b1b815770d04b00692225809ae88190bd67dd052f0854b6", "type": "message", "status": "completed", "content": [{"type": "output_text", "annotations": [], "logprobs": [], "text": "<code>\nbool kissat_restarting(kissat *solver) {\n  assert(solver->unassigned);\n\n  if (!GET_OPTION(restart))\n    return false;\n\n  if (!solver->level)\n    return false;\n\n  // Only apply this adaptive policy in stable mode; otherwise fallback.\n  if (!solver->stable) {\n    if (CONFLICTS < solver->limits.restart.conflicts)\n      return false;\n    return kissat_reluctant_triggered(&solver->reluctant);\n  }\n\n  // --- Dynamic Glue-Decision Adaptive Restart (DGAR) ---\n\n  // Get fast and slow glue averages\n  const double fast_glue = AVERAGE(fast_glue);\n  const double slow_glue = AVERAGE(slow_glue);\n\n  // Compute glue ratio\n  const double glue_ratio = slow_glue > 0.0 ? fast_glue / slow_glue : 0.0;\n\n  // Get current decision rate moving average\n  const double decision_rate = AVERAGE(decision_rate);\n\n  // Use solver->restart_decision_rate_prev to store D_prev (initialize on first call)\n  if (!solver->restart_initialized) {\n    solver->restart_decision_rate_prev = decision_rate;\n    solver->restart_initialized = true;\n  }\n\n  // Check if enough conflicts since last restart\n  if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n\n  // Reason a: Glue ratio high\n  const bool glue_stagnation = (glue_ratio > 1.05);\n\n  // Reason b: Decision rate drop\n  const bool decision_stagnation = (decision_rate < 0.95 * solver->restart_decision_rate_prev);\n\n  // If either signal triggers, restart\n  if (glue_stagnation || decision_stagnation) {\n    kissat_extremely_verbose(\n      solver,\n      \"DGAR restart: glue_ratio=%.3f (fast=%.3f, slow=%.3f), \"\n      \"decision_rate=%.3f, prev=%.3f, stagnation=%s%s\",\n      glue_ratio, fast_glue, slow_glue,\n      decision_rate, solver->restart_decision_rate_prev,\n      glue_stagnation ? \"GLUE \" : \"\",\n      decision_stagnation ? \"DECISION\" : \"\");\n\n    // Update previous decision rate to current\n    solver->restart_decision_rate_prev = decision_rate;\n\n    // Geometrically increase restart conflict limit to avoid too frequent restarts\n    solver->limits.restart.conflicts = CONFLICTS + (uint64_t)(GET_OPTION(restartint) * 1.2);\n\n    return true;\n  }\n\n  return false;\n}\n</code>"}], "role": "assistant"}], "parallel_tool_calls": true, "previous_response_id": null, "prompt_cache_key": null, "prompt_cache_retention": null, "reasoning": {"effort": null, "summary": null}, "safety_identifier": null, "service_tier": "default", "store": true, "temperature": 0.7, "text": {"format": {"type": "text"}, "verbosity": "medium"}, "tool_choice": "auto", "tools": [], "top_logprobs": 0, "top_p": 1.0, "truncation": "disabled", "usage": {"input_tokens": 1421, "input_tokens_details": {"cached_tokens": 0}, "output_tokens": 563, "output_tokens_details": {"reasoning_tokens": 0}, "total_tokens": 1984}, "user": null, "metadata": {}}}, "error": null}
{"id": "batch_req_6922258f361c8190bcceb92e6714701a", "custom_id": "req-0004", "response": {"status_code": 200, "request_id": "a8a4addbd908131d37e09d7af06ca8e3", "body": {"id": "resp_0a38d46f18a9711d0069222584a23c8194acafa872ca534351", "object": "response", "created_at": 1763845508, "status": "completed", "background": false, "billing": {"payer": "developer"}, "error": null, "incomplete_details": null, "instructions": null, "max_output_tokens": null, "max_tool_calls": null, "model": "gpt-4.1-2025-04-14", "output": [{"id": "msg_0a38d46f18a9711d0069222584e1b8819498d4911b34f1a867", "type": "message", "status": "completed", "content": [{"type": "output_text", "annotations": [], "logprobs": [], "text": "<code>\nbool kissat_restarting (kissat *solver) {\n  assert (solver->unassigned);\n  if (!GET_OPTION (restart))\n    return false;\n  if (!solver->level)\n    return false;\n\n  // Only apply advanced policy in stable mode, else fallback to fixed conflict limit\n  if (!solver->stable) {\n    if (CONFLICTS < solver->limits.restart.conflicts)\n      return false;\n    return true;\n  }\n\n  // Retrieve averages for glue and decision rate\n  const double fast_glue = AVERAGE (fast_glue);\n  const double slow_glue = AVERAGE (slow_glue);\n  const double glue_ratio = slow_glue > 0 ? fast_glue / slow_glue : 0.0;\n  const double decision_rate = AVERAGE (decision_rate);\n\n  // Persistent storage for previous decision rate\n  static double prev_decision_rate = 0.0;\n  static int prev_decision_rate_valid = 0;\n\n  // Decision rate drop threshold\n  const double decision_rate_drop_threshold = 0.95;\n\n  // Conflict limit check\n  if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n\n  // Compute glue stagnation and decision stagnation signals\n  bool glue_stagnation = glue_ratio > 1.05;\n  bool decision_stagnation = 0;\n\n  if (prev_decision_rate_valid) {\n    decision_stagnation = decision_rate < decision_rate_drop_threshold * prev_decision_rate;\n  }\n\n  if (glue_stagnation || decision_stagnation) {\n    // On restart: update prev_decision_rate and raise conflict limit geometrically\n    prev_decision_rate = decision_rate;\n    prev_decision_rate_valid = 1;\n    // Increase the conflict limit for the next restart (geometric growth, e.g., 1.2x)\n    solver->limits.restart.conflicts = CONFLICTS + (size_t)((solver->limits.restart.conflicts - CONFLICTS) * 1.2);\n    kissat_extremely_verbose (solver,\n      \"DGAR restart triggered (glue_ratio=%.3f %s 1.05, decision_rate=%.3f, prev=%.3f, stagnation=%d/%d, next_limit=%zu)\",\n      glue_ratio, glue_stagnation ? \">\" : \"<=\",\n      decision_rate, prev_decision_rate, glue_stagnation, decision_stagnation,\n      solver->limits.restart.conflicts);\n    return true;\n  }\n\n  return false;\n}\n</code>"}], "role": "assistant"}], "parallel_tool_calls": true, "previous_response_id": null, "prompt_cache_key": null, "prompt_cache_retention": null, "reasoning": {"effort": null, "summary": null}, "safety_identifier": null, "service_tier": "default", "store": true, "temperature": 0.7, "text": {"format": {"type": "text"}, "verbosity": "medium"}, "tool_choice": "auto", "tools": [], "top_logprobs": 0, "top_p": 1.0, "truncation": "disabled", "usage": {"input_tokens": 1421, "input_tokens_details": {"cached_tokens": 0}, "output_tokens": 540, "output_tokens_details": {"reasoning_tokens": 0}, "total_tokens": 1961}, "user": null, "metadata": {}}}, "error": null}
{"id": "batch_req_6922258f3384819088df5b25a6699c07", "custom_id": "req-0005", "response": {"status_code": 200, "request_id": "e7c9a63a0b8977c33c85fffdb9c2f6b0", "body": {"id": "resp_0d839b67aa58156d006922258929d48194a187e74c5ab28e4c", "object": "response", "created_at": 1763845513, "status": "completed", "background": false, "billing": {"payer": "developer"}, "error": null, "incomplete_details": null, "instructions": null, "max_output_tokens": null, "max_tool_calls": null, "model": "gpt-4.1-2025-04-14", "output": [{"id": "msg_0d839b67aa58156d006922258979208194bdec4f5cff95e11f", "type": "message", "status": "completed", "content": [{"type": "output_text", "annotations": [], "logprobs": [], "text": "<code>\nbool kissat_restarting (kissat *solver) {\n  assert (solver->unassigned);\n  if (!GET_OPTION (restart))\n    return false;\n  if (!solver->level)\n    return false;\n\n  // If not in stable phase, fallback to fixed conflict limit based restart\n  if (!solver->stable) {\n    if (CONFLICTS < solver->limits.restart.conflicts)\n      return false;\n    return kissat_reluctant_triggered (&solver->reluctant);\n  }\n\n  // --- DGAR: Dynamic Glue-Decision Adaptive Restart ---\n\n  // Compute glue ratio\n  const double fast = AVERAGE (fast_glue);\n  const double slow = AVERAGE (slow_glue);\n  const double glue_ratio = slow > 0 ? (fast / slow) : 0.0;\n\n  // Decision rate moving average\n  const double decision_rate = AVERAGE (decision_rate);\n\n  // Persistent storage for previous decision rate (across restarts)\n  double *d_prev_ptr = &solver->restart_d_prev;\n  // If not initialized (first run), initialize to current value\n  if (*d_prev_ptr == 0.0)\n    *d_prev_ptr = decision_rate;\n\n  bool glue_stagnation = (glue_ratio > 1.05);\n  bool dec_stagnation = (decision_rate < 0.95 * (*d_prev_ptr));\n\n  if ((glue_stagnation || dec_stagnation) &&\n      (CONFLICTS >= solver->limits.restart.conflicts)) {\n    // On restart: update d_prev and increase restart conflict limit geometrically\n    *d_prev_ptr = decision_rate;\n    solver->limits.restart.conflicts =\n      CONFLICTS + (uint64_t) (GET_OPTION (restartint) * 1.2);\n    kissat_extremely_verbose (\n      solver,\n      \"restarting: glue_ratio=%.3f (fast=%.3f, slow=%.3f),\"\n      \" decision_rate=%.3f, prev=%.3f, conflicts=%\" PRIu64 \", new limit=%\" PRIu64,\n      glue_ratio, fast, slow, decision_rate, *d_prev_ptr,\n      CONFLICTS, solver->limits.restart.conflicts);\n    return true;\n  }\n\n  return false;\n}\n</code>"}], "role": "assistant"}], "parallel_tool_calls": true, "previous_response_id": null, "prompt_cache_key": null, "prompt_cache_retention": null, "reasoning": {"effort": null, "summary": null}, "safety_identifier": null, "service_tier": "default", "store": true, "temperature": 0.7, "text": {"format": {"type": "text"}, "verbosity": "medium"}, "tool_choice": "auto", "tools": [], "top_logprobs": 0, "top_p": 1.0, "truncation": "disabled", "usage": {"input_tokens": 1421, "input_tokens_details": {"cached_tokens": 0}, "output_tokens": 488, "output_tokens_details": {"reasoning_tokens": 0}, "total_tokens": 1909}, "user": null, "metadata": {}}}, "error": null}
{"id": "batch_req_6922258f2c4481909adbf71b76ff43bd", "custom_id": "req-0006", "response": {"status_code": 200, "request_id": "52c1dc94aebdb375940dd01637b1714d", "body": {"id": "resp_0e6840d15942a58a006922253ac150819599bcd2f1867f493e", "object": "response", "created_at": 1763845434, "status": "completed", "background": false, "billing": {"payer": "developer"}, "error": null, "incomplete_details": null, "instructions": null, "max_output_tokens": null, "max_tool_calls": null, "model": "gpt-4.1-2025-04-14", "output": [{"id": "msg_0e6840d15942a58a006922253af3708195878eabed9ea19c85", "type": "message", "status": "completed", "content": [{"type": "output_text", "annotations": [], "logprobs": [], "text": "<code>\nbool kissat_restarting (kissat *solver) {\n  assert (solver->unassigned);\n  if (!GET_OPTION (restart))\n    return false;\n  if (!solver->level)\n    return false;\n\n  // Use static variables to persist D_prev between calls (per solver)\n  static double d_prev = 0.0;\n  static uint64_t last_restart_conflicts = 0;\n\n  const uint64_t conflicts = solver->statistics.conflicts;\n  const uint64_t conflict_limit = solver->limits.restart.conflicts;\n  const int stable = solver->stable;\n\n  const double fast_glue = AVERAGE (fast_glue);\n  const double slow_glue = AVERAGE (slow_glue);\n\n  // Defensive: avoid division by zero\n  double glue_ratio = (slow_glue > 0.0) ? (fast_glue / slow_glue) : 1.0;\n\n  // Decision rate\n  const double d = AVERAGE (decision_rate);\n\n  // Only run DGAR in stable mode\n  if (stable) {\n    // Initialize d_prev on first entry in stable mode or after restart\n    if (d_prev == 0.0)\n      d_prev = d;\n\n    bool glue_stagnation = glue_ratio > 1.05;\n    bool decision_stagnation = d < 0.95 * d_prev;\n\n    kissat_extremely_verbose (solver,\n      \"DGAR stable: glue_ratio=%.3f (%.2f/%.2f), decision_rate=%.2f, d_prev=%.2f, glue_stagnation=%d, decision_stagnation=%d, conflicts=%\" PRIu64 \"/%\" PRIu64,\n      glue_ratio, fast_glue, slow_glue, d, d_prev, glue_stagnation, decision_stagnation, conflicts, conflict_limit);\n\n    if ((glue_stagnation || decision_stagnation) && conflicts >= conflict_limit) {\n      // On restart: update d_prev, increase conflict limit geometrically\n      d_prev = d;\n      // Enforce geometric growth, but cap to avoid overflow\n      uint64_t new_limit = conflict_limit + (uint64_t)(conflict_limit * 0.2);\n      if (new_limit <= conflict_limit) // overflow guard\n        new_limit = conflict_limit + 1;\n      solver->limits.restart.conflicts = new_limit;\n      last_restart_conflicts = conflicts;\n      kissat_extremely_verbose (solver,\n        \"DGAR triggered restart: new conflict limit=%\" PRIu64,\n        solver->limits.restart.conflicts);\n      return true;\n    }\n    return false;\n  }\n\n  // Fallback: non-stable stage, use fixed conflict limit\n  if (conflicts < conflict_limit)\n    return false;\n\n  kissat_extremely_verbose (solver,\n    \"DGAR non-stable: conflicts %\" PRIu64 \" >= limit %\" PRIu64 \", restarting (fixed)\",\n    conflicts, conflict_limit);\n\n  // Increase the conflict limit geometrically only in fallback as well\n  uint64_t new_limit = conflict_limit + (uint64_t)(conflict_limit * 0.2);\n  if (new_limit <= conflict_limit) // overflow guard\n    new_limit = conflict_limit + 1;\n  solver->limits.restart.conflicts = new_limit;\n  last_restart_conflicts = conflicts;\n\n  return true;\n}\n</code>"}], "role": "assistant"}], "parallel_tool_calls": true, "previous_response_id": null, "prompt_cache_key": null, "prompt_cache_retention": null, "reasoning": {"effort": null, "summary": null}, "safety_identifier": null, "service_tier": "default", "store": true, "temperature": 0.7, "text": {"format": {"type": "text"}, "verbosity": "medium"}, "tool_choice": "auto", "tools": [], "top_logprobs": 0, "top_p": 1.0, "truncation": "disabled", "usage": {"input_tokens": 1421, "input_tokens_details": {"cached_tokens": 0}, "output_tokens": 714, "output_tokens_details": {"reasoning_tokens": 0}, "total_tokens": 2135}, "user": null, "metadata": {}}}, "error": null}
{"id": "batch_req_6922258f3b3c8190a17929dda06d24c7", "custom_id": "req-0007", "response": {"status_code": 200, "request_id": "1484fdb8022d46af6445e10ba8f91e91", "body": {"id": "resp_0b5005d3ae86c1ad006922253ac95c819783a2be480903d98f", "object": "response", "created_at": 1763845434, "status": "completed", "background": false, "billing": {"payer": "developer"}, "error": null, "incomplete_details": null, "instructions": null, "max_output_tokens": null, "max_tool_calls": null, "model": "gpt-4.1-2025-04-14", "output": [{"id": "msg_0b5005d3ae86c1ad00692225466224819799b71c79ea98da69", "type": "message", "status": "completed", "content": [{"type": "output_text", "annotations": [], "logprobs": [], "text": "<code>\nbool kissat_restarting (kissat *solver) {\n  assert (solver->unassigned);\n  if (!GET_OPTION (restart))\n    return false;\n  if (!solver->level)\n    return false;\n\n  // Only apply DGAR in stable phase\n  if (solver->stable) {\n    // Fetch current moving averages\n    const double fast = AVERAGE (fast_glue);\n    const double slow = AVERAGE (slow_glue);\n    const double glue_ratio = slow > 0 ? (fast / slow) : 0.0;\n    const double dec_rate = AVERAGE (decision_rate);\n\n    // Persistent storage for last decision rate at last restart\n    // This must be static or in solver struct (here, use solver struct)\n    // We'll use solver->dgar_prev_decision_rate to store D_prev\n    // Similarly, store last restart conflict limit in solver->dgar_prev_conflict_limit\n\n    // On first call, initialize D_prev if unset (use 0 as sentinel)\n    if (!solver->dgar_prev_decision_rate)\n      solver->dgar_prev_decision_rate = dec_rate;\n\n    bool glue_stagnation = (glue_ratio > 1.05);\n    bool decision_stagnation = (dec_rate < 0.95 * solver->dgar_prev_decision_rate);\n    bool enough_conflicts = (solver->statistics.conflicts >= solver->limits.restart.conflicts);\n\n    if ((glue_stagnation && enough_conflicts) ||\n        (decision_stagnation && enough_conflicts)) {\n      // Update D_prev to current rate for next epoch\n      solver->dgar_prev_decision_rate = dec_rate;\n      // Geometrically increase the restart conflict limit (e.g., *= 1.2, rounded up)\n      unsigned new_limit = (unsigned) ((double)solver->limits.restart.conflicts * 1.2 + 0.5);\n      // Avoid degenerate limit\n      if (new_limit <= solver->limits.restart.conflicts)\n        new_limit = solver->limits.restart.conflicts + 1;\n      solver->limits.restart.conflicts = solver->statistics.conflicts + new_limit;\n\n      kissat_extremely_verbose (solver,\n        \"DGAR triggered restart: glue_ratio=%.3f (fast=%.2f/slow=%.2f), dec_rate=%.2f prev=%.2f, new conflict limit=%u\",\n        glue_ratio, fast, slow, dec_rate, solver->dgar_prev_decision_rate, solver->limits.restart.conflicts);\n\n      return true;\n    }\n\n    // No restart this round\n    return false;\n  } else {\n    // Not stable: fallback to fixed conflict-based restart\n    if (solver->statistics.conflicts < solver->limits.restart.conflicts)\n      return false;\n    // Increase limit linearly to avoid too frequent restarts in non-stable phase\n    solver->limits.restart.conflicts = solver->statistics.conflicts +\n      GET_OPTION (restartint);\n    kissat_extremely_verbose (solver,\n      \"unstable phase: fixed restart after %u conflicts, new limit %u\",\n      GET_OPTION (restartint), solver->limits.restart.conflicts);\n    return true;\n  }\n}\n</code>"}], "role": "assistant"}], "parallel_tool_calls": true, "previous_response_id": null, "prompt_cache_key": null, "prompt_cache_retention": null, "reasoning": {"effort": null, "summary": null}, "safety_identifier": null, "service_tier": "default", "store": true, "temperature": 0.7, "text": {"format": {"type": "text"}, "verbosity": "medium"}, "tool_choice": "auto", "tools": [], "top_logprobs": 0, "top_p": 1.0, "truncation": "disabled", "usage": {"input_tokens": 1421, "input_tokens_details": {"cached_tokens": 0}, "output_tokens": 679, "output_tokens_details": {"reasoning_tokens": 0}, "total_tokens": 2100}, "user": null, "metadata": {}}}, "error": null}
{"id": "batch_req_6922258f389481908c4a217cc9ce7d17", "custom_id": "req-0008", "response": {"status_code": 200, "request_id": "dc1cd13be491c22751cef56c15758f11", "body": {"id": "resp_04179951e7a4ae0f006922253ac9fc81908018542f8b872dbc", "object": "response", "created_at": 1763845434, "status": "completed", "background": false, "billing": {"payer": "developer"}, "error": null, "incomplete_details": null, "instructions": null, "max_output_tokens": null, "max_tool_calls": null, "model": "gpt-4.1-2025-04-14", "output": [{"id": "msg_04179951e7a4ae0f006922253b08048190ad1655c3b0582a0b", "type": "message", "status": "completed", "content": [{"type": "output_text", "annotations": [], "logprobs": [], "text": "<code>\nbool kissat_restarting (kissat *solver) {\n  assert (solver->unassigned);\n\n  if (!GET_OPTION (restart))\n    return false;\n\n  if (!solver->level)\n    return false;\n\n  // Only apply DGAR policy in stable phase\n  if (solver->stable) {\n    // --- Get current glue averages\n    const double fast_glue = AVERAGE (fast_glue);\n    const double slow_glue = AVERAGE (slow_glue);\n\n    // --- Compute ratio R = fast_glue / slow_glue\n    double R = 1.0;\n    if (slow_glue > 0.0)\n      R = fast_glue / slow_glue;\n\n    // --- Get current decision rate moving average\n    const double decision_rate = AVERAGE (decision_rate);\n\n    // --- Static storage for previous decision rate\n    static double prev_decision_rate = -1.0;\n    static bool initialized = false;\n\n    // --- Only initialize prev_decision_rate at first call in this process\n    if (!initialized) {\n      prev_decision_rate = decision_rate;\n      initialized = true;\n    }\n\n    // --- Check stagnation signals\n    bool glue_stagnation = (R > 1.05);\n    bool rate_stagnation = (decision_rate < 0.95 * prev_decision_rate);\n    bool over_conflicts = (CONFLICTS >= solver->limits.restart.conflicts);\n\n    kissat_extremely_verbose (solver,\n      \"DGAR: R=%.4f (fast/slow glue), decision_rate=%.4f, prev=%.4f, conflicts=%\" PRIu64 \" limit=%\" PRIu64,\n      R, decision_rate, prev_decision_rate, CONFLICTS, solver->limits.restart.conflicts);\n\n    if (over_conflicts && (glue_stagnation || rate_stagnation)) {\n      kissat_extremely_verbose (solver,\n        \"DGAR: restarting (glue_stagnation=%d, rate_stagnation=%d), updating prev_decision_rate and conflict limit\",\n        glue_stagnation, rate_stagnation);\n\n      // --- Update previous decision rate for next window\n      prev_decision_rate = decision_rate;\n\n      // --- Increase conflict limit geometrically (limit *= 1.2)\n      solver->limits.restart.conflicts = CONFLICTS + (uint64_t)((solver->limits.restart.conflicts - CONFLICTS) * 1.2);\n\n      // Guarantee at least one conflict for next window\n      if (solver->limits.restart.conflicts <= CONFLICTS)\n        solver->limits.restart.conflicts = CONFLICTS + 1;\n\n      return true;\n    }\n    return false;\n  }\n\n  // Fallback for non-stable phase: fixed conflict restart\n  if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n\n  return true;\n}\n</code>"}], "role": "assistant"}], "parallel_tool_calls": true, "previous_response_id": null, "prompt_cache_key": null, "prompt_cache_retention": null, "reasoning": {"effort": null, "summary": null}, "safety_identifier": null, "service_tier": "default", "store": true, "temperature": 0.7, "text": {"format": {"type": "text"}, "verbosity": "medium"}, "tool_choice": "auto", "tools": [], "top_logprobs": 0, "top_p": 1.0, "truncation": "disabled", "usage": {"input_tokens": 1421, "input_tokens_details": {"cached_tokens": 0}, "output_tokens": 611, "output_tokens_details": {"reasoning_tokens": 0}, "total_tokens": 2032}, "user": null, "metadata": {}}}, "error": null}
{"id": "batch_req_6922258f3ee48190aaf8cf0bfbe59141", "custom_id": "req-0009", "response": {"status_code": 200, "request_id": "b359721d38180df4b470e4fabacaaef0", "body": {"id": "resp_0f18243dc8dfb5d3006922253aca1481948332e7c2d45a0bc0", "object": "response", "created_at": 1763845434, "status": "completed", "background": false, "billing": {"payer": "developer"}, "error": null, "incomplete_details": null, "instructions": null, "max_output_tokens": null, "max_tool_calls": null, "model": "gpt-4.1-2025-04-14", "output": [{"id": "msg_0f18243dc8dfb5d3006922253b1bb08194b7efc91a8bab625c", "type": "message", "status": "completed", "content": [{"type": "output_text", "annotations": [], "logprobs": [], "text": "<code>\nbool kissat_restarting (kissat *solver) {\n  assert(solver->unassigned);\n\n  if (!GET_OPTION(restart))\n    return false;\n\n  if (!solver->level)\n    return false;\n\n  // Always check minimal conflict bound before anything else\n  if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n\n  // Only apply the dynamic glue-decision adaptive restart (DGAR) in stable mode\n  if (solver->stable) {\n    // Compute glue moving averages\n    const double fast_glue = AVERAGE(fast_glue);\n    const double slow_glue = AVERAGE(slow_glue);\n    // Compute their ratio\n    const double glue_ratio = slow_glue ? (fast_glue / slow_glue) : 0.0;\n\n    // Decision rate moving average (current)\n    const double decision_rate = AVERAGE(decision_rate);\n\n    // State for previous decision rate at last restart\n    // We piggyback on the reluctant structure's state field for this session's D_prev.\n    // This is a safe hack as reluctant is only used for triggering restarts in non-stable mode,\n    // and its .state field is an unsigned int.\n    // To store a double in an unsigned int, we use a union.\n    // On first call, if state is zero, initialize D_prev to current.\n    union {\n      unsigned int i;\n      float f;\n    } prev_rate;\n    prev_rate.i = solver->reluctant.state;\n\n    // On first stable restart, initialize D_prev.\n    if (prev_rate.i == 0) {\n      prev_rate.f = (float) decision_rate;\n      solver->reluctant.state = prev_rate.i;\n    }\n\n    // Retrieve D_prev from reluctant.state\n    const double decision_rate_prev = prev_rate.f;\n\n    // Check DGAR conditions\n    bool glue_stagnation = (glue_ratio > 1.05);\n    bool decision_stagnation = (decision_rate < 0.95 * decision_rate_prev);\n\n    if ((glue_stagnation || decision_stagnation) && (CONFLICTS >= solver->limits.restart.conflicts)) {\n      // On restart:\n      // Update D_prev to current decision rate for next restart\n      prev_rate.f = (float) decision_rate;\n      solver->reluctant.state = prev_rate.i;\n\n      // Increase the conflict limit geometrically (limit *= 1.2)\n      solver->limits.restart.conflicts = CONFLICTS + (unsigned long)(GET_OPTION(restartint) * 1.2);\n\n      // Logging (optional)\n      kissat_extremely_verbose(solver,\n        \"DGAR restart: glue_ratio=%.3f (%.2f/%.2f), decision_rate=%.3f, prev=%.3f, conflict_limit=%lu\",\n        glue_ratio, fast_glue, slow_glue, decision_rate, decision_rate_prev, solver->limits.restart.conflicts);\n\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    // In non-stable mode, use fixed conflict limit and reluctant triggering\n    return kissat_reluctant_triggered(&solver->reluctant);\n  }\n}\n</code>"}], "role": "assistant"}], "parallel_tool_calls": true, "previous_response_id": null, "prompt_cache_key": null, "prompt_cache_retention": null, "reasoning": {"effort": null, "summary": null}, "safety_identifier": null, "service_tier": "default", "store": true, "temperature": 0.7, "text": {"format": {"type": "text"}, "verbosity": "medium"}, "tool_choice": "auto", "tools": [], "top_logprobs": 0, "top_p": 1.0, "truncation": "disabled", "usage": {"input_tokens": 1421, "input_tokens_details": {"cached_tokens": 0}, "output_tokens": 680, "output_tokens_details": {"reasoning_tokens": 0}, "total_tokens": 2101}, "user": null, "metadata": {}}}, "error": null}
{"id": "batch_req_6922258f3bf08190a71e45b0c6673b0e", "custom_id": "req-0010", "response": {"status_code": 200, "request_id": "78aeb2c77a815fc245a44d5413f682fd", "body": {"id": "resp_02c7204c0f960dfc006922253f639c819585f76dfa779e96f7", "object": "response", "created_at": 1763845439, "status": "completed", "background": false, "billing": {"payer": "developer"}, "error": null, "incomplete_details": null, "instructions": null, "max_output_tokens": null, "max_tool_calls": null, "model": "gpt-4.1-2025-04-14", "output": [{"id": "msg_02c7204c0f960dfc006922253fa5c08195b74e094cd8ab24ee", "type": "message", "status": "completed", "content": [{"type": "output_text", "annotations": [], "logprobs": [], "text": "<code>\nbool kissat_restarting(kissat *solver) {\n  assert(solver->unassigned);\n  if (!GET_OPTION(restart))\n    return false;\n  if (!solver->level)\n    return false;\n\n  // Use static variables to persist D_prev across calls (per solver instance)\n  static double d_prev = -1.0;\n  static uint64_t last_conflicts_on_restart = 0;\n\n  // --- Gather signals ---\n  const uint64_t conflicts = solver->statistics.conflicts;\n  const uint64_t conflict_limit = solver->limits.restart.conflicts;\n  const bool stable = solver->stable;\n\n  const double fast_glue = AVERAGE(fast_glue);\n  const double slow_glue = AVERAGE(slow_glue);\n  const double ratio = slow_glue ? (fast_glue / slow_glue) : 0.0;\n\n  const double decision_rate = AVERAGE(decision_rate);\n\n  // --- Fallback for unstable: fixed conflict limit ---\n  if (!stable) {\n    if (conflicts < conflict_limit)\n      return false;\n    return true;\n  }\n\n  // --- On first call in stable, initialize d_prev ---\n  if (d_prev < 0.0)\n    d_prev = decision_rate;\n\n  // --- Policy: trigger if R > 1.05 or decision rate drops by 5% ---\n  bool trigger_glue = (ratio > 1.05) && (conflicts >= conflict_limit);\n  bool trigger_decision = (decision_rate < 0.95 * d_prev) && (conflicts >= conflict_limit);\n\n  bool triggered = trigger_glue || trigger_decision;\n\n  // --- On restart, update d_prev and geometric conflict limit growth ---\n  if (triggered) {\n    d_prev = decision_rate;\n    last_conflicts_on_restart = conflicts;\n    // Geometric growth: limit *= 1.2, but ensure at least +1\n    solver->limits.restart.conflicts =\n      conflicts + (uint64_t) (GET_OPTION(restartint) * 1.2);\n  }\n\n  // (Optional) Logging for debugging\n  kissat_extremely_verbose(\n    solver,\n    \"DGAR restart: stable=%d conf=%\" PRIu64 \" lim=%\" PRIu64\n    \" glue: fast=%.2f slow=%.2f ratio=%.3f D=%.2f D_prev=%.2f \"\n    \"trigger_glue=%d trigger_decision=%d\",\n    stable, conflicts, conflict_limit, fast_glue, slow_glue, ratio,\n    decision_rate, d_prev, trigger_glue, trigger_decision);\n\n  return triggered;\n}\n</code>"}], "role": "assistant"}], "parallel_tool_calls": true, "previous_response_id": null, "prompt_cache_key": null, "prompt_cache_retention": null, "reasoning": {"effort": null, "summary": null}, "safety_identifier": null, "service_tier": "default", "store": true, "temperature": 0.7, "text": {"format": {"type": "text"}, "verbosity": "medium"}, "tool_choice": "auto", "tools": [], "top_logprobs": 0, "top_p": 1.0, "truncation": "disabled", "usage": {"input_tokens": 1421, "input_tokens_details": {"cached_tokens": 0}, "output_tokens": 563, "output_tokens_details": {"reasoning_tokens": 0}, "total_tokens": 1984}, "user": null, "metadata": {}}}, "error": null}
