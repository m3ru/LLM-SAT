{"custom_id": "req-0001", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are an expert SAT solver developer that generates compilable source code for a given algorithm in Kissat solver.\nYour final code must be the kissat_restarting function with complete signature and return type. That is the only output you should output. The code will be replacing the kissat_restarting function in the restart.c file.\nYou MUST give your final code in following format (replace the content inside <code> and </code> with your code):\n\n<code>\n(your code here)\n</code>\n\n- Your output must be less than 2048 tokens.\n- You must only use attributes and functions that are defined in Kissat solver and available in restarting function.\n\nAlgorithm specification:\n{algorithm}\n\nReference (Kissat SAT restarting function):\n\nbool kissat_restarting (kissat *solver) {\n    assert (solver->unassigned);\n    if (!GET_OPTION (restart))\n    return false;\n    if (!solver->level)\n    return false;\n    if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n    if (solver->stable)\n    return kissat_reluctant_triggered (&solver->reluctant);\n    const double fast = AVERAGE (fast_glue);\n    const double slow = AVERAGE (slow_glue);\n    const double margin = (100.0 + GET_OPTION (restartmargin)) / 100.0;\n    const double limit = margin * slow;\n    kissat_extremely_verbose (solver,\n                                \"restart glue limit %g = \"\n                                \"%.02f * %g (slow glue) %c %g (fast glue)\",\n                                limit, margin, slow,\n                                (limit > fast    ? '>'\n                                : limit == fast ? '='\n                                                : '<'),\n                                fast);\n    return (limit <= fast);\n}\n\n\n\nAlgorithm:\n{\"Algorithm Name\": \"Dynamic Glue-Rate Adaptive Restart (DGAR)\", \"Scoring Function Definition\": \"Restart when: (fast_glue_ewma > 0.95 * slow_glue_ewma) AND (decision_rate_ewma < 0.85 * long_term_decision_rate), where long_term_decision_rate is the average decision_rate_ewma over the last 1000 conflicts.\", \"Selection Procedure\": [\"On each conflict, update fast_glue_ewma, slow_glue_ewma, and decision_rate_ewma.\", \"Maintain long_term_decision_rate as an O(1) running average over the last 1000 conflicts.\", \"If both scoring conditions are met, trigger a restart.\", \"Enforce minimum interval of 50 conflicts between restarts.\", \"If restart_conflict_limit is reached, force restart regardless of other conditions.\"], \"Tie-breaking Rules\": [\"If both glue and decision rate thresholds are closely met (within 3%), prefer to restart.\", \"If stable is true, increase minimum interval between restarts to 200 conflicts.\", \"If multiple restarts are eligible in the same conflict, favor the one with the higher fast_glue_ewma.\"]}"}], "temperature": 0.7}}
{"custom_id": "req-0002", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are an expert SAT solver developer that generates compilable source code for a given algorithm in Kissat solver.\nYour final code must be the kissat_restarting function with complete signature and return type. That is the only output you should output. The code will be replacing the kissat_restarting function in the restart.c file.\nYou MUST give your final code in following format (replace the content inside <code> and </code> with your code):\n\n<code>\n(your code here)\n</code>\n\n- Your output must be less than 2048 tokens.\n- You must only use attributes and functions that are defined in Kissat solver and available in restarting function.\n\nAlgorithm specification:\n{algorithm}\n\nReference (Kissat SAT restarting function):\n\nbool kissat_restarting (kissat *solver) {\n    assert (solver->unassigned);\n    if (!GET_OPTION (restart))\n    return false;\n    if (!solver->level)\n    return false;\n    if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n    if (solver->stable)\n    return kissat_reluctant_triggered (&solver->reluctant);\n    const double fast = AVERAGE (fast_glue);\n    const double slow = AVERAGE (slow_glue);\n    const double margin = (100.0 + GET_OPTION (restartmargin)) / 100.0;\n    const double limit = margin * slow;\n    kissat_extremely_verbose (solver,\n                                \"restart glue limit %g = \"\n                                \"%.02f * %g (slow glue) %c %g (fast glue)\",\n                                limit, margin, slow,\n                                (limit > fast    ? '>'\n                                : limit == fast ? '='\n                                                : '<'),\n                                fast);\n    return (limit <= fast);\n}\n\n\n\nAlgorithm:\n{\"Algorithm Name\": \"Dynamic Glue-Rate Adaptive Restart (DGAR)\", \"Scoring Function Definition\": \"Restart when: (fast_glue_ewma > 0.95 * slow_glue_ewma) AND (decision_rate_ewma < 0.85 * long_term_decision_rate), where long_term_decision_rate is the average decision_rate_ewma over the last 1000 conflicts.\", \"Selection Procedure\": [\"On each conflict, update fast_glue_ewma, slow_glue_ewma, and decision_rate_ewma.\", \"Maintain long_term_decision_rate as an O(1) running average over the last 1000 conflicts.\", \"If both scoring conditions are met, trigger a restart.\", \"Enforce minimum interval of 50 conflicts between restarts.\", \"If restart_conflict_limit is reached, force restart regardless of other conditions.\"], \"Tie-breaking Rules\": [\"If both glue and decision rate thresholds are closely met (within 3%), prefer to restart.\", \"If stable is true, increase minimum interval between restarts to 200 conflicts.\", \"If multiple restarts are eligible in the same conflict, favor the one with the higher fast_glue_ewma.\"]}"}], "temperature": 0.7}}
{"custom_id": "req-0003", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are an expert SAT solver developer that generates compilable source code for a given algorithm in Kissat solver.\nYour final code must be the kissat_restarting function with complete signature and return type. That is the only output you should output. The code will be replacing the kissat_restarting function in the restart.c file.\nYou MUST give your final code in following format (replace the content inside <code> and </code> with your code):\n\n<code>\n(your code here)\n</code>\n\n- Your output must be less than 2048 tokens.\n- You must only use attributes and functions that are defined in Kissat solver and available in restarting function.\n\nAlgorithm specification:\n{algorithm}\n\nReference (Kissat SAT restarting function):\n\nbool kissat_restarting (kissat *solver) {\n    assert (solver->unassigned);\n    if (!GET_OPTION (restart))\n    return false;\n    if (!solver->level)\n    return false;\n    if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n    if (solver->stable)\n    return kissat_reluctant_triggered (&solver->reluctant);\n    const double fast = AVERAGE (fast_glue);\n    const double slow = AVERAGE (slow_glue);\n    const double margin = (100.0 + GET_OPTION (restartmargin)) / 100.0;\n    const double limit = margin * slow;\n    kissat_extremely_verbose (solver,\n                                \"restart glue limit %g = \"\n                                \"%.02f * %g (slow glue) %c %g (fast glue)\",\n                                limit, margin, slow,\n                                (limit > fast    ? '>'\n                                : limit == fast ? '='\n                                                : '<'),\n                                fast);\n    return (limit <= fast);\n}\n\n\n\nAlgorithm:\n{\"Algorithm Name\": \"Dynamic Glue-Rate Adaptive Restart (DGAR)\", \"Scoring Function Definition\": \"Restart when: (fast_glue_ewma > 0.95 * slow_glue_ewma) AND (decision_rate_ewma < 0.85 * long_term_decision_rate), where long_term_decision_rate is the average decision_rate_ewma over the last 1000 conflicts.\", \"Selection Procedure\": [\"On each conflict, update fast_glue_ewma, slow_glue_ewma, and decision_rate_ewma.\", \"Maintain long_term_decision_rate as an O(1) running average over the last 1000 conflicts.\", \"If both scoring conditions are met, trigger a restart.\", \"Enforce minimum interval of 50 conflicts between restarts.\", \"If restart_conflict_limit is reached, force restart regardless of other conditions.\"], \"Tie-breaking Rules\": [\"If both glue and decision rate thresholds are closely met (within 3%), prefer to restart.\", \"If stable is true, increase minimum interval between restarts to 200 conflicts.\", \"If multiple restarts are eligible in the same conflict, favor the one with the higher fast_glue_ewma.\"]}"}], "temperature": 0.7}}
{"custom_id": "req-0004", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are an expert SAT solver developer that generates compilable source code for a given algorithm in Kissat solver.\nYour final code must be the kissat_restarting function with complete signature and return type. That is the only output you should output. The code will be replacing the kissat_restarting function in the restart.c file.\nYou MUST give your final code in following format (replace the content inside <code> and </code> with your code):\n\n<code>\n(your code here)\n</code>\n\n- Your output must be less than 2048 tokens.\n- You must only use attributes and functions that are defined in Kissat solver and available in restarting function.\n\nAlgorithm specification:\n{algorithm}\n\nReference (Kissat SAT restarting function):\n\nbool kissat_restarting (kissat *solver) {\n    assert (solver->unassigned);\n    if (!GET_OPTION (restart))\n    return false;\n    if (!solver->level)\n    return false;\n    if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n    if (solver->stable)\n    return kissat_reluctant_triggered (&solver->reluctant);\n    const double fast = AVERAGE (fast_glue);\n    const double slow = AVERAGE (slow_glue);\n    const double margin = (100.0 + GET_OPTION (restartmargin)) / 100.0;\n    const double limit = margin * slow;\n    kissat_extremely_verbose (solver,\n                                \"restart glue limit %g = \"\n                                \"%.02f * %g (slow glue) %c %g (fast glue)\",\n                                limit, margin, slow,\n                                (limit > fast    ? '>'\n                                : limit == fast ? '='\n                                                : '<'),\n                                fast);\n    return (limit <= fast);\n}\n\n\n\nAlgorithm:\n{\"Algorithm Name\": \"Dynamic Glue-Rate Adaptive Restart (DGAR)\", \"Scoring Function Definition\": \"Restart when: (fast_glue_ewma > 0.95 * slow_glue_ewma) AND (decision_rate_ewma < 0.85 * long_term_decision_rate), where long_term_decision_rate is the average decision_rate_ewma over the last 1000 conflicts.\", \"Selection Procedure\": [\"On each conflict, update fast_glue_ewma, slow_glue_ewma, and decision_rate_ewma.\", \"Maintain long_term_decision_rate as an O(1) running average over the last 1000 conflicts.\", \"If both scoring conditions are met, trigger a restart.\", \"Enforce minimum interval of 50 conflicts between restarts.\", \"If restart_conflict_limit is reached, force restart regardless of other conditions.\"], \"Tie-breaking Rules\": [\"If both glue and decision rate thresholds are closely met (within 3%), prefer to restart.\", \"If stable is true, increase minimum interval between restarts to 200 conflicts.\", \"If multiple restarts are eligible in the same conflict, favor the one with the higher fast_glue_ewma.\"]}"}], "temperature": 0.7}}
{"custom_id": "req-0005", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are an expert SAT solver developer that generates compilable source code for a given algorithm in Kissat solver.\nYour final code must be the kissat_restarting function with complete signature and return type. That is the only output you should output. The code will be replacing the kissat_restarting function in the restart.c file.\nYou MUST give your final code in following format (replace the content inside <code> and </code> with your code):\n\n<code>\n(your code here)\n</code>\n\n- Your output must be less than 2048 tokens.\n- You must only use attributes and functions that are defined in Kissat solver and available in restarting function.\n\nAlgorithm specification:\n{algorithm}\n\nReference (Kissat SAT restarting function):\n\nbool kissat_restarting (kissat *solver) {\n    assert (solver->unassigned);\n    if (!GET_OPTION (restart))\n    return false;\n    if (!solver->level)\n    return false;\n    if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n    if (solver->stable)\n    return kissat_reluctant_triggered (&solver->reluctant);\n    const double fast = AVERAGE (fast_glue);\n    const double slow = AVERAGE (slow_glue);\n    const double margin = (100.0 + GET_OPTION (restartmargin)) / 100.0;\n    const double limit = margin * slow;\n    kissat_extremely_verbose (solver,\n                                \"restart glue limit %g = \"\n                                \"%.02f * %g (slow glue) %c %g (fast glue)\",\n                                limit, margin, slow,\n                                (limit > fast    ? '>'\n                                : limit == fast ? '='\n                                                : '<'),\n                                fast);\n    return (limit <= fast);\n}\n\n\n\nAlgorithm:\n{\"Algorithm Name\": \"Dynamic Glue-Rate Adaptive Restart (DGAR)\", \"Scoring Function Definition\": \"Restart when: (fast_glue_ewma > 0.95 * slow_glue_ewma) AND (decision_rate_ewma < 0.85 * long_term_decision_rate), where long_term_decision_rate is the average decision_rate_ewma over the last 1000 conflicts.\", \"Selection Procedure\": [\"On each conflict, update fast_glue_ewma, slow_glue_ewma, and decision_rate_ewma.\", \"Maintain long_term_decision_rate as an O(1) running average over the last 1000 conflicts.\", \"If both scoring conditions are met, trigger a restart.\", \"Enforce minimum interval of 50 conflicts between restarts.\", \"If restart_conflict_limit is reached, force restart regardless of other conditions.\"], \"Tie-breaking Rules\": [\"If both glue and decision rate thresholds are closely met (within 3%), prefer to restart.\", \"If stable is true, increase minimum interval between restarts to 200 conflicts.\", \"If multiple restarts are eligible in the same conflict, favor the one with the higher fast_glue_ewma.\"]}"}], "temperature": 0.7}}
{"custom_id": "req-0006", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are an expert SAT solver developer that generates compilable source code for a given algorithm in Kissat solver.\nYour final code must be the kissat_restarting function with complete signature and return type. That is the only output you should output. The code will be replacing the kissat_restarting function in the restart.c file.\nYou MUST give your final code in following format (replace the content inside <code> and </code> with your code):\n\n<code>\n(your code here)\n</code>\n\n- Your output must be less than 2048 tokens.\n- You must only use attributes and functions that are defined in Kissat solver and available in restarting function.\n\nAlgorithm specification:\n{algorithm}\n\nReference (Kissat SAT restarting function):\n\nbool kissat_restarting (kissat *solver) {\n    assert (solver->unassigned);\n    if (!GET_OPTION (restart))\n    return false;\n    if (!solver->level)\n    return false;\n    if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n    if (solver->stable)\n    return kissat_reluctant_triggered (&solver->reluctant);\n    const double fast = AVERAGE (fast_glue);\n    const double slow = AVERAGE (slow_glue);\n    const double margin = (100.0 + GET_OPTION (restartmargin)) / 100.0;\n    const double limit = margin * slow;\n    kissat_extremely_verbose (solver,\n                                \"restart glue limit %g = \"\n                                \"%.02f * %g (slow glue) %c %g (fast glue)\",\n                                limit, margin, slow,\n                                (limit > fast    ? '>'\n                                : limit == fast ? '='\n                                                : '<'),\n                                fast);\n    return (limit <= fast);\n}\n\n\n\nAlgorithm:\n{\"Algorithm Name\": \"Dynamic Glue-Rate Adaptive Restart (DGAR)\", \"Scoring Function Definition\": \"Restart when: (fast_glue_ewma > 0.95 * slow_glue_ewma) AND (decision_rate_ewma < 0.85 * long_term_decision_rate), where long_term_decision_rate is the average decision_rate_ewma over the last 1000 conflicts.\", \"Selection Procedure\": [\"On each conflict, update fast_glue_ewma, slow_glue_ewma, and decision_rate_ewma.\", \"Maintain long_term_decision_rate as an O(1) running average over the last 1000 conflicts.\", \"If both scoring conditions are met, trigger a restart.\", \"Enforce minimum interval of 50 conflicts between restarts.\", \"If restart_conflict_limit is reached, force restart regardless of other conditions.\"], \"Tie-breaking Rules\": [\"If both glue and decision rate thresholds are closely met (within 3%), prefer to restart.\", \"If stable is true, increase minimum interval between restarts to 200 conflicts.\", \"If multiple restarts are eligible in the same conflict, favor the one with the higher fast_glue_ewma.\"]}"}], "temperature": 0.7}}
{"custom_id": "req-0007", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are an expert SAT solver developer that generates compilable source code for a given algorithm in Kissat solver.\nYour final code must be the kissat_restarting function with complete signature and return type. That is the only output you should output. The code will be replacing the kissat_restarting function in the restart.c file.\nYou MUST give your final code in following format (replace the content inside <code> and </code> with your code):\n\n<code>\n(your code here)\n</code>\n\n- Your output must be less than 2048 tokens.\n- You must only use attributes and functions that are defined in Kissat solver and available in restarting function.\n\nAlgorithm specification:\n{algorithm}\n\nReference (Kissat SAT restarting function):\n\nbool kissat_restarting (kissat *solver) {\n    assert (solver->unassigned);\n    if (!GET_OPTION (restart))\n    return false;\n    if (!solver->level)\n    return false;\n    if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n    if (solver->stable)\n    return kissat_reluctant_triggered (&solver->reluctant);\n    const double fast = AVERAGE (fast_glue);\n    const double slow = AVERAGE (slow_glue);\n    const double margin = (100.0 + GET_OPTION (restartmargin)) / 100.0;\n    const double limit = margin * slow;\n    kissat_extremely_verbose (solver,\n                                \"restart glue limit %g = \"\n                                \"%.02f * %g (slow glue) %c %g (fast glue)\",\n                                limit, margin, slow,\n                                (limit > fast    ? '>'\n                                : limit == fast ? '='\n                                                : '<'),\n                                fast);\n    return (limit <= fast);\n}\n\n\n\nAlgorithm:\n{\"Algorithm Name\": \"Dynamic Glue-Rate Adaptive Restart (DGAR)\", \"Scoring Function Definition\": \"Restart when: (fast_glue_ewma > 0.95 * slow_glue_ewma) AND (decision_rate_ewma < 0.85 * long_term_decision_rate), where long_term_decision_rate is the average decision_rate_ewma over the last 1000 conflicts.\", \"Selection Procedure\": [\"On each conflict, update fast_glue_ewma, slow_glue_ewma, and decision_rate_ewma.\", \"Maintain long_term_decision_rate as an O(1) running average over the last 1000 conflicts.\", \"If both scoring conditions are met, trigger a restart.\", \"Enforce minimum interval of 50 conflicts between restarts.\", \"If restart_conflict_limit is reached, force restart regardless of other conditions.\"], \"Tie-breaking Rules\": [\"If both glue and decision rate thresholds are closely met (within 3%), prefer to restart.\", \"If stable is true, increase minimum interval between restarts to 200 conflicts.\", \"If multiple restarts are eligible in the same conflict, favor the one with the higher fast_glue_ewma.\"]}"}], "temperature": 0.7}}
{"custom_id": "req-0008", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are an expert SAT solver developer that generates compilable source code for a given algorithm in Kissat solver.\nYour final code must be the kissat_restarting function with complete signature and return type. That is the only output you should output. The code will be replacing the kissat_restarting function in the restart.c file.\nYou MUST give your final code in following format (replace the content inside <code> and </code> with your code):\n\n<code>\n(your code here)\n</code>\n\n- Your output must be less than 2048 tokens.\n- You must only use attributes and functions that are defined in Kissat solver and available in restarting function.\n\nAlgorithm specification:\n{algorithm}\n\nReference (Kissat SAT restarting function):\n\nbool kissat_restarting (kissat *solver) {\n    assert (solver->unassigned);\n    if (!GET_OPTION (restart))\n    return false;\n    if (!solver->level)\n    return false;\n    if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n    if (solver->stable)\n    return kissat_reluctant_triggered (&solver->reluctant);\n    const double fast = AVERAGE (fast_glue);\n    const double slow = AVERAGE (slow_glue);\n    const double margin = (100.0 + GET_OPTION (restartmargin)) / 100.0;\n    const double limit = margin * slow;\n    kissat_extremely_verbose (solver,\n                                \"restart glue limit %g = \"\n                                \"%.02f * %g (slow glue) %c %g (fast glue)\",\n                                limit, margin, slow,\n                                (limit > fast    ? '>'\n                                : limit == fast ? '='\n                                                : '<'),\n                                fast);\n    return (limit <= fast);\n}\n\n\n\nAlgorithm:\n{\"Algorithm Name\": \"Dynamic Glue-Rate Adaptive Restart (DGAR)\", \"Scoring Function Definition\": \"Restart when: (fast_glue_ewma > 0.95 * slow_glue_ewma) AND (decision_rate_ewma < 0.85 * long_term_decision_rate), where long_term_decision_rate is the average decision_rate_ewma over the last 1000 conflicts.\", \"Selection Procedure\": [\"On each conflict, update fast_glue_ewma, slow_glue_ewma, and decision_rate_ewma.\", \"Maintain long_term_decision_rate as an O(1) running average over the last 1000 conflicts.\", \"If both scoring conditions are met, trigger a restart.\", \"Enforce minimum interval of 50 conflicts between restarts.\", \"If restart_conflict_limit is reached, force restart regardless of other conditions.\"], \"Tie-breaking Rules\": [\"If both glue and decision rate thresholds are closely met (within 3%), prefer to restart.\", \"If stable is true, increase minimum interval between restarts to 200 conflicts.\", \"If multiple restarts are eligible in the same conflict, favor the one with the higher fast_glue_ewma.\"]}"}], "temperature": 0.7}}
{"custom_id": "req-0009", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are an expert SAT solver developer that generates compilable source code for a given algorithm in Kissat solver.\nYour final code must be the kissat_restarting function with complete signature and return type. That is the only output you should output. The code will be replacing the kissat_restarting function in the restart.c file.\nYou MUST give your final code in following format (replace the content inside <code> and </code> with your code):\n\n<code>\n(your code here)\n</code>\n\n- Your output must be less than 2048 tokens.\n- You must only use attributes and functions that are defined in Kissat solver and available in restarting function.\n\nAlgorithm specification:\n{algorithm}\n\nReference (Kissat SAT restarting function):\n\nbool kissat_restarting (kissat *solver) {\n    assert (solver->unassigned);\n    if (!GET_OPTION (restart))\n    return false;\n    if (!solver->level)\n    return false;\n    if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n    if (solver->stable)\n    return kissat_reluctant_triggered (&solver->reluctant);\n    const double fast = AVERAGE (fast_glue);\n    const double slow = AVERAGE (slow_glue);\n    const double margin = (100.0 + GET_OPTION (restartmargin)) / 100.0;\n    const double limit = margin * slow;\n    kissat_extremely_verbose (solver,\n                                \"restart glue limit %g = \"\n                                \"%.02f * %g (slow glue) %c %g (fast glue)\",\n                                limit, margin, slow,\n                                (limit > fast    ? '>'\n                                : limit == fast ? '='\n                                                : '<'),\n                                fast);\n    return (limit <= fast);\n}\n\n\n\nAlgorithm:\n{\"Algorithm Name\": \"Dynamic Glue-Rate Adaptive Restart (DGAR)\", \"Scoring Function Definition\": \"Restart when: (fast_glue_ewma > 0.95 * slow_glue_ewma) AND (decision_rate_ewma < 0.85 * long_term_decision_rate), where long_term_decision_rate is the average decision_rate_ewma over the last 1000 conflicts.\", \"Selection Procedure\": [\"On each conflict, update fast_glue_ewma, slow_glue_ewma, and decision_rate_ewma.\", \"Maintain long_term_decision_rate as an O(1) running average over the last 1000 conflicts.\", \"If both scoring conditions are met, trigger a restart.\", \"Enforce minimum interval of 50 conflicts between restarts.\", \"If restart_conflict_limit is reached, force restart regardless of other conditions.\"], \"Tie-breaking Rules\": [\"If both glue and decision rate thresholds are closely met (within 3%), prefer to restart.\", \"If stable is true, increase minimum interval between restarts to 200 conflicts.\", \"If multiple restarts are eligible in the same conflict, favor the one with the higher fast_glue_ewma.\"]}"}], "temperature": 0.7}}
{"custom_id": "req-0010", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are an expert SAT solver developer that generates compilable source code for a given algorithm in Kissat solver.\nYour final code must be the kissat_restarting function with complete signature and return type. That is the only output you should output. The code will be replacing the kissat_restarting function in the restart.c file.\nYou MUST give your final code in following format (replace the content inside <code> and </code> with your code):\n\n<code>\n(your code here)\n</code>\n\n- Your output must be less than 2048 tokens.\n- You must only use attributes and functions that are defined in Kissat solver and available in restarting function.\n\nAlgorithm specification:\n{algorithm}\n\nReference (Kissat SAT restarting function):\n\nbool kissat_restarting (kissat *solver) {\n    assert (solver->unassigned);\n    if (!GET_OPTION (restart))\n    return false;\n    if (!solver->level)\n    return false;\n    if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n    if (solver->stable)\n    return kissat_reluctant_triggered (&solver->reluctant);\n    const double fast = AVERAGE (fast_glue);\n    const double slow = AVERAGE (slow_glue);\n    const double margin = (100.0 + GET_OPTION (restartmargin)) / 100.0;\n    const double limit = margin * slow;\n    kissat_extremely_verbose (solver,\n                                \"restart glue limit %g = \"\n                                \"%.02f * %g (slow glue) %c %g (fast glue)\",\n                                limit, margin, slow,\n                                (limit > fast    ? '>'\n                                : limit == fast ? '='\n                                                : '<'),\n                                fast);\n    return (limit <= fast);\n}\n\n\n\nAlgorithm:\n{\"Algorithm Name\": \"Dynamic Glue-Rate Adaptive Restart (DGAR)\", \"Scoring Function Definition\": \"Restart when: (fast_glue_ewma > 0.95 * slow_glue_ewma) AND (decision_rate_ewma < 0.85 * long_term_decision_rate), where long_term_decision_rate is the average decision_rate_ewma over the last 1000 conflicts.\", \"Selection Procedure\": [\"On each conflict, update fast_glue_ewma, slow_glue_ewma, and decision_rate_ewma.\", \"Maintain long_term_decision_rate as an O(1) running average over the last 1000 conflicts.\", \"If both scoring conditions are met, trigger a restart.\", \"Enforce minimum interval of 50 conflicts between restarts.\", \"If restart_conflict_limit is reached, force restart regardless of other conditions.\"], \"Tie-breaking Rules\": [\"If both glue and decision rate thresholds are closely met (within 3%), prefer to restart.\", \"If stable is true, increase minimum interval between restarts to 200 conflicts.\", \"If multiple restarts are eligible in the same conflict, favor the one with the higher fast_glue_ewma.\"]}"}], "temperature": 0.7}}
