{"id": "batch_req_692138ab43a081909447bb4583043e35", "custom_id": "req-0001", "response": {"status_code": 200, "request_id": "68e9212ce2a8076acd5852ddd03e9b72", "body": {"id": "resp_03bbb8dbb774810c00692138902d0c81919c81b465622a3ec5", "object": "response", "created_at": 1763784848, "status": "completed", "background": false, "billing": {"payer": "developer"}, "error": null, "incomplete_details": null, "instructions": null, "max_output_tokens": null, "max_tool_calls": null, "model": "gpt-4.1-2025-04-14", "output": [{"id": "msg_03bbb8dbb774810c006921389073e08191bdd94f8810977bc4", "type": "message", "status": "completed", "content": [{"type": "output_text", "annotations": [], "logprobs": [], "text": "<code>\nbool kissat_restarting(kissat *solver) {\n  assert(solver->unassigned);\n  if (!GET_OPTION(restart))\n    return false;\n  if (!solver->level)\n    return false;\n\n  // Conflict limit for minimum interval between restarts\n  const uint64_t restart_conflict_limit = solver->limits.restart.conflicts;\n  static uint64_t next_restart_at = 0;\n  static uint64_t last_restart_conflict = 0;\n\n  // Only consider restarts if enough conflicts have occurred\n  if (CONFLICTS < next_restart_at)\n    return false;\n\n  // Prevent two restarts at the same conflict\n  if (CONFLICTS == last_restart_conflict)\n    return false;\n\n  // Compute glue averages\n  const double fast = AVERAGE(fast_glue);\n  const double slow = AVERAGE(slow_glue);\n\n  // Compute decision rate EWMA and global average\n  const double dec_rate_ewma = AVERAGE(decision_rate);\n  const double global_rate = solver->statistics.decisions ?\n    ((double) solver->statistics.decisions) / solver->statistics.conflicts : 0.0;\n\n  // Glue-based trigger (a)\n  const double glue_margin = 0.8;\n  const bool glue_trigger = (fast >= glue_margin * slow);\n\n  // Decision-rate trigger (b)\n  const double dec_margin = 0.5;\n  const bool dec_trigger = (dec_rate_ewma <= dec_margin * global_rate);\n\n  bool fire_restart = false;\n  // Tie-breaking and stable-phase rules\n  if (solver->stable) {\n    // In stable phase, require both triggers\n    if (glue_trigger && dec_trigger)\n      fire_restart = true;\n  } else {\n    // In non-stable phase, fire if either trigger, glue has priority\n    if (glue_trigger)\n      fire_restart = true;\n    else if (dec_trigger)\n      fire_restart = true;\n  }\n\n  if (fire_restart) {\n    last_restart_conflict = CONFLICTS;\n    next_restart_at = CONFLICTS + restart_conflict_limit;\n#if defined(LOGGING) || defined(NLOGGING)\n    kissat_extremely_verbose(solver,\n      \"dual-threshold adaptive glue-decision restart: \"\n      \"fast_glue %.2f, slow_glue %.2f, dec_rate %.2f, global %.2f (glue:%d dec:%d), next at %\" PRIu64,\n      fast, slow, dec_rate_ewma, global_rate, glue_trigger, dec_trigger, next_restart_at);\n#endif\n    return true;\n  }\n\n  return false;\n}\n</code>"}], "role": "assistant"}], "parallel_tool_calls": true, "previous_response_id": null, "prompt_cache_key": null, "prompt_cache_retention": null, "reasoning": {"effort": null, "summary": null}, "safety_identifier": null, "service_tier": "default", "store": true, "temperature": 0.7, "text": {"format": {"type": "text"}, "verbosity": "medium"}, "tool_choice": "auto", "tools": [], "top_logprobs": 0, "top_p": 1.0, "truncation": "disabled", "usage": {"input_tokens": 672, "input_tokens_details": {"cached_tokens": 0}, "output_tokens": 561, "output_tokens_details": {"reasoning_tokens": 0}, "total_tokens": 1233}, "user": null, "metadata": {}}}, "error": null}
{"id": "batch_req_692138ab569481909b5b27b7e86e3bb3", "custom_id": "req-0002", "response": {"status_code": 200, "request_id": "af950b06fc2e492af5bac4020087d0a6", "body": {"id": "resp_04f19acab36df97e00692138963ff4819d9b1e7ed3bab8683b", "object": "response", "created_at": 1763784854, "status": "completed", "background": false, "billing": {"payer": "developer"}, "error": null, "incomplete_details": null, "instructions": null, "max_output_tokens": null, "max_tool_calls": null, "model": "gpt-4.1-2025-04-14", "output": [{"id": "msg_04f19acab36df97e00692138968744819da8f267e236854940", "type": "message", "status": "completed", "content": [{"type": "output_text", "annotations": [], "logprobs": [], "text": "<code>\nbool kissat_restarting(kissat *solver) {\n  assert(solver->unassigned);\n  if (!GET_OPTION(restart))\n    return false;\n  if (!solver->level)\n    return false;\n\n  // Ensure we have the latest stats\n  const unsigned restart_conflict_limit = solver->limits.restart.conflicts;\n  static uint64_t next_restart_at = 0;\n  static uint64_t last_restart_conflict = 0;\n\n  const uint64_t current_conflicts = CONFLICTS;\n  if (current_conflicts < next_restart_at)\n    return false;\n\n  // Avoid multiple restarts at the same conflict\n  if (current_conflicts == last_restart_conflict)\n    return false;\n\n  // Compute EWMA glue scores\n  const double fast_glue = AVERAGE(fast_glue);\n  const double slow_glue = AVERAGE(slow_glue);\n\n  // Compute decision rate EWMA (decisions per conflict)\n  // We use slow_decision_rate and fast_decision_rate if available, but here we use total stats\n  const uint64_t total_decisions = solver->stats.decisions;\n  const uint64_t total_conflicts = solver->stats.conflicts;\n\n  // Avoid division by zero\n  double average_decision_rate = 0.0;\n  if (total_conflicts)\n    average_decision_rate = (double) total_decisions / (double) total_conflicts;\n  // If not enough history, suppress restarts\n  if (total_conflicts < 10)\n    return false;\n\n  // EWMA of recent decision rate: since we don't have it, approximate with recent decisions/conflicts\n  // To simulate a short window, we use the last 100 conflicts\n  const uint64_t window = 100;\n  uint64_t start_conflicts = (total_conflicts > window) ? (total_conflicts - window) : 0;\n  uint64_t start_decisions = 0;\n  if (start_conflicts)\n    start_decisions = kissat_stats_get_decisions_at(solver, start_conflicts); // This is a hypothetical utility\n  const uint64_t recent_conflicts = total_conflicts - start_conflicts;\n  const uint64_t recent_decisions = total_decisions - start_decisions;\n  double recent_decision_rate_ewma = 0.0;\n  if (recent_conflicts)\n    recent_decision_rate_ewma = (double) recent_decisions / (double) recent_conflicts;\n  else\n    recent_decision_rate_ewma = average_decision_rate;\n\n  // Glue-based trigger\n  const double glue_trigger = 0.8 * slow_glue;\n  const bool glue_based = (fast_glue >= glue_trigger);\n\n  // Decision-rate trigger\n  const double drate_trigger = 0.5 * average_decision_rate;\n  const bool drate_based = (recent_decision_rate_ewma <= drate_trigger);\n\n  // Stable phase: require both triggers to fire\n  bool trigger = false;\n  if (solver->stable) {\n    if (glue_based && drate_based)\n      trigger = true;\n  } else {\n    if (glue_based)\n      trigger = true;\n    else if (drate_based)\n      trigger = true;\n  }\n\n  kissat_extremely_verbose(\n    solver,\n    \"dual-threshold adaptive restart: fast_glue=%.2f slow_glue=%.2f fast/slow=%.2f glue_trigger=%.2f drate=%.4f avg=%.4f drate_trigger=%.4f%s%s\",\n    fast_glue, slow_glue, slow_glue ? (fast_glue / slow_glue) : 0.0,\n    glue_trigger, recent_decision_rate_ewma, average_decision_rate, drate_trigger,\n    glue_based ? \" [GLUE]\" : \"\",\n    drate_based ? \" [DRATE]\" : \"\"\n  );\n\n  if (trigger) {\n    last_restart_conflict = current_conflicts;\n    next_restart_at = current_conflicts + restart_conflict_limit;\n    return true;\n  }\n  return false;\n}\n</code>"}], "role": "assistant"}], "parallel_tool_calls": true, "previous_response_id": null, "prompt_cache_key": null, "prompt_cache_retention": null, "reasoning": {"effort": null, "summary": null}, "safety_identifier": null, "service_tier": "default", "store": true, "temperature": 0.7, "text": {"format": {"type": "text"}, "verbosity": "medium"}, "tool_choice": "auto", "tools": [], "top_logprobs": 0, "top_p": 1.0, "truncation": "disabled", "usage": {"input_tokens": 672, "input_tokens_details": {"cached_tokens": 0}, "output_tokens": 874, "output_tokens_details": {"reasoning_tokens": 0}, "total_tokens": 1546}, "user": null, "metadata": {}}}, "error": null}
{"id": "batch_req_692138ab544881908de18cb7b187392d", "custom_id": "req-0003", "response": {"status_code": 200, "request_id": "e61c8b6dea9906dec56ef4563f932abf", "body": {"id": "resp_02e75113df08ac0d0069213897971881a18e2ff1da7d571bb7", "object": "response", "created_at": 1763784855, "status": "completed", "background": false, "billing": {"payer": "developer"}, "error": null, "incomplete_details": null, "instructions": null, "max_output_tokens": null, "max_tool_calls": null, "model": "gpt-4.1-2025-04-14", "output": [{"id": "msg_02e75113df08ac0d0069213897e1b081a1bb6371e9be6befa8", "type": "message", "status": "completed", "content": [{"type": "output_text", "annotations": [], "logprobs": [], "text": "<code>\nbool kissat_restarting (kissat *solver) {\n    assert(solver->unassigned);\n\n    if (!GET_OPTION(restart))\n        return false;\n    if (!solver->level)\n        return false;\n\n    // Enforce minimal interval between restarts\n    const uint64_t conflicts = CONFLICTS;\n    const uint64_t restart_conflict_limit = solver->limits.restart.conflicts;\n    static uint64_t next_restart_at = 0;\n    static uint64_t last_restart_conflict = 0;\n\n    if (conflicts < next_restart_at)\n        return false;\n    if (conflicts == last_restart_conflict)\n        return false;\n\n    // Compute fast and slow glue EWMAs\n    const double fast_glue = AVERAGE(fast_glue);\n    const double slow_glue = AVERAGE(slow_glue);\n\n    // Compute glue-based trigger\n    const double glue_threshold = 0.8 * slow_glue;\n    bool glue_trigger = (fast_glue >= glue_threshold);\n\n    // Compute decision rate trigger\n    // decisions/conflicts is the long-term average\n    double avg_decisions_per_conflict = 0.0;\n    if (solver->statistics.conflicts > 0)\n        avg_decisions_per_conflict =\n            (double)solver->statistics.decisions / (double)solver->statistics.conflicts;\n    // EWMA for recent decision rate\n    const double decision_rate_ewma = AVERAGE(decision_rate);\n    // Fires if recent decision rate is less than half long-term avg\n    bool decision_trigger = (decision_rate_ewma <= 0.5 * avg_decisions_per_conflict);\n\n    // Tie-breaking and stable-phase rule\n    bool restart = false;\n    if (solver->stable) {\n        // In stable phase, require BOTH triggers\n        restart = glue_trigger && decision_trigger;\n    } else {\n        // In regular phase, fire if EITHER trigger\n        restart = glue_trigger || decision_trigger;\n    }\n\n    if (restart) {\n        // If both triggers fire, prefer glue-based for logging\n        if (glue_trigger)\n            kissat_extremely_verbose(solver,\n                \"dual-threshold adaptive restart: fast_glue %.2f >= 0.8 * slow_glue %.2f (%.2f) [glue-trigger]\",\n                fast_glue, slow_glue, glue_threshold);\n        else\n            kissat_extremely_verbose(solver,\n                \"dual-threshold adaptive restart: decision_rate_ewma %.2f <= 0.5 * avg_decisions_per_conflict %.2f [decision-trigger]\",\n                decision_rate_ewma, 0.5 * avg_decisions_per_conflict);\n\n        last_restart_conflict = conflicts;\n        next_restart_at = conflicts + restart_conflict_limit;\n        return true;\n    }\n\n    return false;\n}\n</code>"}], "role": "assistant"}], "parallel_tool_calls": true, "previous_response_id": null, "prompt_cache_key": null, "prompt_cache_retention": null, "reasoning": {"effort": null, "summary": null}, "safety_identifier": null, "service_tier": "default", "store": true, "temperature": 0.7, "text": {"format": {"type": "text"}, "verbosity": "medium"}, "tool_choice": "auto", "tools": [], "top_logprobs": 0, "top_p": 1.0, "truncation": "disabled", "usage": {"input_tokens": 672, "input_tokens_details": {"cached_tokens": 0}, "output_tokens": 602, "output_tokens_details": {"reasoning_tokens": 0}, "total_tokens": 1274}, "user": null, "metadata": {}}}, "error": null}
{"id": "batch_req_692138ab5294819093f5cf89761c9e0b", "custom_id": "req-0004", "response": {"status_code": 200, "request_id": "1c53092dc0c94709c0fd870a43f15c6d", "body": {"id": "resp_05308fbcb4d953e8006921389aef48819eb62177c77c8c4790", "object": "response", "created_at": 1763784858, "status": "completed", "background": false, "billing": {"payer": "developer"}, "error": null, "incomplete_details": null, "instructions": null, "max_output_tokens": null, "max_tool_calls": null, "model": "gpt-4.1-2025-04-14", "output": [{"id": "msg_05308fbcb4d953e8006921389b37ac819eb3d845a163334454", "type": "message", "status": "completed", "content": [{"type": "output_text", "annotations": [], "logprobs": [], "text": "<code>\nbool kissat_restarting(kissat *solver) {\n  assert(solver->unassigned);\n  if (!GET_OPTION(restart))\n    return false;\n  if (!solver->level)\n    return false;\n\n  // Conflict threshold: don't restart too often\n  uint64_t restart_conflict_limit = solver->limits.restart.conflicts;\n  if (CONFLICTS < solver->restart.next_at)\n    return false;\n\n  // EWMA values for glue\n  const double fast = AVERAGE(fast_glue);\n  const double slow = AVERAGE(slow_glue);\n\n  // EWMA for decision rate (decisions per conflict, but for restarts use its moving average)\n  const double decision_rate_ewma = AVERAGE(decision_rate);\n\n  // Long-term average decisions per conflict (cumulative)\n  double avg_decision_per_conflict = 0.0;\n  if (solver->statistics.conflicts)\n    avg_decision_per_conflict =\n      (double)solver->statistics.decisions /\n      (double)solver->statistics.conflicts;\n  else\n    avg_decision_per_conflict = 1.0; // avoid div by zero, arbitrary positive\n\n  // Triggers\n  bool glue_trigger = (fast >= 0.8 * slow);\n  bool decision_trigger = (decision_rate_ewma <= 0.5 * avg_decision_per_conflict);\n\n  // Tie-breaking: glue_trigger prioritized if both fire\n  bool both_triggers = glue_trigger && decision_trigger;\n\n  // In stable phase, only fire if both triggers\n  if (solver->stable) {\n    if (!both_triggers)\n      return false;\n  } else {\n    if (!glue_trigger && !decision_trigger)\n      return false;\n  }\n\n  // Same-conflict restart suppression\n  uint64_t current_conflicts = CONFLICTS;\n  if (current_conflicts == solver->restart.last_at)\n    return false;\n\n  // Trigger restart\n  kissat_extremely_verbose(\n    solver,\n    \"Dual-Threshold Adaptive Glue-Decision Restart: fast_glue=%.2f, slow_glue=%.2f, fast>=0.8*slow=%d, dec_rate=%.2f, avg_dec/cnf=%.2f, dec_rate<=0.5*avg=%d, stable=%d\",\n    fast, slow, glue_trigger, decision_rate_ewma, avg_decision_per_conflict, decision_trigger, solver->stable);\n\n  // Update next restart constraint\n  solver->restart.last_at = current_conflicts;\n  solver->restart.next_at = current_conflicts + restart_conflict_limit;\n\n  return true;\n}\n</code>"}], "role": "assistant"}], "parallel_tool_calls": true, "previous_response_id": null, "prompt_cache_key": null, "prompt_cache_retention": null, "reasoning": {"effort": null, "summary": null}, "safety_identifier": null, "service_tier": "default", "store": true, "temperature": 0.7, "text": {"format": {"type": "text"}, "verbosity": "medium"}, "tool_choice": "auto", "tools": [], "top_logprobs": 0, "top_p": 1.0, "truncation": "disabled", "usage": {"input_tokens": 672, "input_tokens_details": {"cached_tokens": 0}, "output_tokens": 559, "output_tokens_details": {"reasoning_tokens": 0}, "total_tokens": 1231}, "user": null, "metadata": {}}}, "error": null}
{"id": "batch_req_692138ab52448190a24f4f42913ba638", "custom_id": "req-0005", "response": {"status_code": 200, "request_id": "45bf488c33c2bf8e49d0ef55e8050dc7", "body": {"id": "resp_0cf9d60669b5d49c006921389b041881a2a36c4d15b408437c", "object": "response", "created_at": 1763784859, "status": "completed", "background": false, "billing": {"payer": "developer"}, "error": null, "incomplete_details": null, "instructions": null, "max_output_tokens": null, "max_tool_calls": null, "model": "gpt-4.1-2025-04-14", "output": [{"id": "msg_0cf9d60669b5d49c006921389b53a081a2825c3f1839ed38d4", "type": "message", "status": "completed", "content": [{"type": "output_text", "annotations": [], "logprobs": [], "text": "<code>\nbool kissat_restarting (kissat *solver) {\n  assert (solver->unassigned);\n\n  // Restarts disabled?\n  if (!GET_OPTION (restart))\n    return false;\n  // Only in search, not at root\n  if (!solver->level)\n    return false;\n\n  // Retrieve parameters and state\n  const unsigned restart_conflict_limit = solver->limits.restart.conflicts;\n  unsigned *next_restart_at_ptr = &solver->limits.restart.next_at;\n\n  // Initialize next_restart_at if first time\n  if (!*next_restart_at_ptr)\n    *next_restart_at_ptr = CONFLICTS + restart_conflict_limit;\n\n  // Not yet at the minimum conflict distance for restart\n  if (CONFLICTS < *next_restart_at_ptr)\n    return false;\n\n  // Prevent two restarts at the same conflict\n  if (solver->last.restart == CONFLICTS)\n    return false;\n\n  // Compute EWMA statistics\n  const double fast = AVERAGE (fast_glue);\n  const double slow = AVERAGE (slow_glue);\n\n  // Decision rate EWMA: maintained as solver->decision_rate_moving_avg\n  // Baseline decisions/conflicts: use solver->statistics.decisions / solver->statistics.conflicts\n  const double decision_ewma = solver->decision_rate_moving_avg;\n  double actual_conflicts = solver->statistics.conflicts;\n  double actual_decisions = solver->statistics.decisions;\n  // Avoid division by zero\n  const double baseline_rate = actual_conflicts ? (actual_decisions / actual_conflicts) : 0.0;\n\n  // Dual trigger thresholds\n  const double glue_thresh = 0.8 * slow;\n  const double dec_thresh = 0.5 * baseline_rate;\n\n  // Check trigger (a): glue-based\n  bool glue_triggered = (fast >= glue_thresh);\n\n  // Check trigger (b): decision-rate based\n  bool decision_triggered = (decision_ewma <= dec_thresh);\n\n  // In stable phase, require BOTH triggers\n  if (solver->stable) {\n    if (!(glue_triggered && decision_triggered))\n      return false;\n  } else {\n    if (!(glue_triggered || decision_triggered))\n      return false;\n  }\n\n  // If both triggers, prioritize glue trigger for reporting (not required here)\n  // Update next restart conflict threshold\n  *next_restart_at_ptr = CONFLICTS + restart_conflict_limit;\n  solver->last.restart = CONFLICTS;\n\n  // Optionally print diagnostic\n  kissat_extremely_verbose (solver,\n    \"restarting at conflict %u (fast_glue=%.2f, slow_glue=%.2f, decision_ewma=%.2f, baseline=%.2f, glue_trig=%d, dec_trig=%d, stable=%d)\",\n    CONFLICTS, fast, slow, decision_ewma, baseline_rate, glue_triggered, decision_triggered, solver->stable);\n\n  return true;\n}\n</code>"}], "role": "assistant"}], "parallel_tool_calls": true, "previous_response_id": null, "prompt_cache_key": null, "prompt_cache_retention": null, "reasoning": {"effort": null, "summary": null}, "safety_identifier": null, "service_tier": "default", "store": true, "temperature": 0.7, "text": {"format": {"type": "text"}, "verbosity": "medium"}, "tool_choice": "auto", "tools": [], "top_logprobs": 0, "top_p": 1.0, "truncation": "disabled", "usage": {"input_tokens": 672, "input_tokens_details": {"cached_tokens": 0}, "output_tokens": 631, "output_tokens_details": {"reasoning_tokens": 0}, "total_tokens": 1303}, "user": null, "metadata": {}}}, "error": null}
{"id": "batch_req_692138ab53688190b83565b7586870a8", "custom_id": "req-0006", "response": {"status_code": 200, "request_id": "402740650ab435613ffa1fb81b8ac6f6", "body": {"id": "resp_00d8ac89ab003ad7006921389ba224819dbf18d4724d556ef7", "object": "response", "created_at": 1763784859, "status": "completed", "background": false, "billing": {"payer": "developer"}, "error": null, "incomplete_details": null, "instructions": null, "max_output_tokens": null, "max_tool_calls": null, "model": "gpt-4.1-2025-04-14", "output": [{"id": "msg_00d8ac89ab003ad7006921389be868819d8397c3fd35c78f96", "type": "message", "status": "completed", "content": [{"type": "output_text", "annotations": [], "logprobs": [], "text": "<code>\nbool kissat_restarting (kissat *solver)\n{\n  assert (solver->unassigned);\n\n  if (!GET_OPTION (restart))\n    return false;\n\n  if (!solver->level)\n    return false;\n\n  // Get the restart conflict limit from options\n  const uint64_t restart_conflict_limit = solver->limits.restart.conflicts;\n\n  // Use a persistent field to track next possible restart conflict\n  // Initialize it if unset (zero)\n  if (!solver->next_restart_at)\n    solver->next_restart_at = CONFLICTS + restart_conflict_limit;\n\n  if (CONFLICTS < solver->next_restart_at)\n    return false;\n\n  const double fast = AVERAGE (fast_glue);\n  const double slow = AVERAGE (slow_glue);\n\n  // Decision rate: decisions per conflict\n  // stats.decisions and stats.conflicts are uint64_t\n  double avg_decision_rate = 0.0;\n  if (solver->statistics.conflicts)\n    avg_decision_rate =\n      (double) solver->statistics.decisions / (double) solver->statistics.conflicts;\n\n  // EWMA for decision rate\n  const double dec_rate_ewma = AVERAGE (decision_rate);\n\n  // Triggers:\n  // (a) Glue-based: fast >= 0.8 * slow\n  const double glue_threshold = 0.8 * slow;\n  const bool glue_trigger = (fast >= glue_threshold);\n\n  // (b) Decision-rate: ewma <= 0.5 * average\n  const double dec_rate_threshold = 0.5 * avg_decision_rate;\n  const bool dec_rate_trigger = (dec_rate_ewma <= dec_rate_threshold);\n\n  bool triggered = false;\n  int chosen_trigger = 0; // 1 = glue, 2 = decision-rate, 3 = both\n\n  if (glue_trigger && dec_rate_trigger)\n  {\n    triggered = true;\n    chosen_trigger = 3;\n  }\n  else if (glue_trigger)\n  {\n    triggered = true;\n    chosen_trigger = 1;\n  }\n  else if (dec_rate_trigger)\n  {\n    triggered = true;\n    chosen_trigger = 2;\n  }\n\n  // In stable phase, only restart if BOTH triggers fire\n  if (solver->stable && chosen_trigger != 3)\n    triggered = false;\n\n  // Do not restart if at same conflict as previous restart\n  if (triggered)\n  {\n    if (CONFLICTS == solver->last_restart_conflict)\n    {\n      // Delay by one conflict\n      solver->next_restart_at = CONFLICTS + 1;\n      return false;\n    }\n    // Set up next time and last restart\n    solver->next_restart_at = CONFLICTS + restart_conflict_limit;\n    solver->last_restart_conflict = CONFLICTS;\n\n    kissat_extremely_verbose (\n      solver,\n      \"dual-threshold restart at conflict %\" PRIu64\n      \": glue (fast %.2f, slow %.2f, %.2f threshold=%d), \"\n      \"decision-rate (ewma %.2f, avg %.2f, %.2f threshold=%d), \"\n      \"reason=%s\",\n      CONFLICTS, fast, slow, glue_threshold, glue_trigger,\n      dec_rate_ewma, avg_decision_rate, dec_rate_threshold, dec_rate_trigger,\n      chosen_trigger == 3 ? \"both\"\n      : chosen_trigger == 1 ? \"glue\"\n      : chosen_trigger == 2 ? \"decision-rate\"\n      : \"none\"\n    );\n\n    return true;\n  }\n\n  return false;\n}\n</code>"}], "role": "assistant"}], "parallel_tool_calls": true, "previous_response_id": null, "prompt_cache_key": null, "prompt_cache_retention": null, "reasoning": {"effort": null, "summary": null}, "safety_identifier": null, "service_tier": "default", "store": true, "temperature": 0.7, "text": {"format": {"type": "text"}, "verbosity": "medium"}, "tool_choice": "auto", "tools": [], "top_logprobs": 0, "top_p": 1.0, "truncation": "disabled", "usage": {"input_tokens": 672, "input_tokens_details": {"cached_tokens": 0}, "output_tokens": 761, "output_tokens_details": {"reasoning_tokens": 0}, "total_tokens": 1433}, "user": null, "metadata": {}}}, "error": null}
{"id": "batch_req_692138ab5e888190a945e60c360f2788", "custom_id": "req-0007", "response": {"status_code": 200, "request_id": "af0e94f9d44b6d7e4a61649dbbdc0910", "body": {"id": "resp_0fe9738fea73ddc4006921389dc590819e925d7afc0283d9f5", "object": "response", "created_at": 1763784861, "status": "completed", "background": false, "billing": {"payer": "developer"}, "error": null, "incomplete_details": null, "instructions": null, "max_output_tokens": null, "max_tool_calls": null, "model": "gpt-4.1-2025-04-14", "output": [{"id": "msg_0fe9738fea73ddc4006921389e1b3c819e80294f4d848fe2ee", "type": "message", "status": "completed", "content": [{"type": "output_text", "annotations": [], "logprobs": [], "text": "<code>\nbool kissat_restarting (kissat *solver) {\n  assert (solver->unassigned);\n\n  if (!GET_OPTION (restart))\n    return false;\n  if (!solver->level)\n    return false;\n\n  // Obtain current stats and thresholds\n  const uint64_t conflicts = CONFLICTS;\n  const uint64_t decisions = solver->statistics.decisions;\n  const uint64_t restart_conflict_limit = solver->limits.restart.conflicts;\n\n  // Static or persistent state to track next allowed restart\n  uint64_t *next_restart_at_ptr = &solver->restart.next_restart_at;\n  if (!*next_restart_at_ptr)\n    *next_restart_at_ptr = conflicts + restart_conflict_limit;\n\n  // Enforce minimal interval between restarts\n  if (conflicts < *next_restart_at_ptr)\n    return false;\n\n  // Prevent restarting at the same conflict as previous\n  if (conflicts == solver->restart.last_restart_conflict)\n    return false;\n\n  // Glue-based trigger\n  const double fast = AVERAGE (fast_glue);\n  const double slow = AVERAGE (slow_glue);\n  const double glue_trigger = 0.8 * slow;\n  const bool glue_based = (fast >= glue_trigger);\n\n  // Decision-rate trigger\n  const double dec_rate_ewma = AVERAGE (decision_rate);\n  double avg_decisions_per_conflict = 0.0;\n  if (conflicts)\n    avg_decisions_per_conflict = (double) decisions / (double) conflicts;\n  const double dec_trigger = 0.5 * avg_decisions_per_conflict;\n  const bool dec_based = (dec_rate_ewma <= dec_trigger);\n\n  // Stable phase logic\n  bool trigger = false;\n  if (solver->stable) {\n    // In stable mode, require both triggers\n    if (glue_based && dec_based)\n      trigger = true;\n  } else {\n    // Otherwise, prioritize glue-based trigger\n    if (glue_based)\n      trigger = true;\n    else if (dec_based)\n      trigger = true;\n  }\n\n  if (trigger) {\n    // Record restart point and block further until enough conflicts pass\n    *next_restart_at_ptr = conflicts + restart_conflict_limit;\n    solver->restart.last_restart_conflict = conflicts;\n    kissat_extremely_verbose (\n      solver,\n      \"dual-threshold restart: glue=%.2f (trigger=%.2f), dec_rate=%.2f (trigger=%.2f), next at %\" PRIu64,\n      fast, glue_trigger, dec_rate_ewma, dec_trigger, *next_restart_at_ptr\n    );\n    return true;\n  }\n\n  return false;\n}\n</code>"}], "role": "assistant"}], "parallel_tool_calls": true, "previous_response_id": null, "prompt_cache_key": null, "prompt_cache_retention": null, "reasoning": {"effort": null, "summary": null}, "safety_identifier": null, "service_tier": "default", "store": true, "temperature": 0.7, "text": {"format": {"type": "text"}, "verbosity": "medium"}, "tool_choice": "auto", "tools": [], "top_logprobs": 0, "top_p": 1.0, "truncation": "disabled", "usage": {"input_tokens": 672, "input_tokens_details": {"cached_tokens": 0}, "output_tokens": 569, "output_tokens_details": {"reasoning_tokens": 0}, "total_tokens": 1241}, "user": null, "metadata": {}}}, "error": null}
{"id": "batch_req_692138ab53ac8190b36d014ff312883e", "custom_id": "req-0008", "response": {"status_code": 200, "request_id": "075503236709d51e055d0a274dc5f1df", "body": {"id": "resp_03e7f0ae9f02652f00692138a0a794819c9a98cb1e26aea29f", "object": "response", "created_at": 1763784864, "status": "completed", "background": false, "billing": {"payer": "developer"}, "error": null, "incomplete_details": null, "instructions": null, "max_output_tokens": null, "max_tool_calls": null, "model": "gpt-4.1-2025-04-14", "output": [{"id": "msg_03e7f0ae9f02652f00692138a10004819c89d26665cf2b6742", "type": "message", "status": "completed", "content": [{"type": "output_text", "annotations": [], "logprobs": [], "text": "<code>\nbool kissat_restarting(kissat *solver)\n{\n  assert(solver->unassigned);\n  if (!GET_OPTION(restart))\n    return false;\n  if (!solver->level)\n    return false;\n\n  // Retrieve conflict limit for restart interval\n  const uint64_t restart_conflict_limit = solver->limits.restart.conflicts;\n\n  // This variable should persist across invocations (static or in solver struct)\n  // We'll use solver->restart.next_at (must be initialized in solver init!)\n  uint64_t *next_restart_at_ptr = &solver->restart.next_at;\n  if (!(*next_restart_at_ptr))\n    *next_restart_at_ptr = CONFLICTS + restart_conflict_limit;\n\n  // Only consider restart at or after the allowed next point\n  if (CONFLICTS < *next_restart_at_ptr)\n    return false;\n\n  // Prevent multiple restarts at same conflict - delay by one conflict\n  if (solver->restart.last == CONFLICTS)\n    return false;\n\n  // Compute glue EWMAs\n  const double fast_glue = AVERAGE(fast_glue);\n  const double slow_glue = AVERAGE(slow_glue);\n\n  // Compute decision rate: avg decisions per conflict\n  const uint64_t conflicts = solver->statistics.conflicts;\n  const uint64_t decisions = solver->statistics.decisions;\n  // Avoid division by zero\n  const double avg_decisions_per_conflict = conflicts ? ((double)decisions / (double)conflicts) : 1.0;\n  const double decision_rate_ewma = AVERAGE(decision_rate);\n\n  // Compute thresholds\n  const double glue_threshold = 0.8 * slow_glue;\n  const double decision_threshold = 0.5 * avg_decisions_per_conflict;\n\n  // Evaluate triggers\n  const bool glue_trigger = (fast_glue >= glue_threshold);\n  const bool decision_trigger = (decision_rate_ewma <= decision_threshold);\n\n  kissat_extremely_verbose(\n    solver,\n    \"restart glue: fast %.2f, slow %.2f, threshold %.2f [%d]; \"\n    \"decision rate: ewma %.2f, avg %.2f, threshold %.2f [%d]\",\n    fast_glue, slow_glue, glue_threshold, glue_trigger,\n    decision_rate_ewma, avg_decisions_per_conflict,\n    decision_threshold, decision_trigger);\n\n  bool restart = false;\n\n  if (solver->stable)\n  {\n    // In stable phase, require both triggers\n    if (glue_trigger && decision_trigger)\n      restart = true;\n  }\n  else\n  {\n    // In unstable phase, trigger if either fires, glue takes priority\n    if (glue_trigger)\n      restart = true;\n    else if (decision_trigger)\n      restart = true;\n  }\n\n  if (restart)\n  {\n    // Tie-breaking: if last restart was at this conflict, skip\n    if (solver->restart.last == CONFLICTS)\n      return false;\n\n    // Set next allowed restart point\n    *next_restart_at_ptr = CONFLICTS + restart_conflict_limit;\n    solver->restart.last = CONFLICTS;\n    kissat_extremely_verbose(\n      solver,\n      \"dual-threshold restart: glue[%d] decision[%d] stable[%d]\",\n      glue_trigger, decision_trigger, solver->stable);\n    return true;\n  }\n\n  return false;\n}\n</code>"}], "role": "assistant"}], "parallel_tool_calls": true, "previous_response_id": null, "prompt_cache_key": null, "prompt_cache_retention": null, "reasoning": {"effort": null, "summary": null}, "safety_identifier": null, "service_tier": "default", "store": true, "temperature": 0.7, "text": {"format": {"type": "text"}, "verbosity": "medium"}, "tool_choice": "auto", "tools": [], "top_logprobs": 0, "top_p": 1.0, "truncation": "disabled", "usage": {"input_tokens": 672, "input_tokens_details": {"cached_tokens": 0}, "output_tokens": 715, "output_tokens_details": {"reasoning_tokens": 0}, "total_tokens": 1387}, "user": null, "metadata": {}}}, "error": null}
{"id": "batch_req_692138ab5ccc819091cb0f0982325c8f", "custom_id": "req-0009", "response": {"status_code": 200, "request_id": "c2ac4e2deb3894dd4033b68b46acde23", "body": {"id": "resp_012df4aa43b20d0200692138a19f94819e966b6583566f927b", "object": "response", "created_at": 1763784865, "status": "completed", "background": false, "billing": {"payer": "developer"}, "error": null, "incomplete_details": null, "instructions": null, "max_output_tokens": null, "max_tool_calls": null, "model": "gpt-4.1-2025-04-14", "output": [{"id": "msg_012df4aa43b20d0200692138a23b78819eb6c50bc81c7cd004", "type": "message", "status": "completed", "content": [{"type": "output_text", "annotations": [], "logprobs": [], "text": "<code>\nbool kissat_restarting (kissat *solver) {\n  assert (solver->unassigned);\n\n  if (!GET_OPTION (restart))\n    return false;\n  if (!solver->level)\n    return false;\n\n  // Obtain option value for restart_conflict_limit\n  const uint64_t restart_conflict_limit = solver->limits.restart.conflicts;\n\n  // Check if enough conflicts since last restart\n  // We'll use solver->restart.next_at as the next conflict index allowed for restart\n  if (solver->statistics.conflicts < solver->restart.next_at)\n    return false;\n\n  // For tie-breaking: prevent restarts at same conflict as previous\n  if (solver->statistics.conflicts == solver->restart.last_conflict)\n    return false;\n\n  const double fast = AVERAGE(fast_glue);\n  const double slow = AVERAGE(slow_glue);\n\n  // Glue-based trigger: fast_glue_ewma >= 0.8 * slow_glue_ewma\n  const double glue_margin = 0.8;\n  const bool glue_trigger = (fast >= glue_margin * slow);\n\n  // Decision-rate-based trigger\n  // decision_rate_ewma = AVERAGE(decision_rate)\n  // stats.decisions / stats.conflicts is long-term average\n  const double decisions = (double) solver->statistics.decisions;\n  const double conflicts = (double) solver->statistics.conflicts;\n  // Prevent division by zero\n  const double avg_dec_rate = conflicts ? (decisions / conflicts) : 0.0;\n  const double dec_rate_ewma = AVERAGE(decision_rate);\n  const bool decision_trigger = (dec_rate_ewma <= 0.5 * avg_dec_rate);\n\n  // If in stable phase, suppress restarts unless both triggers fire\n  bool trigger = false;\n  if (solver->stable) {\n    trigger = (glue_trigger && decision_trigger);\n  } else {\n    trigger = glue_trigger || decision_trigger;\n  }\n\n  // Tie-breaking: if both triggers, prioritize glue-based (no-op in this design)\n  if (trigger) {\n    // Set up next allowed restart conflict\n    solver->restart.next_at = solver->statistics.conflicts + restart_conflict_limit;\n    solver->restart.last_conflict = solver->statistics.conflicts;\n    // For verbose output\n    if (glue_trigger)\n      kissat_extremely_verbose (solver,\n        \"dual-threshold restart: glue trigger (fast %.2f >= %.2f * slow %.2f)\",\n        fast, glue_margin, slow);\n    else if (decision_trigger)\n      kissat_extremely_verbose (solver,\n        \"dual-threshold restart: decision rate trigger (ewma %.4f <= 0.5 * avg %.4f)\",\n        dec_rate_ewma, avg_dec_rate);\n    else\n      kissat_extremely_verbose (solver,\n        \"dual-threshold restart: unknown trigger (should not occur)\");\n    return true;\n  }\n\n  return false;\n}\n</code>"}], "role": "assistant"}], "parallel_tool_calls": true, "previous_response_id": null, "prompt_cache_key": null, "prompt_cache_retention": null, "reasoning": {"effort": null, "summary": null}, "safety_identifier": null, "service_tier": "default", "store": true, "temperature": 0.7, "text": {"format": {"type": "text"}, "verbosity": "medium"}, "tool_choice": "auto", "tools": [], "top_logprobs": 0, "top_p": 1.0, "truncation": "disabled", "usage": {"input_tokens": 672, "input_tokens_details": {"cached_tokens": 0}, "output_tokens": 632, "output_tokens_details": {"reasoning_tokens": 0}, "total_tokens": 1304}, "user": null, "metadata": {}}}, "error": null}
{"id": "batch_req_692138ab4aac8190a2932fa6b98d5e31", "custom_id": "req-0010", "response": {"status_code": 200, "request_id": "541aef79e88ffa69f9335f9ca07912c1", "body": {"id": "resp_0f597f3b6647377000692138a2d3f881a09cc4c67d255e65a1", "object": "response", "created_at": 1763784866, "status": "completed", "background": false, "billing": {"payer": "developer"}, "error": null, "incomplete_details": null, "instructions": null, "max_output_tokens": null, "max_tool_calls": null, "model": "gpt-4.1-2025-04-14", "output": [{"id": "msg_0f597f3b6647377000692138a32ac081a09a8c51f64903c76a", "type": "message", "status": "completed", "content": [{"type": "output_text", "annotations": [], "logprobs": [], "text": "<code>\nbool kissat_restarting(kissat *solver) {\n  assert(solver->unassigned);\n  // Option check\n  if (!GET_OPTION(restart))\n    return false;\n  if (!solver->level)\n    return false;\n\n  // Conflict limit check for throttling\n  const uint64_t restart_conflict_limit = solver->limits.restart.conflicts;\n  static uint64_t next_restart_at = 0;\n  uint64_t current_conflicts = CONFLICTS;\n\n  // Initialize on first call\n  if (next_restart_at < current_conflicts)\n    next_restart_at = current_conflicts + restart_conflict_limit;\n\n  // Only consider restart at or after next_restart_at\n  if (current_conflicts < next_restart_at)\n    return false;\n\n  // EWMA glue averages\n  const double fast = AVERAGE(fast_glue);\n  const double slow = AVERAGE(slow_glue);\n  // EWMA decision rate (decisions per conflict)\n  const double decision_rate_ewma = AVERAGE(decision_rate);\n\n  // Long-term decision rate: total decisions / total conflicts (avoid div by zero)\n  double long_term_decision_rate = 0.0;\n  if (solver->statistics.conflicts > 0)\n    long_term_decision_rate = (double) solver->statistics.decisions /\n                              (double) solver->statistics.conflicts;\n\n  // Glue-based trigger (a)\n  bool glue_trigger = (fast >= 0.8 * slow);\n  // Decision-rate-based trigger (b)\n  bool decision_trigger = false;\n  if (long_term_decision_rate > 0.0)\n    decision_trigger = (decision_rate_ewma <= 0.5 * long_term_decision_rate);\n\n  // If both triggers fire, glue is prioritized (for logging only)\n  bool restart = false;\n  if (solver->stable) {\n    // In stable phase, only restart if both triggers fire\n    if (glue_trigger && decision_trigger)\n      restart = true;\n  } else {\n    // In non-stable, restart if either fires\n    if (glue_trigger || decision_trigger)\n      restart = true;\n  }\n\n  // Tie-breaking: If at same conflict as previous restart, delay by one conflict\n  static uint64_t last_restart_conflict = 0;\n  if (restart) {\n    if (current_conflicts == last_restart_conflict) {\n      // Delay restart to next conflict\n      next_restart_at = current_conflicts + 1;\n      return false;\n    }\n    // Proceed with restart, update bookkeeping\n    last_restart_conflict = current_conflicts;\n    next_restart_at = current_conflicts + restart_conflict_limit;\n    // Logging\n    kissat_extremely_verbose(\n      solver,\n      \"dual-threshold restart: fast_glue %.2f, slow_glue %.2f, decision_rate %.2f, long_term_decision_rate %.2f, triggers: glue=%d, decision=%d, stable=%d\",\n      fast, slow, decision_rate_ewma, long_term_decision_rate, glue_trigger, decision_trigger, solver->stable\n    );\n    return true;\n  }\n\n  // No restart; if we've waited past next_restart_at, increment it so we don't check every conflict\n  if (current_conflicts >= next_restart_at)\n    next_restart_at = current_conflicts + 1;\n  return false;\n}\n</code>"}], "role": "assistant"}], "parallel_tool_calls": true, "previous_response_id": null, "prompt_cache_key": null, "prompt_cache_retention": null, "reasoning": {"effort": null, "summary": null}, "safety_identifier": null, "service_tier": "default", "store": true, "temperature": 0.7, "text": {"format": {"type": "text"}, "verbosity": "medium"}, "tool_choice": "auto", "tools": [], "top_logprobs": 0, "top_p": 1.0, "truncation": "disabled", "usage": {"input_tokens": 672, "input_tokens_details": {"cached_tokens": 0}, "output_tokens": 716, "output_tokens_details": {"reasoning_tokens": 0}, "total_tokens": 1388}, "user": null, "metadata": {}}}, "error": null}
