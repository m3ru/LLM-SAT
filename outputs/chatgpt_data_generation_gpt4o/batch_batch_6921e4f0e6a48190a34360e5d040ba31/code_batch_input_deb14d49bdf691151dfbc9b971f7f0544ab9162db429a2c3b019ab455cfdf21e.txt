{"custom_id": "req-0001", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are an expert SAT solver developer that generates compilable source code for a given algorithm in Kissat solver.\nYour final code must be the kissat_restarting function with complete signature and return type. That is the only output you should output. The code will be replacing the kissat_restarting function in the restart.c file.\nYou MUST give your final code in following format (replace the content inside <code> and </code> with your code):\n\n<code>\n(your code here)\n</code>\n\n- You must only use attributes and functions that are defined in Kissat solver and available in restarting function.\n- You need to think carefully, make sure your code compiles in Kissat solver.\n\n### Available Internal Attributes\n- is stable stage — source: solver->stable\n- level — source: solver->level\n- number of conflicts — source: solver->statistics.conflicts\n- number of decisions — source: solver->statistics.decisions\n- limit of conflicts — source: solver->limits.restart.conflicts\n- fast averge of glue — source: solver->averages[solver->stable].fast_glue.value\n- slow averge of glue — source: solver->averages[solver->stable].slow_glue.value\n- decision rate moving average — source: solver->averages[solver->stable].decision_rate.value\n\nAlgorithm specification:\n{algorithm}\n\nReference (Kissat SAT restarting function):\n\nbool kissat_restarting (kissat *solver) {\n    assert (solver->unassigned);\n    if (!GET_OPTION (restart))\n    return false;\n    if (!solver->level)\n    return false;\n    if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n    if (solver->stable)\n    return kissat_reluctant_triggered (&solver->reluctant);\n    const double fast = AVERAGE (fast_glue);\n    const double slow = AVERAGE (slow_glue);\n    const double margin = (100.0 + GET_OPTION (restartmargin)) / 100.0;\n    const double limit = margin * slow;\n    kissat_extremely_verbose (solver,\n                                \"restart glue limit %g = \"\n                                \"%.02f * %g (slow glue) %c %g (fast glue)\",\n                                limit, margin, slow,\n                                (limit > fast    ? '>'\n                                : limit == fast ? '='\n                                                : '<'),\n                                fast);\n    return (limit <= fast);\n}\n\n\n\nAlgorithm:\n{\"Algorithm Name\": \"Adaptive Glue-Rate Hybrid Restart\", \"Scoring Function Definition\": \"Restart fires when (fast_glue_ewma > 0.9 * slow_glue_ewma) AND (decision_rate_ewma < 0.8 * avg_decision_rate), OR when stats.conflicts ≥ restart_conflict_limit. avg_decision_rate is the EWMA of decision_rate_ewma over the last k restarts (k=10).\", \"Selection Procedure\": [\"At each conflict, update fast_glue_ewma, slow_glue_ewma, and decision_rate_ewma.\", \"Compute avg_decision_rate as the EWMA over the last 10 restart intervals.\", \"Check if fast_glue_ewma > 0.9 * slow_glue_ewma AND decision_rate_ewma < 0.8 * avg_decision_rate.\", \"If condition in step 3 is true or stats.conflicts ≥ restart_conflict_limit, trigger a restart.\", \"Reset counters and update avg_decision_rate after each restart.\"], \"Tie-breaking Rules\": [\"If both scoring and conflict-limit triggers fire simultaneously, prioritize the scoring trigger.\", \"If scoring trigger is met but at decision level 0, delay restart until level > 0.\", \"If multiple restarts are possible within the same conflict, perform only one.\", \"If stable is true, double the thresholds before triggering.\"]}"}], "temperature": 0.7}}
{"custom_id": "req-0002", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are an expert SAT solver developer that generates compilable source code for a given algorithm in Kissat solver.\nYour final code must be the kissat_restarting function with complete signature and return type. That is the only output you should output. The code will be replacing the kissat_restarting function in the restart.c file.\nYou MUST give your final code in following format (replace the content inside <code> and </code> with your code):\n\n<code>\n(your code here)\n</code>\n\n- You must only use attributes and functions that are defined in Kissat solver and available in restarting function.\n- You need to think carefully, make sure your code compiles in Kissat solver.\n\n### Available Internal Attributes\n- is stable stage — source: solver->stable\n- level — source: solver->level\n- number of conflicts — source: solver->statistics.conflicts\n- number of decisions — source: solver->statistics.decisions\n- limit of conflicts — source: solver->limits.restart.conflicts\n- fast averge of glue — source: solver->averages[solver->stable].fast_glue.value\n- slow averge of glue — source: solver->averages[solver->stable].slow_glue.value\n- decision rate moving average — source: solver->averages[solver->stable].decision_rate.value\n\nAlgorithm specification:\n{algorithm}\n\nReference (Kissat SAT restarting function):\n\nbool kissat_restarting (kissat *solver) {\n    assert (solver->unassigned);\n    if (!GET_OPTION (restart))\n    return false;\n    if (!solver->level)\n    return false;\n    if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n    if (solver->stable)\n    return kissat_reluctant_triggered (&solver->reluctant);\n    const double fast = AVERAGE (fast_glue);\n    const double slow = AVERAGE (slow_glue);\n    const double margin = (100.0 + GET_OPTION (restartmargin)) / 100.0;\n    const double limit = margin * slow;\n    kissat_extremely_verbose (solver,\n                                \"restart glue limit %g = \"\n                                \"%.02f * %g (slow glue) %c %g (fast glue)\",\n                                limit, margin, slow,\n                                (limit > fast    ? '>'\n                                : limit == fast ? '='\n                                                : '<'),\n                                fast);\n    return (limit <= fast);\n}\n\n\n\nAlgorithm:\n{\"Algorithm Name\": \"Adaptive Glue-Rate Hybrid Restart\", \"Scoring Function Definition\": \"Restart fires when (fast_glue_ewma > 0.9 * slow_glue_ewma) AND (decision_rate_ewma < 0.8 * avg_decision_rate), OR when stats.conflicts ≥ restart_conflict_limit. avg_decision_rate is the EWMA of decision_rate_ewma over the last k restarts (k=10).\", \"Selection Procedure\": [\"At each conflict, update fast_glue_ewma, slow_glue_ewma, and decision_rate_ewma.\", \"Compute avg_decision_rate as the EWMA over the last 10 restart intervals.\", \"Check if fast_glue_ewma > 0.9 * slow_glue_ewma AND decision_rate_ewma < 0.8 * avg_decision_rate.\", \"If condition in step 3 is true or stats.conflicts ≥ restart_conflict_limit, trigger a restart.\", \"Reset counters and update avg_decision_rate after each restart.\"], \"Tie-breaking Rules\": [\"If both scoring and conflict-limit triggers fire simultaneously, prioritize the scoring trigger.\", \"If scoring trigger is met but at decision level 0, delay restart until level > 0.\", \"If multiple restarts are possible within the same conflict, perform only one.\", \"If stable is true, double the thresholds before triggering.\"]}"}], "temperature": 0.7}}
{"custom_id": "req-0003", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are an expert SAT solver developer that generates compilable source code for a given algorithm in Kissat solver.\nYour final code must be the kissat_restarting function with complete signature and return type. That is the only output you should output. The code will be replacing the kissat_restarting function in the restart.c file.\nYou MUST give your final code in following format (replace the content inside <code> and </code> with your code):\n\n<code>\n(your code here)\n</code>\n\n- You must only use attributes and functions that are defined in Kissat solver and available in restarting function.\n- You need to think carefully, make sure your code compiles in Kissat solver.\n\n### Available Internal Attributes\n- is stable stage — source: solver->stable\n- level — source: solver->level\n- number of conflicts — source: solver->statistics.conflicts\n- number of decisions — source: solver->statistics.decisions\n- limit of conflicts — source: solver->limits.restart.conflicts\n- fast averge of glue — source: solver->averages[solver->stable].fast_glue.value\n- slow averge of glue — source: solver->averages[solver->stable].slow_glue.value\n- decision rate moving average — source: solver->averages[solver->stable].decision_rate.value\n\nAlgorithm specification:\n{algorithm}\n\nReference (Kissat SAT restarting function):\n\nbool kissat_restarting (kissat *solver) {\n    assert (solver->unassigned);\n    if (!GET_OPTION (restart))\n    return false;\n    if (!solver->level)\n    return false;\n    if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n    if (solver->stable)\n    return kissat_reluctant_triggered (&solver->reluctant);\n    const double fast = AVERAGE (fast_glue);\n    const double slow = AVERAGE (slow_glue);\n    const double margin = (100.0 + GET_OPTION (restartmargin)) / 100.0;\n    const double limit = margin * slow;\n    kissat_extremely_verbose (solver,\n                                \"restart glue limit %g = \"\n                                \"%.02f * %g (slow glue) %c %g (fast glue)\",\n                                limit, margin, slow,\n                                (limit > fast    ? '>'\n                                : limit == fast ? '='\n                                                : '<'),\n                                fast);\n    return (limit <= fast);\n}\n\n\n\nAlgorithm:\n{\"Algorithm Name\": \"Adaptive Glue-Rate Hybrid Restart\", \"Scoring Function Definition\": \"Restart fires when (fast_glue_ewma > 0.9 * slow_glue_ewma) AND (decision_rate_ewma < 0.8 * avg_decision_rate), OR when stats.conflicts ≥ restart_conflict_limit. avg_decision_rate is the EWMA of decision_rate_ewma over the last k restarts (k=10).\", \"Selection Procedure\": [\"At each conflict, update fast_glue_ewma, slow_glue_ewma, and decision_rate_ewma.\", \"Compute avg_decision_rate as the EWMA over the last 10 restart intervals.\", \"Check if fast_glue_ewma > 0.9 * slow_glue_ewma AND decision_rate_ewma < 0.8 * avg_decision_rate.\", \"If condition in step 3 is true or stats.conflicts ≥ restart_conflict_limit, trigger a restart.\", \"Reset counters and update avg_decision_rate after each restart.\"], \"Tie-breaking Rules\": [\"If both scoring and conflict-limit triggers fire simultaneously, prioritize the scoring trigger.\", \"If scoring trigger is met but at decision level 0, delay restart until level > 0.\", \"If multiple restarts are possible within the same conflict, perform only one.\", \"If stable is true, double the thresholds before triggering.\"]}"}], "temperature": 0.7}}
{"custom_id": "req-0004", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are an expert SAT solver developer that generates compilable source code for a given algorithm in Kissat solver.\nYour final code must be the kissat_restarting function with complete signature and return type. That is the only output you should output. The code will be replacing the kissat_restarting function in the restart.c file.\nYou MUST give your final code in following format (replace the content inside <code> and </code> with your code):\n\n<code>\n(your code here)\n</code>\n\n- You must only use attributes and functions that are defined in Kissat solver and available in restarting function.\n- You need to think carefully, make sure your code compiles in Kissat solver.\n\n### Available Internal Attributes\n- is stable stage — source: solver->stable\n- level — source: solver->level\n- number of conflicts — source: solver->statistics.conflicts\n- number of decisions — source: solver->statistics.decisions\n- limit of conflicts — source: solver->limits.restart.conflicts\n- fast averge of glue — source: solver->averages[solver->stable].fast_glue.value\n- slow averge of glue — source: solver->averages[solver->stable].slow_glue.value\n- decision rate moving average — source: solver->averages[solver->stable].decision_rate.value\n\nAlgorithm specification:\n{algorithm}\n\nReference (Kissat SAT restarting function):\n\nbool kissat_restarting (kissat *solver) {\n    assert (solver->unassigned);\n    if (!GET_OPTION (restart))\n    return false;\n    if (!solver->level)\n    return false;\n    if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n    if (solver->stable)\n    return kissat_reluctant_triggered (&solver->reluctant);\n    const double fast = AVERAGE (fast_glue);\n    const double slow = AVERAGE (slow_glue);\n    const double margin = (100.0 + GET_OPTION (restartmargin)) / 100.0;\n    const double limit = margin * slow;\n    kissat_extremely_verbose (solver,\n                                \"restart glue limit %g = \"\n                                \"%.02f * %g (slow glue) %c %g (fast glue)\",\n                                limit, margin, slow,\n                                (limit > fast    ? '>'\n                                : limit == fast ? '='\n                                                : '<'),\n                                fast);\n    return (limit <= fast);\n}\n\n\n\nAlgorithm:\n{\"Algorithm Name\": \"Adaptive Glue-Rate Hybrid Restart\", \"Scoring Function Definition\": \"Restart fires when (fast_glue_ewma > 0.9 * slow_glue_ewma) AND (decision_rate_ewma < 0.8 * avg_decision_rate), OR when stats.conflicts ≥ restart_conflict_limit. avg_decision_rate is the EWMA of decision_rate_ewma over the last k restarts (k=10).\", \"Selection Procedure\": [\"At each conflict, update fast_glue_ewma, slow_glue_ewma, and decision_rate_ewma.\", \"Compute avg_decision_rate as the EWMA over the last 10 restart intervals.\", \"Check if fast_glue_ewma > 0.9 * slow_glue_ewma AND decision_rate_ewma < 0.8 * avg_decision_rate.\", \"If condition in step 3 is true or stats.conflicts ≥ restart_conflict_limit, trigger a restart.\", \"Reset counters and update avg_decision_rate after each restart.\"], \"Tie-breaking Rules\": [\"If both scoring and conflict-limit triggers fire simultaneously, prioritize the scoring trigger.\", \"If scoring trigger is met but at decision level 0, delay restart until level > 0.\", \"If multiple restarts are possible within the same conflict, perform only one.\", \"If stable is true, double the thresholds before triggering.\"]}"}], "temperature": 0.7}}
{"custom_id": "req-0005", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are an expert SAT solver developer that generates compilable source code for a given algorithm in Kissat solver.\nYour final code must be the kissat_restarting function with complete signature and return type. That is the only output you should output. The code will be replacing the kissat_restarting function in the restart.c file.\nYou MUST give your final code in following format (replace the content inside <code> and </code> with your code):\n\n<code>\n(your code here)\n</code>\n\n- You must only use attributes and functions that are defined in Kissat solver and available in restarting function.\n- You need to think carefully, make sure your code compiles in Kissat solver.\n\n### Available Internal Attributes\n- is stable stage — source: solver->stable\n- level — source: solver->level\n- number of conflicts — source: solver->statistics.conflicts\n- number of decisions — source: solver->statistics.decisions\n- limit of conflicts — source: solver->limits.restart.conflicts\n- fast averge of glue — source: solver->averages[solver->stable].fast_glue.value\n- slow averge of glue — source: solver->averages[solver->stable].slow_glue.value\n- decision rate moving average — source: solver->averages[solver->stable].decision_rate.value\n\nAlgorithm specification:\n{algorithm}\n\nReference (Kissat SAT restarting function):\n\nbool kissat_restarting (kissat *solver) {\n    assert (solver->unassigned);\n    if (!GET_OPTION (restart))\n    return false;\n    if (!solver->level)\n    return false;\n    if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n    if (solver->stable)\n    return kissat_reluctant_triggered (&solver->reluctant);\n    const double fast = AVERAGE (fast_glue);\n    const double slow = AVERAGE (slow_glue);\n    const double margin = (100.0 + GET_OPTION (restartmargin)) / 100.0;\n    const double limit = margin * slow;\n    kissat_extremely_verbose (solver,\n                                \"restart glue limit %g = \"\n                                \"%.02f * %g (slow glue) %c %g (fast glue)\",\n                                limit, margin, slow,\n                                (limit > fast    ? '>'\n                                : limit == fast ? '='\n                                                : '<'),\n                                fast);\n    return (limit <= fast);\n}\n\n\n\nAlgorithm:\n{\"Algorithm Name\": \"Adaptive Glue-Rate Hybrid Restart\", \"Scoring Function Definition\": \"Restart fires when (fast_glue_ewma > 0.9 * slow_glue_ewma) AND (decision_rate_ewma < 0.8 * avg_decision_rate), OR when stats.conflicts ≥ restart_conflict_limit. avg_decision_rate is the EWMA of decision_rate_ewma over the last k restarts (k=10).\", \"Selection Procedure\": [\"At each conflict, update fast_glue_ewma, slow_glue_ewma, and decision_rate_ewma.\", \"Compute avg_decision_rate as the EWMA over the last 10 restart intervals.\", \"Check if fast_glue_ewma > 0.9 * slow_glue_ewma AND decision_rate_ewma < 0.8 * avg_decision_rate.\", \"If condition in step 3 is true or stats.conflicts ≥ restart_conflict_limit, trigger a restart.\", \"Reset counters and update avg_decision_rate after each restart.\"], \"Tie-breaking Rules\": [\"If both scoring and conflict-limit triggers fire simultaneously, prioritize the scoring trigger.\", \"If scoring trigger is met but at decision level 0, delay restart until level > 0.\", \"If multiple restarts are possible within the same conflict, perform only one.\", \"If stable is true, double the thresholds before triggering.\"]}"}], "temperature": 0.7}}
{"custom_id": "req-0006", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are an expert SAT solver developer that generates compilable source code for a given algorithm in Kissat solver.\nYour final code must be the kissat_restarting function with complete signature and return type. That is the only output you should output. The code will be replacing the kissat_restarting function in the restart.c file.\nYou MUST give your final code in following format (replace the content inside <code> and </code> with your code):\n\n<code>\n(your code here)\n</code>\n\n- You must only use attributes and functions that are defined in Kissat solver and available in restarting function.\n- You need to think carefully, make sure your code compiles in Kissat solver.\n\n### Available Internal Attributes\n- is stable stage — source: solver->stable\n- level — source: solver->level\n- number of conflicts — source: solver->statistics.conflicts\n- number of decisions — source: solver->statistics.decisions\n- limit of conflicts — source: solver->limits.restart.conflicts\n- fast averge of glue — source: solver->averages[solver->stable].fast_glue.value\n- slow averge of glue — source: solver->averages[solver->stable].slow_glue.value\n- decision rate moving average — source: solver->averages[solver->stable].decision_rate.value\n\nAlgorithm specification:\n{algorithm}\n\nReference (Kissat SAT restarting function):\n\nbool kissat_restarting (kissat *solver) {\n    assert (solver->unassigned);\n    if (!GET_OPTION (restart))\n    return false;\n    if (!solver->level)\n    return false;\n    if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n    if (solver->stable)\n    return kissat_reluctant_triggered (&solver->reluctant);\n    const double fast = AVERAGE (fast_glue);\n    const double slow = AVERAGE (slow_glue);\n    const double margin = (100.0 + GET_OPTION (restartmargin)) / 100.0;\n    const double limit = margin * slow;\n    kissat_extremely_verbose (solver,\n                                \"restart glue limit %g = \"\n                                \"%.02f * %g (slow glue) %c %g (fast glue)\",\n                                limit, margin, slow,\n                                (limit > fast    ? '>'\n                                : limit == fast ? '='\n                                                : '<'),\n                                fast);\n    return (limit <= fast);\n}\n\n\n\nAlgorithm:\n{\"Algorithm Name\": \"Adaptive Glue-Rate Hybrid Restart\", \"Scoring Function Definition\": \"Restart fires when (fast_glue_ewma > 0.9 * slow_glue_ewma) AND (decision_rate_ewma < 0.8 * avg_decision_rate), OR when stats.conflicts ≥ restart_conflict_limit. avg_decision_rate is the EWMA of decision_rate_ewma over the last k restarts (k=10).\", \"Selection Procedure\": [\"At each conflict, update fast_glue_ewma, slow_glue_ewma, and decision_rate_ewma.\", \"Compute avg_decision_rate as the EWMA over the last 10 restart intervals.\", \"Check if fast_glue_ewma > 0.9 * slow_glue_ewma AND decision_rate_ewma < 0.8 * avg_decision_rate.\", \"If condition in step 3 is true or stats.conflicts ≥ restart_conflict_limit, trigger a restart.\", \"Reset counters and update avg_decision_rate after each restart.\"], \"Tie-breaking Rules\": [\"If both scoring and conflict-limit triggers fire simultaneously, prioritize the scoring trigger.\", \"If scoring trigger is met but at decision level 0, delay restart until level > 0.\", \"If multiple restarts are possible within the same conflict, perform only one.\", \"If stable is true, double the thresholds before triggering.\"]}"}], "temperature": 0.7}}
{"custom_id": "req-0007", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are an expert SAT solver developer that generates compilable source code for a given algorithm in Kissat solver.\nYour final code must be the kissat_restarting function with complete signature and return type. That is the only output you should output. The code will be replacing the kissat_restarting function in the restart.c file.\nYou MUST give your final code in following format (replace the content inside <code> and </code> with your code):\n\n<code>\n(your code here)\n</code>\n\n- You must only use attributes and functions that are defined in Kissat solver and available in restarting function.\n- You need to think carefully, make sure your code compiles in Kissat solver.\n\n### Available Internal Attributes\n- is stable stage — source: solver->stable\n- level — source: solver->level\n- number of conflicts — source: solver->statistics.conflicts\n- number of decisions — source: solver->statistics.decisions\n- limit of conflicts — source: solver->limits.restart.conflicts\n- fast averge of glue — source: solver->averages[solver->stable].fast_glue.value\n- slow averge of glue — source: solver->averages[solver->stable].slow_glue.value\n- decision rate moving average — source: solver->averages[solver->stable].decision_rate.value\n\nAlgorithm specification:\n{algorithm}\n\nReference (Kissat SAT restarting function):\n\nbool kissat_restarting (kissat *solver) {\n    assert (solver->unassigned);\n    if (!GET_OPTION (restart))\n    return false;\n    if (!solver->level)\n    return false;\n    if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n    if (solver->stable)\n    return kissat_reluctant_triggered (&solver->reluctant);\n    const double fast = AVERAGE (fast_glue);\n    const double slow = AVERAGE (slow_glue);\n    const double margin = (100.0 + GET_OPTION (restartmargin)) / 100.0;\n    const double limit = margin * slow;\n    kissat_extremely_verbose (solver,\n                                \"restart glue limit %g = \"\n                                \"%.02f * %g (slow glue) %c %g (fast glue)\",\n                                limit, margin, slow,\n                                (limit > fast    ? '>'\n                                : limit == fast ? '='\n                                                : '<'),\n                                fast);\n    return (limit <= fast);\n}\n\n\n\nAlgorithm:\n{\"Algorithm Name\": \"Adaptive Glue-Rate Hybrid Restart\", \"Scoring Function Definition\": \"Restart fires when (fast_glue_ewma > 0.9 * slow_glue_ewma) AND (decision_rate_ewma < 0.8 * avg_decision_rate), OR when stats.conflicts ≥ restart_conflict_limit. avg_decision_rate is the EWMA of decision_rate_ewma over the last k restarts (k=10).\", \"Selection Procedure\": [\"At each conflict, update fast_glue_ewma, slow_glue_ewma, and decision_rate_ewma.\", \"Compute avg_decision_rate as the EWMA over the last 10 restart intervals.\", \"Check if fast_glue_ewma > 0.9 * slow_glue_ewma AND decision_rate_ewma < 0.8 * avg_decision_rate.\", \"If condition in step 3 is true or stats.conflicts ≥ restart_conflict_limit, trigger a restart.\", \"Reset counters and update avg_decision_rate after each restart.\"], \"Tie-breaking Rules\": [\"If both scoring and conflict-limit triggers fire simultaneously, prioritize the scoring trigger.\", \"If scoring trigger is met but at decision level 0, delay restart until level > 0.\", \"If multiple restarts are possible within the same conflict, perform only one.\", \"If stable is true, double the thresholds before triggering.\"]}"}], "temperature": 0.7}}
{"custom_id": "req-0008", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are an expert SAT solver developer that generates compilable source code for a given algorithm in Kissat solver.\nYour final code must be the kissat_restarting function with complete signature and return type. That is the only output you should output. The code will be replacing the kissat_restarting function in the restart.c file.\nYou MUST give your final code in following format (replace the content inside <code> and </code> with your code):\n\n<code>\n(your code here)\n</code>\n\n- You must only use attributes and functions that are defined in Kissat solver and available in restarting function.\n- You need to think carefully, make sure your code compiles in Kissat solver.\n\n### Available Internal Attributes\n- is stable stage — source: solver->stable\n- level — source: solver->level\n- number of conflicts — source: solver->statistics.conflicts\n- number of decisions — source: solver->statistics.decisions\n- limit of conflicts — source: solver->limits.restart.conflicts\n- fast averge of glue — source: solver->averages[solver->stable].fast_glue.value\n- slow averge of glue — source: solver->averages[solver->stable].slow_glue.value\n- decision rate moving average — source: solver->averages[solver->stable].decision_rate.value\n\nAlgorithm specification:\n{algorithm}\n\nReference (Kissat SAT restarting function):\n\nbool kissat_restarting (kissat *solver) {\n    assert (solver->unassigned);\n    if (!GET_OPTION (restart))\n    return false;\n    if (!solver->level)\n    return false;\n    if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n    if (solver->stable)\n    return kissat_reluctant_triggered (&solver->reluctant);\n    const double fast = AVERAGE (fast_glue);\n    const double slow = AVERAGE (slow_glue);\n    const double margin = (100.0 + GET_OPTION (restartmargin)) / 100.0;\n    const double limit = margin * slow;\n    kissat_extremely_verbose (solver,\n                                \"restart glue limit %g = \"\n                                \"%.02f * %g (slow glue) %c %g (fast glue)\",\n                                limit, margin, slow,\n                                (limit > fast    ? '>'\n                                : limit == fast ? '='\n                                                : '<'),\n                                fast);\n    return (limit <= fast);\n}\n\n\n\nAlgorithm:\n{\"Algorithm Name\": \"Adaptive Glue-Rate Hybrid Restart\", \"Scoring Function Definition\": \"Restart fires when (fast_glue_ewma > 0.9 * slow_glue_ewma) AND (decision_rate_ewma < 0.8 * avg_decision_rate), OR when stats.conflicts ≥ restart_conflict_limit. avg_decision_rate is the EWMA of decision_rate_ewma over the last k restarts (k=10).\", \"Selection Procedure\": [\"At each conflict, update fast_glue_ewma, slow_glue_ewma, and decision_rate_ewma.\", \"Compute avg_decision_rate as the EWMA over the last 10 restart intervals.\", \"Check if fast_glue_ewma > 0.9 * slow_glue_ewma AND decision_rate_ewma < 0.8 * avg_decision_rate.\", \"If condition in step 3 is true or stats.conflicts ≥ restart_conflict_limit, trigger a restart.\", \"Reset counters and update avg_decision_rate after each restart.\"], \"Tie-breaking Rules\": [\"If both scoring and conflict-limit triggers fire simultaneously, prioritize the scoring trigger.\", \"If scoring trigger is met but at decision level 0, delay restart until level > 0.\", \"If multiple restarts are possible within the same conflict, perform only one.\", \"If stable is true, double the thresholds before triggering.\"]}"}], "temperature": 0.7}}
{"custom_id": "req-0009", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are an expert SAT solver developer that generates compilable source code for a given algorithm in Kissat solver.\nYour final code must be the kissat_restarting function with complete signature and return type. That is the only output you should output. The code will be replacing the kissat_restarting function in the restart.c file.\nYou MUST give your final code in following format (replace the content inside <code> and </code> with your code):\n\n<code>\n(your code here)\n</code>\n\n- You must only use attributes and functions that are defined in Kissat solver and available in restarting function.\n- You need to think carefully, make sure your code compiles in Kissat solver.\n\n### Available Internal Attributes\n- is stable stage — source: solver->stable\n- level — source: solver->level\n- number of conflicts — source: solver->statistics.conflicts\n- number of decisions — source: solver->statistics.decisions\n- limit of conflicts — source: solver->limits.restart.conflicts\n- fast averge of glue — source: solver->averages[solver->stable].fast_glue.value\n- slow averge of glue — source: solver->averages[solver->stable].slow_glue.value\n- decision rate moving average — source: solver->averages[solver->stable].decision_rate.value\n\nAlgorithm specification:\n{algorithm}\n\nReference (Kissat SAT restarting function):\n\nbool kissat_restarting (kissat *solver) {\n    assert (solver->unassigned);\n    if (!GET_OPTION (restart))\n    return false;\n    if (!solver->level)\n    return false;\n    if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n    if (solver->stable)\n    return kissat_reluctant_triggered (&solver->reluctant);\n    const double fast = AVERAGE (fast_glue);\n    const double slow = AVERAGE (slow_glue);\n    const double margin = (100.0 + GET_OPTION (restartmargin)) / 100.0;\n    const double limit = margin * slow;\n    kissat_extremely_verbose (solver,\n                                \"restart glue limit %g = \"\n                                \"%.02f * %g (slow glue) %c %g (fast glue)\",\n                                limit, margin, slow,\n                                (limit > fast    ? '>'\n                                : limit == fast ? '='\n                                                : '<'),\n                                fast);\n    return (limit <= fast);\n}\n\n\n\nAlgorithm:\n{\"Algorithm Name\": \"Adaptive Glue-Rate Hybrid Restart\", \"Scoring Function Definition\": \"Restart fires when (fast_glue_ewma > 0.9 * slow_glue_ewma) AND (decision_rate_ewma < 0.8 * avg_decision_rate), OR when stats.conflicts ≥ restart_conflict_limit. avg_decision_rate is the EWMA of decision_rate_ewma over the last k restarts (k=10).\", \"Selection Procedure\": [\"At each conflict, update fast_glue_ewma, slow_glue_ewma, and decision_rate_ewma.\", \"Compute avg_decision_rate as the EWMA over the last 10 restart intervals.\", \"Check if fast_glue_ewma > 0.9 * slow_glue_ewma AND decision_rate_ewma < 0.8 * avg_decision_rate.\", \"If condition in step 3 is true or stats.conflicts ≥ restart_conflict_limit, trigger a restart.\", \"Reset counters and update avg_decision_rate after each restart.\"], \"Tie-breaking Rules\": [\"If both scoring and conflict-limit triggers fire simultaneously, prioritize the scoring trigger.\", \"If scoring trigger is met but at decision level 0, delay restart until level > 0.\", \"If multiple restarts are possible within the same conflict, perform only one.\", \"If stable is true, double the thresholds before triggering.\"]}"}], "temperature": 0.7}}
{"custom_id": "req-0010", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4.1", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are an expert SAT solver developer that generates compilable source code for a given algorithm in Kissat solver.\nYour final code must be the kissat_restarting function with complete signature and return type. That is the only output you should output. The code will be replacing the kissat_restarting function in the restart.c file.\nYou MUST give your final code in following format (replace the content inside <code> and </code> with your code):\n\n<code>\n(your code here)\n</code>\n\n- You must only use attributes and functions that are defined in Kissat solver and available in restarting function.\n- You need to think carefully, make sure your code compiles in Kissat solver.\n\n### Available Internal Attributes\n- is stable stage — source: solver->stable\n- level — source: solver->level\n- number of conflicts — source: solver->statistics.conflicts\n- number of decisions — source: solver->statistics.decisions\n- limit of conflicts — source: solver->limits.restart.conflicts\n- fast averge of glue — source: solver->averages[solver->stable].fast_glue.value\n- slow averge of glue — source: solver->averages[solver->stable].slow_glue.value\n- decision rate moving average — source: solver->averages[solver->stable].decision_rate.value\n\nAlgorithm specification:\n{algorithm}\n\nReference (Kissat SAT restarting function):\n\nbool kissat_restarting (kissat *solver) {\n    assert (solver->unassigned);\n    if (!GET_OPTION (restart))\n    return false;\n    if (!solver->level)\n    return false;\n    if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n    if (solver->stable)\n    return kissat_reluctant_triggered (&solver->reluctant);\n    const double fast = AVERAGE (fast_glue);\n    const double slow = AVERAGE (slow_glue);\n    const double margin = (100.0 + GET_OPTION (restartmargin)) / 100.0;\n    const double limit = margin * slow;\n    kissat_extremely_verbose (solver,\n                                \"restart glue limit %g = \"\n                                \"%.02f * %g (slow glue) %c %g (fast glue)\",\n                                limit, margin, slow,\n                                (limit > fast    ? '>'\n                                : limit == fast ? '='\n                                                : '<'),\n                                fast);\n    return (limit <= fast);\n}\n\n\n\nAlgorithm:\n{\"Algorithm Name\": \"Adaptive Glue-Rate Hybrid Restart\", \"Scoring Function Definition\": \"Restart fires when (fast_glue_ewma > 0.9 * slow_glue_ewma) AND (decision_rate_ewma < 0.8 * avg_decision_rate), OR when stats.conflicts ≥ restart_conflict_limit. avg_decision_rate is the EWMA of decision_rate_ewma over the last k restarts (k=10).\", \"Selection Procedure\": [\"At each conflict, update fast_glue_ewma, slow_glue_ewma, and decision_rate_ewma.\", \"Compute avg_decision_rate as the EWMA over the last 10 restart intervals.\", \"Check if fast_glue_ewma > 0.9 * slow_glue_ewma AND decision_rate_ewma < 0.8 * avg_decision_rate.\", \"If condition in step 3 is true or stats.conflicts ≥ restart_conflict_limit, trigger a restart.\", \"Reset counters and update avg_decision_rate after each restart.\"], \"Tie-breaking Rules\": [\"If both scoring and conflict-limit triggers fire simultaneously, prioritize the scoring trigger.\", \"If scoring trigger is met but at decision level 0, delay restart until level > 0.\", \"If multiple restarts are possible within the same conflict, perform only one.\", \"If stable is true, double the thresholds before triggering.\"]}"}], "temperature": 0.7}}
